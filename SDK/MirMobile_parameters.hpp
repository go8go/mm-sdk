#pragma once

/*
* SDK generated by Dumper-7
*
* https://github.com/Encryqed/Dumper-7
*/

// Package: MirMobile

#include "Basic.hpp"

#include "CoreUObject_structs.hpp"
#include "MirMobile_structs.hpp"
#include "SlateCore_structs.hpp"
#include "WNGamePlugin_structs.hpp"
#include "Engine_structs.hpp"


namespace SDK::Params
{

// Function MirMobile.CutsceneActor.TestSetSkeletalMesh
// 0x0020 (0x0020 - 0x0000)
struct CutsceneActor_TestSetSkeletalMesh final
{
public:
	class FString                                 MeshPath;                                          // 0x0000(0x0010)(Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 AnimClassName;                                     // 0x0010(0x0010)(Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(CutsceneActor_TestSetSkeletalMesh) == 0x000008, "Wrong alignment on CutsceneActor_TestSetSkeletalMesh");
static_assert(sizeof(CutsceneActor_TestSetSkeletalMesh) == 0x000020, "Wrong size on CutsceneActor_TestSetSkeletalMesh");
static_assert(offsetof(CutsceneActor_TestSetSkeletalMesh, MeshPath) == 0x000000, "Member 'CutsceneActor_TestSetSkeletalMesh::MeshPath' has a wrong offset!");
static_assert(offsetof(CutsceneActor_TestSetSkeletalMesh, AnimClassName) == 0x000010, "Member 'CutsceneActor_TestSetSkeletalMesh::AnimClassName' has a wrong offset!");

// Function MirMobile.MM_AIControllerBase.AddBuffToChar
// 0x0010 (0x0010 - 0x0000)
struct MM_AIControllerBase_AddBuffToChar final
{
public:
	class AMM_CharacterPawnBase*                  PCharBase;                                         // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         NBuffTID;                                          // 0x0008(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          ReturnValue;                                       // 0x000C(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_D[0x3];                                        // 0x000D(0x0003)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(MM_AIControllerBase_AddBuffToChar) == 0x000008, "Wrong alignment on MM_AIControllerBase_AddBuffToChar");
static_assert(sizeof(MM_AIControllerBase_AddBuffToChar) == 0x000010, "Wrong size on MM_AIControllerBase_AddBuffToChar");
static_assert(offsetof(MM_AIControllerBase_AddBuffToChar, PCharBase) == 0x000000, "Member 'MM_AIControllerBase_AddBuffToChar::PCharBase' has a wrong offset!");
static_assert(offsetof(MM_AIControllerBase_AddBuffToChar, NBuffTID) == 0x000008, "Member 'MM_AIControllerBase_AddBuffToChar::NBuffTID' has a wrong offset!");
static_assert(offsetof(MM_AIControllerBase_AddBuffToChar, ReturnValue) == 0x00000C, "Member 'MM_AIControllerBase_AddBuffToChar::ReturnValue' has a wrong offset!");

// Function MirMobile.MM_AIControllerBase.AttackTarget
// 0x0008 (0x0008 - 0x0000)
struct MM_AIControllerBase_AttackTarget final
{
public:
	int32                                         NAttackTID;                                        // 0x0000(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          ReturnValue;                                       // 0x0004(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_5[0x3];                                        // 0x0005(0x0003)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(MM_AIControllerBase_AttackTarget) == 0x000004, "Wrong alignment on MM_AIControllerBase_AttackTarget");
static_assert(sizeof(MM_AIControllerBase_AttackTarget) == 0x000008, "Wrong size on MM_AIControllerBase_AttackTarget");
static_assert(offsetof(MM_AIControllerBase_AttackTarget, NAttackTID) == 0x000000, "Member 'MM_AIControllerBase_AttackTarget::NAttackTID' has a wrong offset!");
static_assert(offsetof(MM_AIControllerBase_AttackTarget, ReturnValue) == 0x000004, "Member 'MM_AIControllerBase_AttackTarget::ReturnValue' has a wrong offset!");

// Function MirMobile.MM_AIControllerBase.CompareDistance
// 0x0018 (0x0018 - 0x0000)
struct MM_AIControllerBase_CompareDistance final
{
public:
	const class AMM_CharacterPawnBase*            PCharA;                                            // 0x0000(0x0008)(ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	const class AMM_CharacterPawnBase*            PCharB;                                            // 0x0008(0x0008)(ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         ReturnValue;                                       // 0x0010(0x0004)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_14[0x4];                                       // 0x0014(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(MM_AIControllerBase_CompareDistance) == 0x000008, "Wrong alignment on MM_AIControllerBase_CompareDistance");
static_assert(sizeof(MM_AIControllerBase_CompareDistance) == 0x000018, "Wrong size on MM_AIControllerBase_CompareDistance");
static_assert(offsetof(MM_AIControllerBase_CompareDistance, PCharA) == 0x000000, "Member 'MM_AIControllerBase_CompareDistance::PCharA' has a wrong offset!");
static_assert(offsetof(MM_AIControllerBase_CompareDistance, PCharB) == 0x000008, "Member 'MM_AIControllerBase_CompareDistance::PCharB' has a wrong offset!");
static_assert(offsetof(MM_AIControllerBase_CompareDistance, ReturnValue) == 0x000010, "Member 'MM_AIControllerBase_CompareDistance::ReturnValue' has a wrong offset!");

// Function MirMobile.MM_AIControllerBase.DelBuffFromChar
// 0x0010 (0x0010 - 0x0000)
struct MM_AIControllerBase_DelBuffFromChar final
{
public:
	class AMM_CharacterPawnBase*                  PCharBase;                                         // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         NBuffTID;                                          // 0x0008(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          ReturnValue;                                       // 0x000C(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_D[0x3];                                        // 0x000D(0x0003)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(MM_AIControllerBase_DelBuffFromChar) == 0x000008, "Wrong alignment on MM_AIControllerBase_DelBuffFromChar");
static_assert(sizeof(MM_AIControllerBase_DelBuffFromChar) == 0x000010, "Wrong size on MM_AIControllerBase_DelBuffFromChar");
static_assert(offsetof(MM_AIControllerBase_DelBuffFromChar, PCharBase) == 0x000000, "Member 'MM_AIControllerBase_DelBuffFromChar::PCharBase' has a wrong offset!");
static_assert(offsetof(MM_AIControllerBase_DelBuffFromChar, NBuffTID) == 0x000008, "Member 'MM_AIControllerBase_DelBuffFromChar::NBuffTID' has a wrong offset!");
static_assert(offsetof(MM_AIControllerBase_DelBuffFromChar, ReturnValue) == 0x00000C, "Member 'MM_AIControllerBase_DelBuffFromChar::ReturnValue' has a wrong offset!");

// Function MirMobile.MM_AIControllerBase.GenTotem
// 0x0020 (0x0020 - 0x0000)
struct MM_AIControllerBase_GenTotem final
{
public:
	class AMM_CharacterPawnBase*                  PCharBase;                                         // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         NTotemID;                                          // 0x0008(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                Loc;                                               // 0x000C(0x000C)(ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          ReturnValue;                                       // 0x0018(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_19[0x7];                                       // 0x0019(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(MM_AIControllerBase_GenTotem) == 0x000008, "Wrong alignment on MM_AIControllerBase_GenTotem");
static_assert(sizeof(MM_AIControllerBase_GenTotem) == 0x000020, "Wrong size on MM_AIControllerBase_GenTotem");
static_assert(offsetof(MM_AIControllerBase_GenTotem, PCharBase) == 0x000000, "Member 'MM_AIControllerBase_GenTotem::PCharBase' has a wrong offset!");
static_assert(offsetof(MM_AIControllerBase_GenTotem, NTotemID) == 0x000008, "Member 'MM_AIControllerBase_GenTotem::NTotemID' has a wrong offset!");
static_assert(offsetof(MM_AIControllerBase_GenTotem, Loc) == 0x00000C, "Member 'MM_AIControllerBase_GenTotem::Loc' has a wrong offset!");
static_assert(offsetof(MM_AIControllerBase_GenTotem, ReturnValue) == 0x000018, "Member 'MM_AIControllerBase_GenTotem::ReturnValue' has a wrong offset!");

// Function MirMobile.MM_AIControllerBase.GetAttackID
// 0x0008 (0x0008 - 0x0000)
struct MM_AIControllerBase_GetAttackID final
{
public:
	bool                                          bLongAttack;                                       // 0x0000(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1[0x3];                                        // 0x0001(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         ReturnValue;                                       // 0x0004(0x0004)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(MM_AIControllerBase_GetAttackID) == 0x000004, "Wrong alignment on MM_AIControllerBase_GetAttackID");
static_assert(sizeof(MM_AIControllerBase_GetAttackID) == 0x000008, "Wrong size on MM_AIControllerBase_GetAttackID");
static_assert(offsetof(MM_AIControllerBase_GetAttackID, bLongAttack) == 0x000000, "Member 'MM_AIControllerBase_GetAttackID::bLongAttack' has a wrong offset!");
static_assert(offsetof(MM_AIControllerBase_GetAttackID, ReturnValue) == 0x000004, "Member 'MM_AIControllerBase_GetAttackID::ReturnValue' has a wrong offset!");

// Function MirMobile.MM_AIControllerBase.GetDirectionFromMe
// 0x0010 (0x0010 - 0x0000)
struct MM_AIControllerBase_GetDirectionFromMe final
{
public:
	const class AMM_CharacterPawnBase*            PChar;                                             // 0x0000(0x0008)(ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         Angle;                                             // 0x0008(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	E_CARDINALPOINTS                              ReturnValue;                                       // 0x000C(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_D[0x3];                                        // 0x000D(0x0003)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(MM_AIControllerBase_GetDirectionFromMe) == 0x000008, "Wrong alignment on MM_AIControllerBase_GetDirectionFromMe");
static_assert(sizeof(MM_AIControllerBase_GetDirectionFromMe) == 0x000010, "Wrong size on MM_AIControllerBase_GetDirectionFromMe");
static_assert(offsetof(MM_AIControllerBase_GetDirectionFromMe, PChar) == 0x000000, "Member 'MM_AIControllerBase_GetDirectionFromMe::PChar' has a wrong offset!");
static_assert(offsetof(MM_AIControllerBase_GetDirectionFromMe, Angle) == 0x000008, "Member 'MM_AIControllerBase_GetDirectionFromMe::Angle' has a wrong offset!");
static_assert(offsetof(MM_AIControllerBase_GetDirectionFromMe, ReturnValue) == 0x00000C, "Member 'MM_AIControllerBase_GetDirectionFromMe::ReturnValue' has a wrong offset!");

// Function MirMobile.MM_AIControllerBase.HaveCCType
// 0x0002 (0x0002 - 0x0000)
struct MM_AIControllerBase_HaveCCType final
{
public:
	ECROWD_CONTROL_TYPE                           ECCType;                                           // 0x0000(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          ReturnValue;                                       // 0x0001(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(MM_AIControllerBase_HaveCCType) == 0x000001, "Wrong alignment on MM_AIControllerBase_HaveCCType");
static_assert(sizeof(MM_AIControllerBase_HaveCCType) == 0x000002, "Wrong size on MM_AIControllerBase_HaveCCType");
static_assert(offsetof(MM_AIControllerBase_HaveCCType, ECCType) == 0x000000, "Member 'MM_AIControllerBase_HaveCCType::ECCType' has a wrong offset!");
static_assert(offsetof(MM_AIControllerBase_HaveCCType, ReturnValue) == 0x000001, "Member 'MM_AIControllerBase_HaveCCType::ReturnValue' has a wrong offset!");

// Function MirMobile.MM_AIControllerBase.HealTarget
// 0x0008 (0x0008 - 0x0000)
struct MM_AIControllerBase_HealTarget final
{
public:
	int32                                         NHealValue;                                        // 0x0000(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          ReturnValue;                                       // 0x0004(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_5[0x3];                                        // 0x0005(0x0003)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(MM_AIControllerBase_HealTarget) == 0x000004, "Wrong alignment on MM_AIControllerBase_HealTarget");
static_assert(sizeof(MM_AIControllerBase_HealTarget) == 0x000008, "Wrong size on MM_AIControllerBase_HealTarget");
static_assert(offsetof(MM_AIControllerBase_HealTarget, NHealValue) == 0x000000, "Member 'MM_AIControllerBase_HealTarget::NHealValue' has a wrong offset!");
static_assert(offsetof(MM_AIControllerBase_HealTarget, ReturnValue) == 0x000004, "Member 'MM_AIControllerBase_HealTarget::ReturnValue' has a wrong offset!");

// Function MirMobile.MM_AIControllerBase.IsCloseToChar
// 0x0010 (0x0010 - 0x0000)
struct MM_AIControllerBase_IsCloseToChar final
{
public:
	const class AMM_CharacterPawnBase*            PChar;                                             // 0x0000(0x0008)(ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         FCheckDist;                                        // 0x0008(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          ReturnValue;                                       // 0x000C(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_D[0x3];                                        // 0x000D(0x0003)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(MM_AIControllerBase_IsCloseToChar) == 0x000008, "Wrong alignment on MM_AIControllerBase_IsCloseToChar");
static_assert(sizeof(MM_AIControllerBase_IsCloseToChar) == 0x000010, "Wrong size on MM_AIControllerBase_IsCloseToChar");
static_assert(offsetof(MM_AIControllerBase_IsCloseToChar, PChar) == 0x000000, "Member 'MM_AIControllerBase_IsCloseToChar::PChar' has a wrong offset!");
static_assert(offsetof(MM_AIControllerBase_IsCloseToChar, FCheckDist) == 0x000008, "Member 'MM_AIControllerBase_IsCloseToChar::FCheckDist' has a wrong offset!");
static_assert(offsetof(MM_AIControllerBase_IsCloseToChar, ReturnValue) == 0x00000C, "Member 'MM_AIControllerBase_IsCloseToChar::ReturnValue' has a wrong offset!");

// Function MirMobile.MM_AIControllerBase.IsCloseToPos
// 0x0014 (0x0014 - 0x0000)
struct MM_AIControllerBase_IsCloseToPos final
{
public:
	struct FVector                                VPos;                                              // 0x0000(0x000C)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         FCheckDist;                                        // 0x000C(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          ReturnValue;                                       // 0x0010(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_11[0x3];                                       // 0x0011(0x0003)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(MM_AIControllerBase_IsCloseToPos) == 0x000004, "Wrong alignment on MM_AIControllerBase_IsCloseToPos");
static_assert(sizeof(MM_AIControllerBase_IsCloseToPos) == 0x000014, "Wrong size on MM_AIControllerBase_IsCloseToPos");
static_assert(offsetof(MM_AIControllerBase_IsCloseToPos, VPos) == 0x000000, "Member 'MM_AIControllerBase_IsCloseToPos::VPos' has a wrong offset!");
static_assert(offsetof(MM_AIControllerBase_IsCloseToPos, FCheckDist) == 0x00000C, "Member 'MM_AIControllerBase_IsCloseToPos::FCheckDist' has a wrong offset!");
static_assert(offsetof(MM_AIControllerBase_IsCloseToPos, ReturnValue) == 0x000010, "Member 'MM_AIControllerBase_IsCloseToPos::ReturnValue' has a wrong offset!");

// Function MirMobile.MM_AIControllerBase.IsDead
// 0x0010 (0x0010 - 0x0000)
struct MM_AIControllerBase_IsDead final
{
public:
	class AMM_CharacterPawnBase*                  PCharBase;                                         // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          ReturnValue;                                       // 0x0008(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_9[0x7];                                        // 0x0009(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(MM_AIControllerBase_IsDead) == 0x000008, "Wrong alignment on MM_AIControllerBase_IsDead");
static_assert(sizeof(MM_AIControllerBase_IsDead) == 0x000010, "Wrong size on MM_AIControllerBase_IsDead");
static_assert(offsetof(MM_AIControllerBase_IsDead, PCharBase) == 0x000000, "Member 'MM_AIControllerBase_IsDead::PCharBase' has a wrong offset!");
static_assert(offsetof(MM_AIControllerBase_IsDead, ReturnValue) == 0x000008, "Member 'MM_AIControllerBase_IsDead::ReturnValue' has a wrong offset!");

// Function MirMobile.MM_AIControllerBase.KillMonster
// 0x0008 (0x0008 - 0x0000)
struct MM_AIControllerBase_KillMonster final
{
public:
	int32                                         NMonTID;                                           // 0x0000(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          ReturnValue;                                       // 0x0004(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_5[0x3];                                        // 0x0005(0x0003)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(MM_AIControllerBase_KillMonster) == 0x000004, "Wrong alignment on MM_AIControllerBase_KillMonster");
static_assert(sizeof(MM_AIControllerBase_KillMonster) == 0x000008, "Wrong size on MM_AIControllerBase_KillMonster");
static_assert(offsetof(MM_AIControllerBase_KillMonster, NMonTID) == 0x000000, "Member 'MM_AIControllerBase_KillMonster::NMonTID' has a wrong offset!");
static_assert(offsetof(MM_AIControllerBase_KillMonster, ReturnValue) == 0x000004, "Member 'MM_AIControllerBase_KillMonster::ReturnValue' has a wrong offset!");

// Function MirMobile.MM_AIControllerBase.KillTotem
// 0x0008 (0x0008 - 0x0000)
struct MM_AIControllerBase_KillTotem final
{
public:
	int32                                         NTotemTID;                                         // 0x0000(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          ReturnValue;                                       // 0x0004(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_5[0x3];                                        // 0x0005(0x0003)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(MM_AIControllerBase_KillTotem) == 0x000004, "Wrong alignment on MM_AIControllerBase_KillTotem");
static_assert(sizeof(MM_AIControllerBase_KillTotem) == 0x000008, "Wrong size on MM_AIControllerBase_KillTotem");
static_assert(offsetof(MM_AIControllerBase_KillTotem, NTotemTID) == 0x000000, "Member 'MM_AIControllerBase_KillTotem::NTotemTID' has a wrong offset!");
static_assert(offsetof(MM_AIControllerBase_KillTotem, ReturnValue) == 0x000004, "Member 'MM_AIControllerBase_KillTotem::ReturnValue' has a wrong offset!");

// Function MirMobile.MM_AIControllerBase.MoveToDest
// 0x0010 (0x0010 - 0x0000)
struct MM_AIControllerBase_MoveToDest final
{
public:
	struct FVector                                VDestPos;                                          // 0x0000(0x000C)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          ReturnValue;                                       // 0x000C(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_D[0x3];                                        // 0x000D(0x0003)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(MM_AIControllerBase_MoveToDest) == 0x000004, "Wrong alignment on MM_AIControllerBase_MoveToDest");
static_assert(sizeof(MM_AIControllerBase_MoveToDest) == 0x000010, "Wrong size on MM_AIControllerBase_MoveToDest");
static_assert(offsetof(MM_AIControllerBase_MoveToDest, VDestPos) == 0x000000, "Member 'MM_AIControllerBase_MoveToDest::VDestPos' has a wrong offset!");
static_assert(offsetof(MM_AIControllerBase_MoveToDest, ReturnValue) == 0x00000C, "Member 'MM_AIControllerBase_MoveToDest::ReturnValue' has a wrong offset!");

// Function MirMobile.MM_AIControllerBase.NoticeMsg
// 0x0008 (0x0008 - 0x0000)
struct MM_AIControllerBase_NoticeMsg final
{
public:
	int32                                         MessageID;                                         // 0x0000(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	E_NOTICE_TARGET                               EType;                                             // 0x0004(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          ReturnValue;                                       // 0x0005(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_6[0x2];                                        // 0x0006(0x0002)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(MM_AIControllerBase_NoticeMsg) == 0x000004, "Wrong alignment on MM_AIControllerBase_NoticeMsg");
static_assert(sizeof(MM_AIControllerBase_NoticeMsg) == 0x000008, "Wrong size on MM_AIControllerBase_NoticeMsg");
static_assert(offsetof(MM_AIControllerBase_NoticeMsg, MessageID) == 0x000000, "Member 'MM_AIControllerBase_NoticeMsg::MessageID' has a wrong offset!");
static_assert(offsetof(MM_AIControllerBase_NoticeMsg, EType) == 0x000004, "Member 'MM_AIControllerBase_NoticeMsg::EType' has a wrong offset!");
static_assert(offsetof(MM_AIControllerBase_NoticeMsg, ReturnValue) == 0x000005, "Member 'MM_AIControllerBase_NoticeMsg::ReturnValue' has a wrong offset!");

// Function MirMobile.MM_AIControllerBase.Patrol
// 0x0001 (0x0001 - 0x0000)
struct MM_AIControllerBase_Patrol final
{
public:
	bool                                          ReturnValue;                                       // 0x0000(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(MM_AIControllerBase_Patrol) == 0x000001, "Wrong alignment on MM_AIControllerBase_Patrol");
static_assert(sizeof(MM_AIControllerBase_Patrol) == 0x000001, "Wrong size on MM_AIControllerBase_Patrol");
static_assert(offsetof(MM_AIControllerBase_Patrol, ReturnValue) == 0x000000, "Member 'MM_AIControllerBase_Patrol::ReturnValue' has a wrong offset!");

// Function MirMobile.MM_AIControllerBase.PlayAni
// 0x0008 (0x0008 - 0x0000)
struct MM_AIControllerBase_PlayAni final
{
public:
	int32                                         NEmotionID;                                        // 0x0000(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          ReturnValue;                                       // 0x0004(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_5[0x3];                                        // 0x0005(0x0003)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(MM_AIControllerBase_PlayAni) == 0x000004, "Wrong alignment on MM_AIControllerBase_PlayAni");
static_assert(sizeof(MM_AIControllerBase_PlayAni) == 0x000008, "Wrong size on MM_AIControllerBase_PlayAni");
static_assert(offsetof(MM_AIControllerBase_PlayAni, NEmotionID) == 0x000000, "Member 'MM_AIControllerBase_PlayAni::NEmotionID' has a wrong offset!");
static_assert(offsetof(MM_AIControllerBase_PlayAni, ReturnValue) == 0x000004, "Member 'MM_AIControllerBase_PlayAni::ReturnValue' has a wrong offset!");

// Function MirMobile.MM_AIControllerBase.RemoveEffect
// 0x000C (0x000C - 0x0000)
struct MM_AIControllerBase_RemoveEffect final
{
public:
	class FName                                   ParticleName;                                      // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          ReturnValue;                                       // 0x0008(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_9[0x3];                                        // 0x0009(0x0003)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(MM_AIControllerBase_RemoveEffect) == 0x000004, "Wrong alignment on MM_AIControllerBase_RemoveEffect");
static_assert(sizeof(MM_AIControllerBase_RemoveEffect) == 0x00000C, "Wrong size on MM_AIControllerBase_RemoveEffect");
static_assert(offsetof(MM_AIControllerBase_RemoveEffect, ParticleName) == 0x000000, "Member 'MM_AIControllerBase_RemoveEffect::ParticleName' has a wrong offset!");
static_assert(offsetof(MM_AIControllerBase_RemoveEffect, ReturnValue) == 0x000008, "Member 'MM_AIControllerBase_RemoveEffect::ReturnValue' has a wrong offset!");

// Function MirMobile.MM_AIControllerBase.RunAway
// 0x0018 (0x0018 - 0x0000)
struct MM_AIControllerBase_RunAway final
{
public:
	class AMM_CharacterPawnBase*                  PTargetChar;                                       // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         FDist;                                             // 0x0008(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         Angle;                                             // 0x000C(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          ReturnValue;                                       // 0x0010(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_11[0x7];                                       // 0x0011(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(MM_AIControllerBase_RunAway) == 0x000008, "Wrong alignment on MM_AIControllerBase_RunAway");
static_assert(sizeof(MM_AIControllerBase_RunAway) == 0x000018, "Wrong size on MM_AIControllerBase_RunAway");
static_assert(offsetof(MM_AIControllerBase_RunAway, PTargetChar) == 0x000000, "Member 'MM_AIControllerBase_RunAway::PTargetChar' has a wrong offset!");
static_assert(offsetof(MM_AIControllerBase_RunAway, FDist) == 0x000008, "Member 'MM_AIControllerBase_RunAway::FDist' has a wrong offset!");
static_assert(offsetof(MM_AIControllerBase_RunAway, Angle) == 0x00000C, "Member 'MM_AIControllerBase_RunAway::Angle' has a wrong offset!");
static_assert(offsetof(MM_AIControllerBase_RunAway, ReturnValue) == 0x000010, "Member 'MM_AIControllerBase_RunAway::ReturnValue' has a wrong offset!");

// Function MirMobile.MM_AIControllerBase.RunCC
// 0x0010 (0x0010 - 0x0000)
struct MM_AIControllerBase_RunCC final
{
public:
	class AMM_CharacterPawnBase*                  PTargetChar;                                       // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          ReturnValue;                                       // 0x0008(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_9[0x7];                                        // 0x0009(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(MM_AIControllerBase_RunCC) == 0x000008, "Wrong alignment on MM_AIControllerBase_RunCC");
static_assert(sizeof(MM_AIControllerBase_RunCC) == 0x000010, "Wrong size on MM_AIControllerBase_RunCC");
static_assert(offsetof(MM_AIControllerBase_RunCC, PTargetChar) == 0x000000, "Member 'MM_AIControllerBase_RunCC::PTargetChar' has a wrong offset!");
static_assert(offsetof(MM_AIControllerBase_RunCC, ReturnValue) == 0x000008, "Member 'MM_AIControllerBase_RunCC::ReturnValue' has a wrong offset!");

// Function MirMobile.MM_AIControllerBase.SearchCharacter
// 0x0010 (0x0010 - 0x0000)
struct MM_AIControllerBase_SearchCharacter final
{
public:
	ECharacterType                                ECharType;                                         // 0x0000(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	ETARGET_TYPE                                  ETargetType;                                       // 0x0001(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EDISTANCE_TYPE                                EDistType;                                         // 0x0002(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_3[0x5];                                        // 0x0003(0x0005)(Fixing Size After Last Property [ Dumper-7 ])
	class AMM_CharacterPawnBase*                  ReturnValue;                                       // 0x0008(0x0008)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(MM_AIControllerBase_SearchCharacter) == 0x000008, "Wrong alignment on MM_AIControllerBase_SearchCharacter");
static_assert(sizeof(MM_AIControllerBase_SearchCharacter) == 0x000010, "Wrong size on MM_AIControllerBase_SearchCharacter");
static_assert(offsetof(MM_AIControllerBase_SearchCharacter, ECharType) == 0x000000, "Member 'MM_AIControllerBase_SearchCharacter::ECharType' has a wrong offset!");
static_assert(offsetof(MM_AIControllerBase_SearchCharacter, ETargetType) == 0x000001, "Member 'MM_AIControllerBase_SearchCharacter::ETargetType' has a wrong offset!");
static_assert(offsetof(MM_AIControllerBase_SearchCharacter, EDistType) == 0x000002, "Member 'MM_AIControllerBase_SearchCharacter::EDistType' has a wrong offset!");
static_assert(offsetof(MM_AIControllerBase_SearchCharacter, ReturnValue) == 0x000008, "Member 'MM_AIControllerBase_SearchCharacter::ReturnValue' has a wrong offset!");

// Function MirMobile.MM_AIControllerBase.SearchTargets
// 0x0001 (0x0001 - 0x0000)
struct MM_AIControllerBase_SearchTargets final
{
public:
	bool                                          bAggressive;                                       // 0x0000(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(MM_AIControllerBase_SearchTargets) == 0x000001, "Wrong alignment on MM_AIControllerBase_SearchTargets");
static_assert(sizeof(MM_AIControllerBase_SearchTargets) == 0x000001, "Wrong size on MM_AIControllerBase_SearchTargets");
static_assert(offsetof(MM_AIControllerBase_SearchTargets, bAggressive) == 0x000000, "Member 'MM_AIControllerBase_SearchTargets::bAggressive' has a wrong offset!");

// Function MirMobile.MM_AIControllerBase.SetEnemyTarget
// 0x0008 (0x0008 - 0x0000)
struct MM_AIControllerBase_SetEnemyTarget final
{
public:
	class AMM_CharacterPawnBase*                  PCharBase;                                         // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(MM_AIControllerBase_SetEnemyTarget) == 0x000008, "Wrong alignment on MM_AIControllerBase_SetEnemyTarget");
static_assert(sizeof(MM_AIControllerBase_SetEnemyTarget) == 0x000008, "Wrong size on MM_AIControllerBase_SetEnemyTarget");
static_assert(offsetof(MM_AIControllerBase_SetEnemyTarget, PCharBase) == 0x000000, "Member 'MM_AIControllerBase_SetEnemyTarget::PCharBase' has a wrong offset!");

// Function MirMobile.MM_AIControllerBase.SetTarget
// 0x0008 (0x0008 - 0x0000)
struct MM_AIControllerBase_SetTarget final
{
public:
	class AMM_CharacterPawnBase*                  PCharBase;                                         // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(MM_AIControllerBase_SetTarget) == 0x000008, "Wrong alignment on MM_AIControllerBase_SetTarget");
static_assert(sizeof(MM_AIControllerBase_SetTarget) == 0x000008, "Wrong size on MM_AIControllerBase_SetTarget");
static_assert(offsetof(MM_AIControllerBase_SetTarget, PCharBase) == 0x000000, "Member 'MM_AIControllerBase_SetTarget::PCharBase' has a wrong offset!");

// Function MirMobile.MM_AIControllerBase.SpawnEffect
// 0x0014 (0x0014 - 0x0000)
struct MM_AIControllerBase_SpawnEffect final
{
public:
	class FName                                   ParticleName;                                      // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   BoneName;                                          // 0x0008(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          ReturnValue;                                       // 0x0010(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_11[0x3];                                       // 0x0011(0x0003)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(MM_AIControllerBase_SpawnEffect) == 0x000004, "Wrong alignment on MM_AIControllerBase_SpawnEffect");
static_assert(sizeof(MM_AIControllerBase_SpawnEffect) == 0x000014, "Wrong size on MM_AIControllerBase_SpawnEffect");
static_assert(offsetof(MM_AIControllerBase_SpawnEffect, ParticleName) == 0x000000, "Member 'MM_AIControllerBase_SpawnEffect::ParticleName' has a wrong offset!");
static_assert(offsetof(MM_AIControllerBase_SpawnEffect, BoneName) == 0x000008, "Member 'MM_AIControllerBase_SpawnEffect::BoneName' has a wrong offset!");
static_assert(offsetof(MM_AIControllerBase_SpawnEffect, ReturnValue) == 0x000010, "Member 'MM_AIControllerBase_SpawnEffect::ReturnValue' has a wrong offset!");

// Function MirMobile.MM_AIControllerBase.StopMoving
// 0x0001 (0x0001 - 0x0000)
struct MM_AIControllerBase_StopMoving final
{
public:
	bool                                          ReturnValue;                                       // 0x0000(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(MM_AIControllerBase_StopMoving) == 0x000001, "Wrong alignment on MM_AIControllerBase_StopMoving");
static_assert(sizeof(MM_AIControllerBase_StopMoving) == 0x000001, "Wrong size on MM_AIControllerBase_StopMoving");
static_assert(offsetof(MM_AIControllerBase_StopMoving, ReturnValue) == 0x000000, "Member 'MM_AIControllerBase_StopMoving::ReturnValue' has a wrong offset!");

// Function MirMobile.MM_AIControllerBase.Suicide
// 0x0002 (0x0002 - 0x0000)
struct MM_AIControllerBase_Suicide final
{
public:
	bool                                          bDyingAni;                                         // 0x0000(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          ReturnValue;                                       // 0x0001(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(MM_AIControllerBase_Suicide) == 0x000001, "Wrong alignment on MM_AIControllerBase_Suicide");
static_assert(sizeof(MM_AIControllerBase_Suicide) == 0x000002, "Wrong size on MM_AIControllerBase_Suicide");
static_assert(offsetof(MM_AIControllerBase_Suicide, bDyingAni) == 0x000000, "Member 'MM_AIControllerBase_Suicide::bDyingAni' has a wrong offset!");
static_assert(offsetof(MM_AIControllerBase_Suicide, ReturnValue) == 0x000001, "Member 'MM_AIControllerBase_Suicide::ReturnValue' has a wrong offset!");

// Function MirMobile.MM_AIControllerBase.SummonMonster
// 0x0020 (0x0020 - 0x0000)
struct MM_AIControllerBase_SummonMonster final
{
public:
	int32                                         NMonTID;                                           // 0x0000(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                VLoc;                                              // 0x0004(0x000C)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         RangeMax;                                          // 0x0010(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         RangeMin;                                          // 0x0014(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         Num;                                               // 0x0018(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          ReturnValue;                                       // 0x001C(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1D[0x3];                                       // 0x001D(0x0003)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(MM_AIControllerBase_SummonMonster) == 0x000004, "Wrong alignment on MM_AIControllerBase_SummonMonster");
static_assert(sizeof(MM_AIControllerBase_SummonMonster) == 0x000020, "Wrong size on MM_AIControllerBase_SummonMonster");
static_assert(offsetof(MM_AIControllerBase_SummonMonster, NMonTID) == 0x000000, "Member 'MM_AIControllerBase_SummonMonster::NMonTID' has a wrong offset!");
static_assert(offsetof(MM_AIControllerBase_SummonMonster, VLoc) == 0x000004, "Member 'MM_AIControllerBase_SummonMonster::VLoc' has a wrong offset!");
static_assert(offsetof(MM_AIControllerBase_SummonMonster, RangeMax) == 0x000010, "Member 'MM_AIControllerBase_SummonMonster::RangeMax' has a wrong offset!");
static_assert(offsetof(MM_AIControllerBase_SummonMonster, RangeMin) == 0x000014, "Member 'MM_AIControllerBase_SummonMonster::RangeMin' has a wrong offset!");
static_assert(offsetof(MM_AIControllerBase_SummonMonster, Num) == 0x000018, "Member 'MM_AIControllerBase_SummonMonster::Num' has a wrong offset!");
static_assert(offsetof(MM_AIControllerBase_SummonMonster, ReturnValue) == 0x00001C, "Member 'MM_AIControllerBase_SummonMonster::ReturnValue' has a wrong offset!");

// Function MirMobile.MM_AIControllerBase.ToggleCharShow
// 0x0010 (0x0010 - 0x0000)
struct MM_AIControllerBase_ToggleCharShow final
{
public:
	class AMM_CharacterPawnBase*                  PCharBase;                                         // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bShow;                                             // 0x0008(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          ReturnValue;                                       // 0x0009(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_A[0x6];                                        // 0x000A(0x0006)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(MM_AIControllerBase_ToggleCharShow) == 0x000008, "Wrong alignment on MM_AIControllerBase_ToggleCharShow");
static_assert(sizeof(MM_AIControllerBase_ToggleCharShow) == 0x000010, "Wrong size on MM_AIControllerBase_ToggleCharShow");
static_assert(offsetof(MM_AIControllerBase_ToggleCharShow, PCharBase) == 0x000000, "Member 'MM_AIControllerBase_ToggleCharShow::PCharBase' has a wrong offset!");
static_assert(offsetof(MM_AIControllerBase_ToggleCharShow, bShow) == 0x000008, "Member 'MM_AIControllerBase_ToggleCharShow::bShow' has a wrong offset!");
static_assert(offsetof(MM_AIControllerBase_ToggleCharShow, ReturnValue) == 0x000009, "Member 'MM_AIControllerBase_ToggleCharShow::ReturnValue' has a wrong offset!");

// Function MirMobile.MM_AIControllerBase.TraceDirTarget
// 0x0018 (0x0018 - 0x0000)
struct MM_AIControllerBase_TraceDirTarget final
{
public:
	class AMM_CharacterPawnBase*                  PTargetChar;                                       // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         Distance;                                          // 0x0008(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         Angle;                                             // 0x000C(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          ReturnValue;                                       // 0x0010(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_11[0x7];                                       // 0x0011(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(MM_AIControllerBase_TraceDirTarget) == 0x000008, "Wrong alignment on MM_AIControllerBase_TraceDirTarget");
static_assert(sizeof(MM_AIControllerBase_TraceDirTarget) == 0x000018, "Wrong size on MM_AIControllerBase_TraceDirTarget");
static_assert(offsetof(MM_AIControllerBase_TraceDirTarget, PTargetChar) == 0x000000, "Member 'MM_AIControllerBase_TraceDirTarget::PTargetChar' has a wrong offset!");
static_assert(offsetof(MM_AIControllerBase_TraceDirTarget, Distance) == 0x000008, "Member 'MM_AIControllerBase_TraceDirTarget::Distance' has a wrong offset!");
static_assert(offsetof(MM_AIControllerBase_TraceDirTarget, Angle) == 0x00000C, "Member 'MM_AIControllerBase_TraceDirTarget::Angle' has a wrong offset!");
static_assert(offsetof(MM_AIControllerBase_TraceDirTarget, ReturnValue) == 0x000010, "Member 'MM_AIControllerBase_TraceDirTarget::ReturnValue' has a wrong offset!");

// Function MirMobile.MM_AIControllerBase.TraceTarget
// 0x0010 (0x0010 - 0x0000)
struct MM_AIControllerBase_TraceTarget final
{
public:
	class AMM_CharacterPawnBase*                  PTargetChar;                                       // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          ReturnValue;                                       // 0x0008(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_9[0x7];                                        // 0x0009(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(MM_AIControllerBase_TraceTarget) == 0x000008, "Wrong alignment on MM_AIControllerBase_TraceTarget");
static_assert(sizeof(MM_AIControllerBase_TraceTarget) == 0x000010, "Wrong size on MM_AIControllerBase_TraceTarget");
static_assert(offsetof(MM_AIControllerBase_TraceTarget, PTargetChar) == 0x000000, "Member 'MM_AIControllerBase_TraceTarget::PTargetChar' has a wrong offset!");
static_assert(offsetof(MM_AIControllerBase_TraceTarget, ReturnValue) == 0x000008, "Member 'MM_AIControllerBase_TraceTarget::ReturnValue' has a wrong offset!");

// Function MirMobile.MM_AIControllerBase.WarpToChar
// 0x0010 (0x0010 - 0x0000)
struct MM_AIControllerBase_WarpToChar final
{
public:
	class AMM_CharacterPawnBase*                  PCharBase;                                         // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          ReturnValue;                                       // 0x0008(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_9[0x7];                                        // 0x0009(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(MM_AIControllerBase_WarpToChar) == 0x000008, "Wrong alignment on MM_AIControllerBase_WarpToChar");
static_assert(sizeof(MM_AIControllerBase_WarpToChar) == 0x000010, "Wrong size on MM_AIControllerBase_WarpToChar");
static_assert(offsetof(MM_AIControllerBase_WarpToChar, PCharBase) == 0x000000, "Member 'MM_AIControllerBase_WarpToChar::PCharBase' has a wrong offset!");
static_assert(offsetof(MM_AIControllerBase_WarpToChar, ReturnValue) == 0x000008, "Member 'MM_AIControllerBase_WarpToChar::ReturnValue' has a wrong offset!");

// Function MirMobile.MM_AIControllerBase.WarpToLocation
// 0x0010 (0x0010 - 0x0000)
struct MM_AIControllerBase_WarpToLocation final
{
public:
	struct FVector                                VPos;                                              // 0x0000(0x000C)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          ReturnValue;                                       // 0x000C(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_D[0x3];                                        // 0x000D(0x0003)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(MM_AIControllerBase_WarpToLocation) == 0x000004, "Wrong alignment on MM_AIControllerBase_WarpToLocation");
static_assert(sizeof(MM_AIControllerBase_WarpToLocation) == 0x000010, "Wrong size on MM_AIControllerBase_WarpToLocation");
static_assert(offsetof(MM_AIControllerBase_WarpToLocation, VPos) == 0x000000, "Member 'MM_AIControllerBase_WarpToLocation::VPos' has a wrong offset!");
static_assert(offsetof(MM_AIControllerBase_WarpToLocation, ReturnValue) == 0x00000C, "Member 'MM_AIControllerBase_WarpToLocation::ReturnValue' has a wrong offset!");

// Function MirMobile.MM_AutoBehaviorAIController.CanSkillByDeadPartyMember
// 0x000C (0x000C - 0x0000)
struct MM_AutoBehaviorAIController_CanSkillByDeadPartyMember final
{
public:
	int32                                         SkillId;                                           // 0x0000(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         Distance;                                          // 0x0004(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          ReturnValue;                                       // 0x0008(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_9[0x3];                                        // 0x0009(0x0003)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(MM_AutoBehaviorAIController_CanSkillByDeadPartyMember) == 0x000004, "Wrong alignment on MM_AutoBehaviorAIController_CanSkillByDeadPartyMember");
static_assert(sizeof(MM_AutoBehaviorAIController_CanSkillByDeadPartyMember) == 0x00000C, "Wrong size on MM_AutoBehaviorAIController_CanSkillByDeadPartyMember");
static_assert(offsetof(MM_AutoBehaviorAIController_CanSkillByDeadPartyMember, SkillId) == 0x000000, "Member 'MM_AutoBehaviorAIController_CanSkillByDeadPartyMember::SkillId' has a wrong offset!");
static_assert(offsetof(MM_AutoBehaviorAIController_CanSkillByDeadPartyMember, Distance) == 0x000004, "Member 'MM_AutoBehaviorAIController_CanSkillByDeadPartyMember::Distance' has a wrong offset!");
static_assert(offsetof(MM_AutoBehaviorAIController_CanSkillByDeadPartyMember, ReturnValue) == 0x000008, "Member 'MM_AutoBehaviorAIController_CanSkillByDeadPartyMember::ReturnValue' has a wrong offset!");

// Function MirMobile.MM_AutoBehaviorAIController.CanSkillByRate
// 0x000C (0x000C - 0x0000)
struct MM_AutoBehaviorAIController_CanSkillByRate final
{
public:
	int32                                         SkillId;                                           // 0x0000(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         Rate;                                              // 0x0004(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          ReturnValue;                                       // 0x0008(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_9[0x3];                                        // 0x0009(0x0003)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(MM_AutoBehaviorAIController_CanSkillByRate) == 0x000004, "Wrong alignment on MM_AutoBehaviorAIController_CanSkillByRate");
static_assert(sizeof(MM_AutoBehaviorAIController_CanSkillByRate) == 0x00000C, "Wrong size on MM_AutoBehaviorAIController_CanSkillByRate");
static_assert(offsetof(MM_AutoBehaviorAIController_CanSkillByRate, SkillId) == 0x000000, "Member 'MM_AutoBehaviorAIController_CanSkillByRate::SkillId' has a wrong offset!");
static_assert(offsetof(MM_AutoBehaviorAIController_CanSkillByRate, Rate) == 0x000004, "Member 'MM_AutoBehaviorAIController_CanSkillByRate::Rate' has a wrong offset!");
static_assert(offsetof(MM_AutoBehaviorAIController_CanSkillByRate, ReturnValue) == 0x000008, "Member 'MM_AutoBehaviorAIController_CanSkillByRate::ReturnValue' has a wrong offset!");

// Function MirMobile.MM_AutoBehaviorAIController.CanSkillByRateLessHP
// 0x0010 (0x0010 - 0x0000)
struct MM_AutoBehaviorAIController_CanSkillByRateLessHP final
{
public:
	int32                                         SkillId;                                           // 0x0000(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         HpPercent;                                         // 0x0004(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         Rate;                                              // 0x0008(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          ReturnValue;                                       // 0x000C(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_D[0x3];                                        // 0x000D(0x0003)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(MM_AutoBehaviorAIController_CanSkillByRateLessHP) == 0x000004, "Wrong alignment on MM_AutoBehaviorAIController_CanSkillByRateLessHP");
static_assert(sizeof(MM_AutoBehaviorAIController_CanSkillByRateLessHP) == 0x000010, "Wrong size on MM_AutoBehaviorAIController_CanSkillByRateLessHP");
static_assert(offsetof(MM_AutoBehaviorAIController_CanSkillByRateLessHP, SkillId) == 0x000000, "Member 'MM_AutoBehaviorAIController_CanSkillByRateLessHP::SkillId' has a wrong offset!");
static_assert(offsetof(MM_AutoBehaviorAIController_CanSkillByRateLessHP, HpPercent) == 0x000004, "Member 'MM_AutoBehaviorAIController_CanSkillByRateLessHP::HpPercent' has a wrong offset!");
static_assert(offsetof(MM_AutoBehaviorAIController_CanSkillByRateLessHP, Rate) == 0x000008, "Member 'MM_AutoBehaviorAIController_CanSkillByRateLessHP::Rate' has a wrong offset!");
static_assert(offsetof(MM_AutoBehaviorAIController_CanSkillByRateLessHP, ReturnValue) == 0x00000C, "Member 'MM_AutoBehaviorAIController_CanSkillByRateLessHP::ReturnValue' has a wrong offset!");

// Function MirMobile.MM_AutoBehaviorAIController.CanSkillByRateNoBuff
// 0x0010 (0x0010 - 0x0000)
struct MM_AutoBehaviorAIController_CanSkillByRateNoBuff final
{
public:
	int32                                         SkillId;                                           // 0x0000(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         BuffId;                                            // 0x0004(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         Rate;                                              // 0x0008(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          ReturnValue;                                       // 0x000C(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_D[0x3];                                        // 0x000D(0x0003)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(MM_AutoBehaviorAIController_CanSkillByRateNoBuff) == 0x000004, "Wrong alignment on MM_AutoBehaviorAIController_CanSkillByRateNoBuff");
static_assert(sizeof(MM_AutoBehaviorAIController_CanSkillByRateNoBuff) == 0x000010, "Wrong size on MM_AutoBehaviorAIController_CanSkillByRateNoBuff");
static_assert(offsetof(MM_AutoBehaviorAIController_CanSkillByRateNoBuff, SkillId) == 0x000000, "Member 'MM_AutoBehaviorAIController_CanSkillByRateNoBuff::SkillId' has a wrong offset!");
static_assert(offsetof(MM_AutoBehaviorAIController_CanSkillByRateNoBuff, BuffId) == 0x000004, "Member 'MM_AutoBehaviorAIController_CanSkillByRateNoBuff::BuffId' has a wrong offset!");
static_assert(offsetof(MM_AutoBehaviorAIController_CanSkillByRateNoBuff, Rate) == 0x000008, "Member 'MM_AutoBehaviorAIController_CanSkillByRateNoBuff::Rate' has a wrong offset!");
static_assert(offsetof(MM_AutoBehaviorAIController_CanSkillByRateNoBuff, ReturnValue) == 0x00000C, "Member 'MM_AutoBehaviorAIController_CanSkillByRateNoBuff::ReturnValue' has a wrong offset!");

// Function MirMobile.MM_AutoBehaviorAIController.CanSkillByRateOverHP
// 0x0010 (0x0010 - 0x0000)
struct MM_AutoBehaviorAIController_CanSkillByRateOverHP final
{
public:
	int32                                         SkillId;                                           // 0x0000(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         HpPercent;                                         // 0x0004(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         Rate;                                              // 0x0008(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          ReturnValue;                                       // 0x000C(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_D[0x3];                                        // 0x000D(0x0003)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(MM_AutoBehaviorAIController_CanSkillByRateOverHP) == 0x000004, "Wrong alignment on MM_AutoBehaviorAIController_CanSkillByRateOverHP");
static_assert(sizeof(MM_AutoBehaviorAIController_CanSkillByRateOverHP) == 0x000010, "Wrong size on MM_AutoBehaviorAIController_CanSkillByRateOverHP");
static_assert(offsetof(MM_AutoBehaviorAIController_CanSkillByRateOverHP, SkillId) == 0x000000, "Member 'MM_AutoBehaviorAIController_CanSkillByRateOverHP::SkillId' has a wrong offset!");
static_assert(offsetof(MM_AutoBehaviorAIController_CanSkillByRateOverHP, HpPercent) == 0x000004, "Member 'MM_AutoBehaviorAIController_CanSkillByRateOverHP::HpPercent' has a wrong offset!");
static_assert(offsetof(MM_AutoBehaviorAIController_CanSkillByRateOverHP, Rate) == 0x000008, "Member 'MM_AutoBehaviorAIController_CanSkillByRateOverHP::Rate' has a wrong offset!");
static_assert(offsetof(MM_AutoBehaviorAIController_CanSkillByRateOverHP, ReturnValue) == 0x00000C, "Member 'MM_AutoBehaviorAIController_CanSkillByRateOverHP::ReturnValue' has a wrong offset!");

// Function MirMobile.MM_AutoBehaviorAIController.CanSkillByTargetInDistance
// 0x0010 (0x0010 - 0x0000)
struct MM_AutoBehaviorAIController_CanSkillByTargetInDistance final
{
public:
	int32                                         SkillId;                                           // 0x0000(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         Distance;                                          // 0x0004(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         Rate;                                              // 0x0008(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          ReturnValue;                                       // 0x000C(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_D[0x3];                                        // 0x000D(0x0003)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(MM_AutoBehaviorAIController_CanSkillByTargetInDistance) == 0x000004, "Wrong alignment on MM_AutoBehaviorAIController_CanSkillByTargetInDistance");
static_assert(sizeof(MM_AutoBehaviorAIController_CanSkillByTargetInDistance) == 0x000010, "Wrong size on MM_AutoBehaviorAIController_CanSkillByTargetInDistance");
static_assert(offsetof(MM_AutoBehaviorAIController_CanSkillByTargetInDistance, SkillId) == 0x000000, "Member 'MM_AutoBehaviorAIController_CanSkillByTargetInDistance::SkillId' has a wrong offset!");
static_assert(offsetof(MM_AutoBehaviorAIController_CanSkillByTargetInDistance, Distance) == 0x000004, "Member 'MM_AutoBehaviorAIController_CanSkillByTargetInDistance::Distance' has a wrong offset!");
static_assert(offsetof(MM_AutoBehaviorAIController_CanSkillByTargetInDistance, Rate) == 0x000008, "Member 'MM_AutoBehaviorAIController_CanSkillByTargetInDistance::Rate' has a wrong offset!");
static_assert(offsetof(MM_AutoBehaviorAIController_CanSkillByTargetInDistance, ReturnValue) == 0x00000C, "Member 'MM_AutoBehaviorAIController_CanSkillByTargetInDistance::ReturnValue' has a wrong offset!");

// Function MirMobile.MM_AutoBehaviorAIController.CanSkillByTargetOverDistance
// 0x0010 (0x0010 - 0x0000)
struct MM_AutoBehaviorAIController_CanSkillByTargetOverDistance final
{
public:
	int32                                         SkillId;                                           // 0x0000(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         Distance;                                          // 0x0004(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         Rate;                                              // 0x0008(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          ReturnValue;                                       // 0x000C(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_D[0x3];                                        // 0x000D(0x0003)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(MM_AutoBehaviorAIController_CanSkillByTargetOverDistance) == 0x000004, "Wrong alignment on MM_AutoBehaviorAIController_CanSkillByTargetOverDistance");
static_assert(sizeof(MM_AutoBehaviorAIController_CanSkillByTargetOverDistance) == 0x000010, "Wrong size on MM_AutoBehaviorAIController_CanSkillByTargetOverDistance");
static_assert(offsetof(MM_AutoBehaviorAIController_CanSkillByTargetOverDistance, SkillId) == 0x000000, "Member 'MM_AutoBehaviorAIController_CanSkillByTargetOverDistance::SkillId' has a wrong offset!");
static_assert(offsetof(MM_AutoBehaviorAIController_CanSkillByTargetOverDistance, Distance) == 0x000004, "Member 'MM_AutoBehaviorAIController_CanSkillByTargetOverDistance::Distance' has a wrong offset!");
static_assert(offsetof(MM_AutoBehaviorAIController_CanSkillByTargetOverDistance, Rate) == 0x000008, "Member 'MM_AutoBehaviorAIController_CanSkillByTargetOverDistance::Rate' has a wrong offset!");
static_assert(offsetof(MM_AutoBehaviorAIController_CanSkillByTargetOverDistance, ReturnValue) == 0x00000C, "Member 'MM_AutoBehaviorAIController_CanSkillByTargetOverDistance::ReturnValue' has a wrong offset!");

// Function MirMobile.MM_AutoBehaviorAIController.CheckCanSkill
// 0x0001 (0x0001 - 0x0000)
struct MM_AutoBehaviorAIController_CheckCanSkill final
{
public:
	bool                                          ReturnValue;                                       // 0x0000(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(MM_AutoBehaviorAIController_CheckCanSkill) == 0x000001, "Wrong alignment on MM_AutoBehaviorAIController_CheckCanSkill");
static_assert(sizeof(MM_AutoBehaviorAIController_CheckCanSkill) == 0x000001, "Wrong size on MM_AutoBehaviorAIController_CheckCanSkill");
static_assert(offsetof(MM_AutoBehaviorAIController_CheckCanSkill, ReturnValue) == 0x000000, "Member 'MM_AutoBehaviorAIController_CheckCanSkill::ReturnValue' has a wrong offset!");

// Function MirMobile.MM_AutoBehaviorAIController.CheckOnSmiteSkills
// 0x0001 (0x0001 - 0x0000)
struct MM_AutoBehaviorAIController_CheckOnSmiteSkills final
{
public:
	bool                                          ReturnValue;                                       // 0x0000(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(MM_AutoBehaviorAIController_CheckOnSmiteSkills) == 0x000001, "Wrong alignment on MM_AutoBehaviorAIController_CheckOnSmiteSkills");
static_assert(sizeof(MM_AutoBehaviorAIController_CheckOnSmiteSkills) == 0x000001, "Wrong size on MM_AutoBehaviorAIController_CheckOnSmiteSkills");
static_assert(offsetof(MM_AutoBehaviorAIController_CheckOnSmiteSkills, ReturnValue) == 0x000000, "Member 'MM_AutoBehaviorAIController_CheckOnSmiteSkills::ReturnValue' has a wrong offset!");

// Function MirMobile.MM_AutoBehaviorAIController.CheckSmiteSkillByRate
// 0x0008 (0x0008 - 0x0000)
struct MM_AutoBehaviorAIController_CheckSmiteSkillByRate final
{
public:
	float                                         Rate;                                              // 0x0000(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          ReturnValue;                                       // 0x0004(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_5[0x3];                                        // 0x0005(0x0003)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(MM_AutoBehaviorAIController_CheckSmiteSkillByRate) == 0x000004, "Wrong alignment on MM_AutoBehaviorAIController_CheckSmiteSkillByRate");
static_assert(sizeof(MM_AutoBehaviorAIController_CheckSmiteSkillByRate) == 0x000008, "Wrong size on MM_AutoBehaviorAIController_CheckSmiteSkillByRate");
static_assert(offsetof(MM_AutoBehaviorAIController_CheckSmiteSkillByRate, Rate) == 0x000000, "Member 'MM_AutoBehaviorAIController_CheckSmiteSkillByRate::Rate' has a wrong offset!");
static_assert(offsetof(MM_AutoBehaviorAIController_CheckSmiteSkillByRate, ReturnValue) == 0x000004, "Member 'MM_AutoBehaviorAIController_CheckSmiteSkillByRate::ReturnValue' has a wrong offset!");

// Function MirMobile.MM_AutoBehaviorAIController.ExceptSkillByEnemyInDistance
// 0x0008 (0x0008 - 0x0000)
struct MM_AutoBehaviorAIController_ExceptSkillByEnemyInDistance final
{
public:
	int32                                         SkillId;                                           // 0x0000(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         Distance;                                          // 0x0004(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(MM_AutoBehaviorAIController_ExceptSkillByEnemyInDistance) == 0x000004, "Wrong alignment on MM_AutoBehaviorAIController_ExceptSkillByEnemyInDistance");
static_assert(sizeof(MM_AutoBehaviorAIController_ExceptSkillByEnemyInDistance) == 0x000008, "Wrong size on MM_AutoBehaviorAIController_ExceptSkillByEnemyInDistance");
static_assert(offsetof(MM_AutoBehaviorAIController_ExceptSkillByEnemyInDistance, SkillId) == 0x000000, "Member 'MM_AutoBehaviorAIController_ExceptSkillByEnemyInDistance::SkillId' has a wrong offset!");
static_assert(offsetof(MM_AutoBehaviorAIController_ExceptSkillByEnemyInDistance, Distance) == 0x000004, "Member 'MM_AutoBehaviorAIController_ExceptSkillByEnemyInDistance::Distance' has a wrong offset!");

// Function MirMobile.MM_AutoBehaviorAIController.ExceptSkillByHasBuff
// 0x0008 (0x0008 - 0x0000)
struct MM_AutoBehaviorAIController_ExceptSkillByHasBuff final
{
public:
	int32                                         SkillId;                                           // 0x0000(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         BuffId;                                            // 0x0004(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(MM_AutoBehaviorAIController_ExceptSkillByHasBuff) == 0x000004, "Wrong alignment on MM_AutoBehaviorAIController_ExceptSkillByHasBuff");
static_assert(sizeof(MM_AutoBehaviorAIController_ExceptSkillByHasBuff) == 0x000008, "Wrong size on MM_AutoBehaviorAIController_ExceptSkillByHasBuff");
static_assert(offsetof(MM_AutoBehaviorAIController_ExceptSkillByHasBuff, SkillId) == 0x000000, "Member 'MM_AutoBehaviorAIController_ExceptSkillByHasBuff::SkillId' has a wrong offset!");
static_assert(offsetof(MM_AutoBehaviorAIController_ExceptSkillByHasBuff, BuffId) == 0x000004, "Member 'MM_AutoBehaviorAIController_ExceptSkillByHasBuff::BuffId' has a wrong offset!");

// Function MirMobile.MM_AutoBehaviorAIController.ExceptSkillByLessHP
// 0x0008 (0x0008 - 0x0000)
struct MM_AutoBehaviorAIController_ExceptSkillByLessHP final
{
public:
	int32                                         SkillId;                                           // 0x0000(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         Rate;                                              // 0x0004(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(MM_AutoBehaviorAIController_ExceptSkillByLessHP) == 0x000004, "Wrong alignment on MM_AutoBehaviorAIController_ExceptSkillByLessHP");
static_assert(sizeof(MM_AutoBehaviorAIController_ExceptSkillByLessHP) == 0x000008, "Wrong size on MM_AutoBehaviorAIController_ExceptSkillByLessHP");
static_assert(offsetof(MM_AutoBehaviorAIController_ExceptSkillByLessHP, SkillId) == 0x000000, "Member 'MM_AutoBehaviorAIController_ExceptSkillByLessHP::SkillId' has a wrong offset!");
static_assert(offsetof(MM_AutoBehaviorAIController_ExceptSkillByLessHP, Rate) == 0x000004, "Member 'MM_AutoBehaviorAIController_ExceptSkillByLessHP::Rate' has a wrong offset!");

// Function MirMobile.MM_AutoBehaviorAIController.ExceptSkillByLessMP
// 0x0008 (0x0008 - 0x0000)
struct MM_AutoBehaviorAIController_ExceptSkillByLessMP final
{
public:
	int32                                         SkillId;                                           // 0x0000(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         Rate;                                              // 0x0004(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(MM_AutoBehaviorAIController_ExceptSkillByLessMP) == 0x000004, "Wrong alignment on MM_AutoBehaviorAIController_ExceptSkillByLessMP");
static_assert(sizeof(MM_AutoBehaviorAIController_ExceptSkillByLessMP) == 0x000008, "Wrong size on MM_AutoBehaviorAIController_ExceptSkillByLessMP");
static_assert(offsetof(MM_AutoBehaviorAIController_ExceptSkillByLessMP, SkillId) == 0x000000, "Member 'MM_AutoBehaviorAIController_ExceptSkillByLessMP::SkillId' has a wrong offset!");
static_assert(offsetof(MM_AutoBehaviorAIController_ExceptSkillByLessMP, Rate) == 0x000004, "Member 'MM_AutoBehaviorAIController_ExceptSkillByLessMP::Rate' has a wrong offset!");

// Function MirMobile.MM_AutoBehaviorAIController.ExceptSkillByNoEnemyInDistance
// 0x0008 (0x0008 - 0x0000)
struct MM_AutoBehaviorAIController_ExceptSkillByNoEnemyInDistance final
{
public:
	int32                                         SkillId;                                           // 0x0000(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         Distance;                                          // 0x0004(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(MM_AutoBehaviorAIController_ExceptSkillByNoEnemyInDistance) == 0x000004, "Wrong alignment on MM_AutoBehaviorAIController_ExceptSkillByNoEnemyInDistance");
static_assert(sizeof(MM_AutoBehaviorAIController_ExceptSkillByNoEnemyInDistance) == 0x000008, "Wrong size on MM_AutoBehaviorAIController_ExceptSkillByNoEnemyInDistance");
static_assert(offsetof(MM_AutoBehaviorAIController_ExceptSkillByNoEnemyInDistance, SkillId) == 0x000000, "Member 'MM_AutoBehaviorAIController_ExceptSkillByNoEnemyInDistance::SkillId' has a wrong offset!");
static_assert(offsetof(MM_AutoBehaviorAIController_ExceptSkillByNoEnemyInDistance, Distance) == 0x000004, "Member 'MM_AutoBehaviorAIController_ExceptSkillByNoEnemyInDistance::Distance' has a wrong offset!");

// Function MirMobile.MM_AutoBehaviorAIController.ExceptSkillByOverHP
// 0x0008 (0x0008 - 0x0000)
struct MM_AutoBehaviorAIController_ExceptSkillByOverHP final
{
public:
	int32                                         SkillId;                                           // 0x0000(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         Rate;                                              // 0x0004(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(MM_AutoBehaviorAIController_ExceptSkillByOverHP) == 0x000004, "Wrong alignment on MM_AutoBehaviorAIController_ExceptSkillByOverHP");
static_assert(sizeof(MM_AutoBehaviorAIController_ExceptSkillByOverHP) == 0x000008, "Wrong size on MM_AutoBehaviorAIController_ExceptSkillByOverHP");
static_assert(offsetof(MM_AutoBehaviorAIController_ExceptSkillByOverHP, SkillId) == 0x000000, "Member 'MM_AutoBehaviorAIController_ExceptSkillByOverHP::SkillId' has a wrong offset!");
static_assert(offsetof(MM_AutoBehaviorAIController_ExceptSkillByOverHP, Rate) == 0x000004, "Member 'MM_AutoBehaviorAIController_ExceptSkillByOverHP::Rate' has a wrong offset!");

// Function MirMobile.MM_AutoBehaviorAIController.ExceptSkillByTargetInDistance
// 0x0008 (0x0008 - 0x0000)
struct MM_AutoBehaviorAIController_ExceptSkillByTargetInDistance final
{
public:
	int32                                         SkillId;                                           // 0x0000(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         Distance;                                          // 0x0004(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(MM_AutoBehaviorAIController_ExceptSkillByTargetInDistance) == 0x000004, "Wrong alignment on MM_AutoBehaviorAIController_ExceptSkillByTargetInDistance");
static_assert(sizeof(MM_AutoBehaviorAIController_ExceptSkillByTargetInDistance) == 0x000008, "Wrong size on MM_AutoBehaviorAIController_ExceptSkillByTargetInDistance");
static_assert(offsetof(MM_AutoBehaviorAIController_ExceptSkillByTargetInDistance, SkillId) == 0x000000, "Member 'MM_AutoBehaviorAIController_ExceptSkillByTargetInDistance::SkillId' has a wrong offset!");
static_assert(offsetof(MM_AutoBehaviorAIController_ExceptSkillByTargetInDistance, Distance) == 0x000004, "Member 'MM_AutoBehaviorAIController_ExceptSkillByTargetInDistance::Distance' has a wrong offset!");

// Function MirMobile.MM_AutoBehaviorAIController.ExcuteSkill
// 0x0001 (0x0001 - 0x0000)
struct MM_AutoBehaviorAIController_ExcuteSkill final
{
public:
	bool                                          ReturnValue;                                       // 0x0000(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(MM_AutoBehaviorAIController_ExcuteSkill) == 0x000001, "Wrong alignment on MM_AutoBehaviorAIController_ExcuteSkill");
static_assert(sizeof(MM_AutoBehaviorAIController_ExcuteSkill) == 0x000001, "Wrong size on MM_AutoBehaviorAIController_ExcuteSkill");
static_assert(offsetof(MM_AutoBehaviorAIController_ExcuteSkill, ReturnValue) == 0x000000, "Member 'MM_AutoBehaviorAIController_ExcuteSkill::ReturnValue' has a wrong offset!");

// Function MirMobile.MM_AutoBehaviorAIController.IsAttacking
// 0x0001 (0x0001 - 0x0000)
struct MM_AutoBehaviorAIController_IsAttacking final
{
public:
	bool                                          ReturnValue;                                       // 0x0000(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(MM_AutoBehaviorAIController_IsAttacking) == 0x000001, "Wrong alignment on MM_AutoBehaviorAIController_IsAttacking");
static_assert(sizeof(MM_AutoBehaviorAIController_IsAttacking) == 0x000001, "Wrong size on MM_AutoBehaviorAIController_IsAttacking");
static_assert(offsetof(MM_AutoBehaviorAIController_IsAttacking, ReturnValue) == 0x000000, "Member 'MM_AutoBehaviorAIController_IsAttacking::ReturnValue' has a wrong offset!");

// Function MirMobile.MM_AutoBehaviorAIController.IsOperating
// 0x0001 (0x0001 - 0x0000)
struct MM_AutoBehaviorAIController_IsOperating final
{
public:
	bool                                          ReturnValue;                                       // 0x0000(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(MM_AutoBehaviorAIController_IsOperating) == 0x000001, "Wrong alignment on MM_AutoBehaviorAIController_IsOperating");
static_assert(sizeof(MM_AutoBehaviorAIController_IsOperating) == 0x000001, "Wrong size on MM_AutoBehaviorAIController_IsOperating");
static_assert(offsetof(MM_AutoBehaviorAIController_IsOperating, ReturnValue) == 0x000000, "Member 'MM_AutoBehaviorAIController_IsOperating::ReturnValue' has a wrong offset!");

// Function MirMobile.MM_AutoBehaviorAIController.IsSetTargetCharacter
// 0x0001 (0x0001 - 0x0000)
struct MM_AutoBehaviorAIController_IsSetTargetCharacter final
{
public:
	bool                                          ReturnValue;                                       // 0x0000(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(MM_AutoBehaviorAIController_IsSetTargetCharacter) == 0x000001, "Wrong alignment on MM_AutoBehaviorAIController_IsSetTargetCharacter");
static_assert(sizeof(MM_AutoBehaviorAIController_IsSetTargetCharacter) == 0x000001, "Wrong size on MM_AutoBehaviorAIController_IsSetTargetCharacter");
static_assert(offsetof(MM_AutoBehaviorAIController_IsSetTargetCharacter, ReturnValue) == 0x000000, "Member 'MM_AutoBehaviorAIController_IsSetTargetCharacter::ReturnValue' has a wrong offset!");

// Function MirMobile.MM_AutoBehaviorAIController.IsSetTargetObject
// 0x0001 (0x0001 - 0x0000)
struct MM_AutoBehaviorAIController_IsSetTargetObject final
{
public:
	bool                                          ReturnValue;                                       // 0x0000(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(MM_AutoBehaviorAIController_IsSetTargetObject) == 0x000001, "Wrong alignment on MM_AutoBehaviorAIController_IsSetTargetObject");
static_assert(sizeof(MM_AutoBehaviorAIController_IsSetTargetObject) == 0x000001, "Wrong size on MM_AutoBehaviorAIController_IsSetTargetObject");
static_assert(offsetof(MM_AutoBehaviorAIController_IsSetTargetObject, ReturnValue) == 0x000000, "Member 'MM_AutoBehaviorAIController_IsSetTargetObject::ReturnValue' has a wrong offset!");

// Function MirMobile.MM_AutoBehaviorAIController.IsTracing
// 0x0001 (0x0001 - 0x0000)
struct MM_AutoBehaviorAIController_IsTracing final
{
public:
	bool                                          ReturnValue;                                       // 0x0000(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(MM_AutoBehaviorAIController_IsTracing) == 0x000001, "Wrong alignment on MM_AutoBehaviorAIController_IsTracing");
static_assert(sizeof(MM_AutoBehaviorAIController_IsTracing) == 0x000001, "Wrong size on MM_AutoBehaviorAIController_IsTracing");
static_assert(offsetof(MM_AutoBehaviorAIController_IsTracing, ReturnValue) == 0x000000, "Member 'MM_AutoBehaviorAIController_IsTracing::ReturnValue' has a wrong offset!");

// Function MirMobile.MM_AutoBehaviorAIController.ReturnToCenter
// 0x0001 (0x0001 - 0x0000)
struct MM_AutoBehaviorAIController_ReturnToCenter final
{
public:
	bool                                          ReturnValue;                                       // 0x0000(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(MM_AutoBehaviorAIController_ReturnToCenter) == 0x000001, "Wrong alignment on MM_AutoBehaviorAIController_ReturnToCenter");
static_assert(sizeof(MM_AutoBehaviorAIController_ReturnToCenter) == 0x000001, "Wrong size on MM_AutoBehaviorAIController_ReturnToCenter");
static_assert(offsetof(MM_AutoBehaviorAIController_ReturnToCenter, ReturnValue) == 0x000000, "Member 'MM_AutoBehaviorAIController_ReturnToCenter::ReturnValue' has a wrong offset!");

// Function MirMobile.MM_AutoBehaviorAIController.SearchGather
// 0x0001 (0x0001 - 0x0000)
struct MM_AutoBehaviorAIController_SearchGather final
{
public:
	bool                                          ReturnValue;                                       // 0x0000(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(MM_AutoBehaviorAIController_SearchGather) == 0x000001, "Wrong alignment on MM_AutoBehaviorAIController_SearchGather");
static_assert(sizeof(MM_AutoBehaviorAIController_SearchGather) == 0x000001, "Wrong size on MM_AutoBehaviorAIController_SearchGather");
static_assert(offsetof(MM_AutoBehaviorAIController_SearchGather, ReturnValue) == 0x000000, "Member 'MM_AutoBehaviorAIController_SearchGather::ReturnValue' has a wrong offset!");

// Function MirMobile.MM_AutoBehaviorAIController.SearchQuestAnyTarget
// 0x0001 (0x0001 - 0x0000)
struct MM_AutoBehaviorAIController_SearchQuestAnyTarget final
{
public:
	bool                                          ReturnValue;                                       // 0x0000(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(MM_AutoBehaviorAIController_SearchQuestAnyTarget) == 0x000001, "Wrong alignment on MM_AutoBehaviorAIController_SearchQuestAnyTarget");
static_assert(sizeof(MM_AutoBehaviorAIController_SearchQuestAnyTarget) == 0x000001, "Wrong size on MM_AutoBehaviorAIController_SearchQuestAnyTarget");
static_assert(offsetof(MM_AutoBehaviorAIController_SearchQuestAnyTarget, ReturnValue) == 0x000000, "Member 'MM_AutoBehaviorAIController_SearchQuestAnyTarget::ReturnValue' has a wrong offset!");

// Function MirMobile.MM_AutoBehaviorAIController.SearchQuestTarget
// 0x0001 (0x0001 - 0x0000)
struct MM_AutoBehaviorAIController_SearchQuestTarget final
{
public:
	bool                                          ReturnValue;                                       // 0x0000(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(MM_AutoBehaviorAIController_SearchQuestTarget) == 0x000001, "Wrong alignment on MM_AutoBehaviorAIController_SearchQuestTarget");
static_assert(sizeof(MM_AutoBehaviorAIController_SearchQuestTarget) == 0x000001, "Wrong size on MM_AutoBehaviorAIController_SearchQuestTarget");
static_assert(offsetof(MM_AutoBehaviorAIController_SearchQuestTarget, ReturnValue) == 0x000000, "Member 'MM_AutoBehaviorAIController_SearchQuestTarget::ReturnValue' has a wrong offset!");

// Function MirMobile.MM_AutoBehaviorAIController.SearchQuestTargetAroundNPC
// 0x0001 (0x0001 - 0x0000)
struct MM_AutoBehaviorAIController_SearchQuestTargetAroundNPC final
{
public:
	bool                                          ReturnValue;                                       // 0x0000(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(MM_AutoBehaviorAIController_SearchQuestTargetAroundNPC) == 0x000001, "Wrong alignment on MM_AutoBehaviorAIController_SearchQuestTargetAroundNPC");
static_assert(sizeof(MM_AutoBehaviorAIController_SearchQuestTargetAroundNPC) == 0x000001, "Wrong size on MM_AutoBehaviorAIController_SearchQuestTargetAroundNPC");
static_assert(offsetof(MM_AutoBehaviorAIController_SearchQuestTargetAroundNPC, ReturnValue) == 0x000000, "Member 'MM_AutoBehaviorAIController_SearchQuestTargetAroundNPC::ReturnValue' has a wrong offset!");

// Function MirMobile.MM_AutoBehaviorAIController.SearchQuestTargetGrade
// 0x0001 (0x0001 - 0x0000)
struct MM_AutoBehaviorAIController_SearchQuestTargetGrade final
{
public:
	bool                                          ReturnValue;                                       // 0x0000(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(MM_AutoBehaviorAIController_SearchQuestTargetGrade) == 0x000001, "Wrong alignment on MM_AutoBehaviorAIController_SearchQuestTargetGrade");
static_assert(sizeof(MM_AutoBehaviorAIController_SearchQuestTargetGrade) == 0x000001, "Wrong size on MM_AutoBehaviorAIController_SearchQuestTargetGrade");
static_assert(offsetof(MM_AutoBehaviorAIController_SearchQuestTargetGrade, ReturnValue) == 0x000000, "Member 'MM_AutoBehaviorAIController_SearchQuestTargetGrade::ReturnValue' has a wrong offset!");

// Function MirMobile.MM_AutoBehaviorAIController.SearchQuestTargetGroupID
// 0x0001 (0x0001 - 0x0000)
struct MM_AutoBehaviorAIController_SearchQuestTargetGroupID final
{
public:
	bool                                          ReturnValue;                                       // 0x0000(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(MM_AutoBehaviorAIController_SearchQuestTargetGroupID) == 0x000001, "Wrong alignment on MM_AutoBehaviorAIController_SearchQuestTargetGroupID");
static_assert(sizeof(MM_AutoBehaviorAIController_SearchQuestTargetGroupID) == 0x000001, "Wrong size on MM_AutoBehaviorAIController_SearchQuestTargetGroupID");
static_assert(offsetof(MM_AutoBehaviorAIController_SearchQuestTargetGroupID, ReturnValue) == 0x000000, "Member 'MM_AutoBehaviorAIController_SearchQuestTargetGroupID::ReturnValue' has a wrong offset!");

// Function MirMobile.MM_AutoBehaviorAIController.SearchQuestTargetID
// 0x0001 (0x0001 - 0x0000)
struct MM_AutoBehaviorAIController_SearchQuestTargetID final
{
public:
	bool                                          ReturnValue;                                       // 0x0000(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(MM_AutoBehaviorAIController_SearchQuestTargetID) == 0x000001, "Wrong alignment on MM_AutoBehaviorAIController_SearchQuestTargetID");
static_assert(sizeof(MM_AutoBehaviorAIController_SearchQuestTargetID) == 0x000001, "Wrong size on MM_AutoBehaviorAIController_SearchQuestTargetID");
static_assert(offsetof(MM_AutoBehaviorAIController_SearchQuestTargetID, ReturnValue) == 0x000000, "Member 'MM_AutoBehaviorAIController_SearchQuestTargetID::ReturnValue' has a wrong offset!");

// Function MirMobile.MM_AutoBehaviorAIController.SearchTarget
// 0x0001 (0x0001 - 0x0000)
struct MM_AutoBehaviorAIController_SearchTarget final
{
public:
	bool                                          ReturnValue;                                       // 0x0000(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(MM_AutoBehaviorAIController_SearchTarget) == 0x000001, "Wrong alignment on MM_AutoBehaviorAIController_SearchTarget");
static_assert(sizeof(MM_AutoBehaviorAIController_SearchTarget) == 0x000001, "Wrong size on MM_AutoBehaviorAIController_SearchTarget");
static_assert(offsetof(MM_AutoBehaviorAIController_SearchTarget, ReturnValue) == 0x000000, "Member 'MM_AutoBehaviorAIController_SearchTarget::ReturnValue' has a wrong offset!");

// Function MirMobile.MM_AutoBehaviorAIController.IsInQuestCompleteZone
// 0x0001 (0x0001 - 0x0000)
struct MM_AutoBehaviorAIController_IsInQuestCompleteZone final
{
public:
	bool                                          ReturnValue;                                       // 0x0000(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(MM_AutoBehaviorAIController_IsInQuestCompleteZone) == 0x000001, "Wrong alignment on MM_AutoBehaviorAIController_IsInQuestCompleteZone");
static_assert(sizeof(MM_AutoBehaviorAIController_IsInQuestCompleteZone) == 0x000001, "Wrong size on MM_AutoBehaviorAIController_IsInQuestCompleteZone");
static_assert(offsetof(MM_AutoBehaviorAIController_IsInQuestCompleteZone, ReturnValue) == 0x000000, "Member 'MM_AutoBehaviorAIController_IsInQuestCompleteZone::ReturnValue' has a wrong offset!");

// Function MirMobile.CutsceneActorAnimInstance.GetTest01Anim
// 0x0008 (0x0008 - 0x0000)
struct CutsceneActorAnimInstance_GetTest01Anim final
{
public:
	class UAnimSequenceBase*                      ReturnValue;                                       // 0x0000(0x0008)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(CutsceneActorAnimInstance_GetTest01Anim) == 0x000008, "Wrong alignment on CutsceneActorAnimInstance_GetTest01Anim");
static_assert(sizeof(CutsceneActorAnimInstance_GetTest01Anim) == 0x000008, "Wrong size on CutsceneActorAnimInstance_GetTest01Anim");
static_assert(offsetof(CutsceneActorAnimInstance_GetTest01Anim, ReturnValue) == 0x000000, "Member 'CutsceneActorAnimInstance_GetTest01Anim::ReturnValue' has a wrong offset!");

// Function MirMobile.CutsceneActorAnimInstance.GetTest02Anim
// 0x0008 (0x0008 - 0x0000)
struct CutsceneActorAnimInstance_GetTest02Anim final
{
public:
	class UAnimSequenceBase*                      ReturnValue;                                       // 0x0000(0x0008)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(CutsceneActorAnimInstance_GetTest02Anim) == 0x000008, "Wrong alignment on CutsceneActorAnimInstance_GetTest02Anim");
static_assert(sizeof(CutsceneActorAnimInstance_GetTest02Anim) == 0x000008, "Wrong size on CutsceneActorAnimInstance_GetTest02Anim");
static_assert(offsetof(CutsceneActorAnimInstance_GetTest02Anim, ReturnValue) == 0x000000, "Member 'CutsceneActorAnimInstance_GetTest02Anim::ReturnValue' has a wrong offset!");

// Function MirMobile.MirSoundStatics.ChangeSoundVolume
// 0x0010 (0x0010 - 0x0000)
struct MirSoundStatics_ChangeSoundVolume final
{
public:
	EMirSoundClass                                SoundType;                                         // 0x0000(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1[0x3];                                        // 0x0001(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         Volume;                                            // 0x0004(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         FadeInTime;                                        // 0x0008(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          ReturnValue;                                       // 0x000C(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_D[0x3];                                        // 0x000D(0x0003)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(MirSoundStatics_ChangeSoundVolume) == 0x000004, "Wrong alignment on MirSoundStatics_ChangeSoundVolume");
static_assert(sizeof(MirSoundStatics_ChangeSoundVolume) == 0x000010, "Wrong size on MirSoundStatics_ChangeSoundVolume");
static_assert(offsetof(MirSoundStatics_ChangeSoundVolume, SoundType) == 0x000000, "Member 'MirSoundStatics_ChangeSoundVolume::SoundType' has a wrong offset!");
static_assert(offsetof(MirSoundStatics_ChangeSoundVolume, Volume) == 0x000004, "Member 'MirSoundStatics_ChangeSoundVolume::Volume' has a wrong offset!");
static_assert(offsetof(MirSoundStatics_ChangeSoundVolume, FadeInTime) == 0x000008, "Member 'MirSoundStatics_ChangeSoundVolume::FadeInTime' has a wrong offset!");
static_assert(offsetof(MirSoundStatics_ChangeSoundVolume, ReturnValue) == 0x00000C, "Member 'MirSoundStatics_ChangeSoundVolume::ReturnValue' has a wrong offset!");

// Function MirMobile.MirSoundStatics.GetPlayNotifySound
// 0x0001 (0x0001 - 0x0000)
struct MirSoundStatics_GetPlayNotifySound final
{
public:
	bool                                          ReturnValue;                                       // 0x0000(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(MirSoundStatics_GetPlayNotifySound) == 0x000001, "Wrong alignment on MirSoundStatics_GetPlayNotifySound");
static_assert(sizeof(MirSoundStatics_GetPlayNotifySound) == 0x000001, "Wrong size on MirSoundStatics_GetPlayNotifySound");
static_assert(offsetof(MirSoundStatics_GetPlayNotifySound, ReturnValue) == 0x000000, "Member 'MirSoundStatics_GetPlayNotifySound::ReturnValue' has a wrong offset!");

// Function MirMobile.MirSoundStatics.MuteSound
// 0x0002 (0x0002 - 0x0000)
struct MirSoundStatics_MuteSound final
{
public:
	EMirSoundClass                                SoundType;                                         // 0x0000(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bMute;                                             // 0x0001(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(MirSoundStatics_MuteSound) == 0x000001, "Wrong alignment on MirSoundStatics_MuteSound");
static_assert(sizeof(MirSoundStatics_MuteSound) == 0x000002, "Wrong size on MirSoundStatics_MuteSound");
static_assert(offsetof(MirSoundStatics_MuteSound, SoundType) == 0x000000, "Member 'MirSoundStatics_MuteSound::SoundType' has a wrong offset!");
static_assert(offsetof(MirSoundStatics_MuteSound, bMute) == 0x000001, "Member 'MirSoundStatics_MuteSound::bMute' has a wrong offset!");

// Function MirMobile.MirSoundStatics.PlayBGM
// 0x0008 (0x0008 - 0x0000)
struct MirSoundStatics_PlayBGM final
{
public:
	int32                                         TableID;                                           // 0x0000(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bPhasingBGM;                                       // 0x0004(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_5[0x3];                                        // 0x0005(0x0003)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(MirSoundStatics_PlayBGM) == 0x000004, "Wrong alignment on MirSoundStatics_PlayBGM");
static_assert(sizeof(MirSoundStatics_PlayBGM) == 0x000008, "Wrong size on MirSoundStatics_PlayBGM");
static_assert(offsetof(MirSoundStatics_PlayBGM, TableID) == 0x000000, "Member 'MirSoundStatics_PlayBGM::TableID' has a wrong offset!");
static_assert(offsetof(MirSoundStatics_PlayBGM, bPhasingBGM) == 0x000004, "Member 'MirSoundStatics_PlayBGM::bPhasingBGM' has a wrong offset!");

// Function MirMobile.MirSoundStatics.PlayBGM_SoundBase
// 0x0010 (0x0010 - 0x0000)
struct MirSoundStatics_PlayBGM_SoundBase final
{
public:
	class USoundBase*                             PSoundBase;                                        // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bPhasingBGM;                                       // 0x0008(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_9[0x7];                                        // 0x0009(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(MirSoundStatics_PlayBGM_SoundBase) == 0x000008, "Wrong alignment on MirSoundStatics_PlayBGM_SoundBase");
static_assert(sizeof(MirSoundStatics_PlayBGM_SoundBase) == 0x000010, "Wrong size on MirSoundStatics_PlayBGM_SoundBase");
static_assert(offsetof(MirSoundStatics_PlayBGM_SoundBase, PSoundBase) == 0x000000, "Member 'MirSoundStatics_PlayBGM_SoundBase::PSoundBase' has a wrong offset!");
static_assert(offsetof(MirSoundStatics_PlayBGM_SoundBase, bPhasingBGM) == 0x000008, "Member 'MirSoundStatics_PlayBGM_SoundBase::bPhasingBGM' has a wrong offset!");

// Function MirMobile.MirSoundStatics.PlayDialogueSound
// 0x0004 (0x0004 - 0x0000)
struct MirSoundStatics_PlayDialogueSound final
{
public:
	int32                                         TableID;                                           // 0x0000(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(MirSoundStatics_PlayDialogueSound) == 0x000004, "Wrong alignment on MirSoundStatics_PlayDialogueSound");
static_assert(sizeof(MirSoundStatics_PlayDialogueSound) == 0x000004, "Wrong size on MirSoundStatics_PlayDialogueSound");
static_assert(offsetof(MirSoundStatics_PlayDialogueSound, TableID) == 0x000000, "Member 'MirSoundStatics_PlayDialogueSound::TableID' has a wrong offset!");

// Function MirMobile.MirSoundStatics.PlayMirSoundData
// 0x0001 (0x0001 - 0x0000)
struct MirSoundStatics_PlayMirSoundData final
{
public:
	EMirSoundDataType                             SoundType;                                         // 0x0000(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(MirSoundStatics_PlayMirSoundData) == 0x000001, "Wrong alignment on MirSoundStatics_PlayMirSoundData");
static_assert(sizeof(MirSoundStatics_PlayMirSoundData) == 0x000001, "Wrong size on MirSoundStatics_PlayMirSoundData");
static_assert(offsetof(MirSoundStatics_PlayMirSoundData, SoundType) == 0x000000, "Member 'MirSoundStatics_PlayMirSoundData::SoundType' has a wrong offset!");

// Function MirMobile.MirSoundStatics.PlaySound
// 0x0004 (0x0004 - 0x0000)
struct MirSoundStatics_PlaySound final
{
public:
	int32                                         TableID;                                           // 0x0000(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(MirSoundStatics_PlaySound) == 0x000004, "Wrong alignment on MirSoundStatics_PlaySound");
static_assert(sizeof(MirSoundStatics_PlaySound) == 0x000004, "Wrong size on MirSoundStatics_PlaySound");
static_assert(offsetof(MirSoundStatics_PlaySound, TableID) == 0x000000, "Member 'MirSoundStatics_PlaySound::TableID' has a wrong offset!");

// Function MirMobile.MirSoundStatics.PlaySound2D
// 0x0004 (0x0004 - 0x0000)
struct MirSoundStatics_PlaySound2D final
{
public:
	int32                                         TableID;                                           // 0x0000(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(MirSoundStatics_PlaySound2D) == 0x000004, "Wrong alignment on MirSoundStatics_PlaySound2D");
static_assert(sizeof(MirSoundStatics_PlaySound2D) == 0x000004, "Wrong size on MirSoundStatics_PlaySound2D");
static_assert(offsetof(MirSoundStatics_PlaySound2D, TableID) == 0x000000, "Member 'MirSoundStatics_PlaySound2D::TableID' has a wrong offset!");

// Function MirMobile.MirSoundStatics.PlaySound2D_SoundBase
// 0x0008 (0x0008 - 0x0000)
struct MirSoundStatics_PlaySound2D_SoundBase final
{
public:
	class USoundBase*                             PSoundBase;                                        // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(MirSoundStatics_PlaySound2D_SoundBase) == 0x000008, "Wrong alignment on MirSoundStatics_PlaySound2D_SoundBase");
static_assert(sizeof(MirSoundStatics_PlaySound2D_SoundBase) == 0x000008, "Wrong size on MirSoundStatics_PlaySound2D_SoundBase");
static_assert(offsetof(MirSoundStatics_PlaySound2D_SoundBase, PSoundBase) == 0x000000, "Member 'MirSoundStatics_PlaySound2D_SoundBase::PSoundBase' has a wrong offset!");

// Function MirMobile.MirSoundStatics.PlaySoundAtLocation
// 0x0018 (0x0018 - 0x0000)
struct MirSoundStatics_PlaySoundAtLocation final
{
public:
	class USoundBase*                             PSoundBase;                                        // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                Location;                                          // 0x0008(0x000C)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_14[0x4];                                       // 0x0014(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(MirSoundStatics_PlaySoundAtLocation) == 0x000008, "Wrong alignment on MirSoundStatics_PlaySoundAtLocation");
static_assert(sizeof(MirSoundStatics_PlaySoundAtLocation) == 0x000018, "Wrong size on MirSoundStatics_PlaySoundAtLocation");
static_assert(offsetof(MirSoundStatics_PlaySoundAtLocation, PSoundBase) == 0x000000, "Member 'MirSoundStatics_PlaySoundAtLocation::PSoundBase' has a wrong offset!");
static_assert(offsetof(MirSoundStatics_PlaySoundAtLocation, Location) == 0x000008, "Member 'MirSoundStatics_PlaySoundAtLocation::Location' has a wrong offset!");

// Function MirMobile.MirSoundStatics.PlaySoundAtLocation_TableID
// 0x0010 (0x0010 - 0x0000)
struct MirSoundStatics_PlaySoundAtLocation_TableID final
{
public:
	int32                                         TableID;                                           // 0x0000(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                Location;                                          // 0x0004(0x000C)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(MirSoundStatics_PlaySoundAtLocation_TableID) == 0x000004, "Wrong alignment on MirSoundStatics_PlaySoundAtLocation_TableID");
static_assert(sizeof(MirSoundStatics_PlaySoundAtLocation_TableID) == 0x000010, "Wrong size on MirSoundStatics_PlaySoundAtLocation_TableID");
static_assert(offsetof(MirSoundStatics_PlaySoundAtLocation_TableID, TableID) == 0x000000, "Member 'MirSoundStatics_PlaySoundAtLocation_TableID::TableID' has a wrong offset!");
static_assert(offsetof(MirSoundStatics_PlaySoundAtLocation_TableID, Location) == 0x000004, "Member 'MirSoundStatics_PlaySoundAtLocation_TableID::Location' has a wrong offset!");

// Function MirMobile.MirSoundStatics.SetMediaVolume
// 0x0010 (0x0010 - 0x0000)
struct MirSoundStatics_SetMediaVolume final
{
public:
	class UMediaSoundComponent*                   PMesiaSoundComponent;                              // 0x0000(0x0008)(Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         FVolume;                                           // 0x0008(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_C[0x4];                                        // 0x000C(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(MirSoundStatics_SetMediaVolume) == 0x000008, "Wrong alignment on MirSoundStatics_SetMediaVolume");
static_assert(sizeof(MirSoundStatics_SetMediaVolume) == 0x000010, "Wrong size on MirSoundStatics_SetMediaVolume");
static_assert(offsetof(MirSoundStatics_SetMediaVolume, PMesiaSoundComponent) == 0x000000, "Member 'MirSoundStatics_SetMediaVolume::PMesiaSoundComponent' has a wrong offset!");
static_assert(offsetof(MirSoundStatics_SetMediaVolume, FVolume) == 0x000008, "Member 'MirSoundStatics_SetMediaVolume::FVolume' has a wrong offset!");

// Function MirMobile.MirSoundStatics.StopSound
// 0x0004 (0x0004 - 0x0000)
struct MirSoundStatics_StopSound final
{
public:
	int32                                         TableID;                                           // 0x0000(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(MirSoundStatics_StopSound) == 0x000004, "Wrong alignment on MirSoundStatics_StopSound");
static_assert(sizeof(MirSoundStatics_StopSound) == 0x000004, "Wrong size on MirSoundStatics_StopSound");
static_assert(offsetof(MirSoundStatics_StopSound, TableID) == 0x000000, "Member 'MirSoundStatics_StopSound::TableID' has a wrong offset!");

// Function MirMobile.ActivateTrigger.Debug_GetTriggerState
// 0x0010 (0x0010 - 0x0000)
struct ActivateTrigger_Debug_GetTriggerState final
{
public:
	class FString                                 ReturnValue;                                       // 0x0000(0x0010)(Parm, OutParm, ZeroConstructor, ReturnParm, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(ActivateTrigger_Debug_GetTriggerState) == 0x000008, "Wrong alignment on ActivateTrigger_Debug_GetTriggerState");
static_assert(sizeof(ActivateTrigger_Debug_GetTriggerState) == 0x000010, "Wrong size on ActivateTrigger_Debug_GetTriggerState");
static_assert(offsetof(ActivateTrigger_Debug_GetTriggerState, ReturnValue) == 0x000000, "Member 'ActivateTrigger_Debug_GetTriggerState::ReturnValue' has a wrong offset!");

// Function MirMobile.MM_PopupGuildSearchEdit.OnChangedWorld
// 0x0010 (0x0010 - 0x0000)
struct MM_PopupGuildSearchEdit_OnChangedWorld final
{
public:
	class FString                                 World_name_;                                       // 0x0000(0x0010)(Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(MM_PopupGuildSearchEdit_OnChangedWorld) == 0x000008, "Wrong alignment on MM_PopupGuildSearchEdit_OnChangedWorld");
static_assert(sizeof(MM_PopupGuildSearchEdit_OnChangedWorld) == 0x000010, "Wrong size on MM_PopupGuildSearchEdit_OnChangedWorld");
static_assert(offsetof(MM_PopupGuildSearchEdit_OnChangedWorld, World_name_) == 0x000000, "Member 'MM_PopupGuildSearchEdit_OnChangedWorld::World_name_' has a wrong offset!");

// Function MirMobile.MM_PopupGuildSearchEdit.OnTextCommitted
// 0x0020 (0x0020 - 0x0000)
struct MM_PopupGuildSearchEdit_OnTextCommitted final
{
public:
	class FText                                   Text_;                                             // 0x0000(0x0018)(ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
	ETextCommit                                   Commit_method_;                                    // 0x0018(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_19[0x7];                                       // 0x0019(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(MM_PopupGuildSearchEdit_OnTextCommitted) == 0x000008, "Wrong alignment on MM_PopupGuildSearchEdit_OnTextCommitted");
static_assert(sizeof(MM_PopupGuildSearchEdit_OnTextCommitted) == 0x000020, "Wrong size on MM_PopupGuildSearchEdit_OnTextCommitted");
static_assert(offsetof(MM_PopupGuildSearchEdit_OnTextCommitted, Text_) == 0x000000, "Member 'MM_PopupGuildSearchEdit_OnTextCommitted::Text_' has a wrong offset!");
static_assert(offsetof(MM_PopupGuildSearchEdit_OnTextCommitted, Commit_method_) == 0x000018, "Member 'MM_PopupGuildSearchEdit_OnTextCommitted::Commit_method_' has a wrong offset!");

// Function MirMobile.CutsceneCamera.PlayCameraShake
// 0x0004 (0x0004 - 0x0000)
struct CutsceneCamera_PlayCameraShake final
{
public:
	int32                                         ShakeID;                                           // 0x0000(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(CutsceneCamera_PlayCameraShake) == 0x000004, "Wrong alignment on CutsceneCamera_PlayCameraShake");
static_assert(sizeof(CutsceneCamera_PlayCameraShake) == 0x000004, "Wrong size on CutsceneCamera_PlayCameraShake");
static_assert(offsetof(CutsceneCamera_PlayCameraShake, ShakeID) == 0x000000, "Member 'CutsceneCamera_PlayCameraShake::ShakeID' has a wrong offset!");

// Function MirMobile.AlignedWrapBox.AddChildWrapBox
// 0x0010 (0x0010 - 0x0000)
struct AlignedWrapBox_AddChildWrapBox final
{
public:
	class UWidget*                                Content;                                           // 0x0000(0x0008)(Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UAlignedWrapBoxSlot*                    ReturnValue;                                       // 0x0008(0x0008)(ExportObject, Parm, OutParm, ZeroConstructor, ReturnParm, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(AlignedWrapBox_AddChildWrapBox) == 0x000008, "Wrong alignment on AlignedWrapBox_AddChildWrapBox");
static_assert(sizeof(AlignedWrapBox_AddChildWrapBox) == 0x000010, "Wrong size on AlignedWrapBox_AddChildWrapBox");
static_assert(offsetof(AlignedWrapBox_AddChildWrapBox, Content) == 0x000000, "Member 'AlignedWrapBox_AddChildWrapBox::Content' has a wrong offset!");
static_assert(offsetof(AlignedWrapBox_AddChildWrapBox, ReturnValue) == 0x000008, "Member 'AlignedWrapBox_AddChildWrapBox::ReturnValue' has a wrong offset!");

// Function MirMobile.AlignedWrapBox.SetHorizontalAlignment
// 0x0001 (0x0001 - 0x0000)
struct AlignedWrapBox_SetHorizontalAlignment final
{
public:
	EHorizontalAlignment                          InHorizontalAlignment;                             // 0x0000(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(AlignedWrapBox_SetHorizontalAlignment) == 0x000001, "Wrong alignment on AlignedWrapBox_SetHorizontalAlignment");
static_assert(sizeof(AlignedWrapBox_SetHorizontalAlignment) == 0x000001, "Wrong size on AlignedWrapBox_SetHorizontalAlignment");
static_assert(offsetof(AlignedWrapBox_SetHorizontalAlignment, InHorizontalAlignment) == 0x000000, "Member 'AlignedWrapBox_SetHorizontalAlignment::InHorizontalAlignment' has a wrong offset!");

// Function MirMobile.AlignedWrapBox.SetInnerSlotPadding
// 0x0008 (0x0008 - 0x0000)
struct AlignedWrapBox_SetInnerSlotPadding final
{
public:
	struct FVector2D                              InPadding;                                         // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(AlignedWrapBox_SetInnerSlotPadding) == 0x000004, "Wrong alignment on AlignedWrapBox_SetInnerSlotPadding");
static_assert(sizeof(AlignedWrapBox_SetInnerSlotPadding) == 0x000008, "Wrong size on AlignedWrapBox_SetInnerSlotPadding");
static_assert(offsetof(AlignedWrapBox_SetInnerSlotPadding, InPadding) == 0x000000, "Member 'AlignedWrapBox_SetInnerSlotPadding::InPadding' has a wrong offset!");

// Function MirMobile.MM_GameOption_InGame_Alarm.OnClickNightPushAgree
// 0x0004 (0x0004 - 0x0000)
struct MM_GameOption_InGame_Alarm_OnClickNightPushAgree final
{
public:
	int32                                         ISwitchFlag;                                       // 0x0000(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(MM_GameOption_InGame_Alarm_OnClickNightPushAgree) == 0x000004, "Wrong alignment on MM_GameOption_InGame_Alarm_OnClickNightPushAgree");
static_assert(sizeof(MM_GameOption_InGame_Alarm_OnClickNightPushAgree) == 0x000004, "Wrong size on MM_GameOption_InGame_Alarm_OnClickNightPushAgree");
static_assert(offsetof(MM_GameOption_InGame_Alarm_OnClickNightPushAgree, ISwitchFlag) == 0x000000, "Member 'MM_GameOption_InGame_Alarm_OnClickNightPushAgree::ISwitchFlag' has a wrong offset!");

// Function MirMobile.MM_GameOption_InGame_Alarm.OnClickPushAgree
// 0x0004 (0x0004 - 0x0000)
struct MM_GameOption_InGame_Alarm_OnClickPushAgree final
{
public:
	int32                                         ISwitchFlag;                                       // 0x0000(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(MM_GameOption_InGame_Alarm_OnClickPushAgree) == 0x000004, "Wrong alignment on MM_GameOption_InGame_Alarm_OnClickPushAgree");
static_assert(sizeof(MM_GameOption_InGame_Alarm_OnClickPushAgree) == 0x000004, "Wrong size on MM_GameOption_InGame_Alarm_OnClickPushAgree");
static_assert(offsetof(MM_GameOption_InGame_Alarm_OnClickPushAgree, ISwitchFlag) == 0x000000, "Member 'MM_GameOption_InGame_Alarm_OnClickPushAgree::ISwitchFlag' has a wrong offset!");

// Function MirMobile.MM_PopupStore_Main.OnClickUSD
// 0x0001 (0x0001 - 0x0000)
struct MM_PopupStore_Main_OnClickUSD final
{
public:
	bool                                          InChecked;                                         // 0x0000(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(MM_PopupStore_Main_OnClickUSD) == 0x000001, "Wrong alignment on MM_PopupStore_Main_OnClickUSD");
static_assert(sizeof(MM_PopupStore_Main_OnClickUSD) == 0x000001, "Wrong size on MM_PopupStore_Main_OnClickUSD");
static_assert(offsetof(MM_PopupStore_Main_OnClickUSD, InChecked) == 0x000000, "Member 'MM_PopupStore_Main_OnClickUSD::InChecked' has a wrong offset!");

// Function MirMobile.MM_PopupStore_Main.OnClickWemixDollar
// 0x0001 (0x0001 - 0x0000)
struct MM_PopupStore_Main_OnClickWemixDollar final
{
public:
	bool                                          InChecked;                                         // 0x0000(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(MM_PopupStore_Main_OnClickWemixDollar) == 0x000001, "Wrong alignment on MM_PopupStore_Main_OnClickWemixDollar");
static_assert(sizeof(MM_PopupStore_Main_OnClickWemixDollar) == 0x000001, "Wrong size on MM_PopupStore_Main_OnClickWemixDollar");
static_assert(offsetof(MM_PopupStore_Main_OnClickWemixDollar, InChecked) == 0x000000, "Member 'MM_PopupStore_Main_OnClickWemixDollar::InChecked' has a wrong offset!");

// Function MirMobile.CutsceneDialogueWidget.ChangeQuestTitleStyle
// 0x0001 (0x0001 - 0x0000)
struct CutsceneDialogueWidget_ChangeQuestTitleStyle final
{
public:
	EQuestDialogueType                            QuestType;                                         // 0x0000(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(CutsceneDialogueWidget_ChangeQuestTitleStyle) == 0x000001, "Wrong alignment on CutsceneDialogueWidget_ChangeQuestTitleStyle");
static_assert(sizeof(CutsceneDialogueWidget_ChangeQuestTitleStyle) == 0x000001, "Wrong size on CutsceneDialogueWidget_ChangeQuestTitleStyle");
static_assert(offsetof(CutsceneDialogueWidget_ChangeQuestTitleStyle, QuestType) == 0x000000, "Member 'CutsceneDialogueWidget_ChangeQuestTitleStyle::QuestType' has a wrong offset!");

// Function MirMobile.AlignedWrapBoxSlot.SetFillEmptySpace
// 0x0001 (0x0001 - 0x0000)
struct AlignedWrapBoxSlot_SetFillEmptySpace final
{
public:
	bool                                          InbFillEmptySpace;                                 // 0x0000(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(AlignedWrapBoxSlot_SetFillEmptySpace) == 0x000001, "Wrong alignment on AlignedWrapBoxSlot_SetFillEmptySpace");
static_assert(sizeof(AlignedWrapBoxSlot_SetFillEmptySpace) == 0x000001, "Wrong size on AlignedWrapBoxSlot_SetFillEmptySpace");
static_assert(offsetof(AlignedWrapBoxSlot_SetFillEmptySpace, InbFillEmptySpace) == 0x000000, "Member 'AlignedWrapBoxSlot_SetFillEmptySpace::InbFillEmptySpace' has a wrong offset!");

// Function MirMobile.AlignedWrapBoxSlot.SetFillSpanWhenLessThan
// 0x0004 (0x0004 - 0x0000)
struct AlignedWrapBoxSlot_SetFillSpanWhenLessThan final
{
public:
	float                                         InFillSpanWhenLessThan;                            // 0x0000(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(AlignedWrapBoxSlot_SetFillSpanWhenLessThan) == 0x000004, "Wrong alignment on AlignedWrapBoxSlot_SetFillSpanWhenLessThan");
static_assert(sizeof(AlignedWrapBoxSlot_SetFillSpanWhenLessThan) == 0x000004, "Wrong size on AlignedWrapBoxSlot_SetFillSpanWhenLessThan");
static_assert(offsetof(AlignedWrapBoxSlot_SetFillSpanWhenLessThan, InFillSpanWhenLessThan) == 0x000000, "Member 'AlignedWrapBoxSlot_SetFillSpanWhenLessThan::InFillSpanWhenLessThan' has a wrong offset!");

// Function MirMobile.AlignedWrapBoxSlot.SetHorizontalAlignment
// 0x0001 (0x0001 - 0x0000)
struct AlignedWrapBoxSlot_SetHorizontalAlignment final
{
public:
	EHorizontalAlignment                          InHorizontalAlignment;                             // 0x0000(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(AlignedWrapBoxSlot_SetHorizontalAlignment) == 0x000001, "Wrong alignment on AlignedWrapBoxSlot_SetHorizontalAlignment");
static_assert(sizeof(AlignedWrapBoxSlot_SetHorizontalAlignment) == 0x000001, "Wrong size on AlignedWrapBoxSlot_SetHorizontalAlignment");
static_assert(offsetof(AlignedWrapBoxSlot_SetHorizontalAlignment, InHorizontalAlignment) == 0x000000, "Member 'AlignedWrapBoxSlot_SetHorizontalAlignment::InHorizontalAlignment' has a wrong offset!");

// Function MirMobile.AlignedWrapBoxSlot.SetPadding
// 0x0010 (0x0010 - 0x0000)
struct AlignedWrapBoxSlot_SetPadding final
{
public:
	struct FMargin                                InPadding;                                         // 0x0000(0x0010)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(AlignedWrapBoxSlot_SetPadding) == 0x000004, "Wrong alignment on AlignedWrapBoxSlot_SetPadding");
static_assert(sizeof(AlignedWrapBoxSlot_SetPadding) == 0x000010, "Wrong size on AlignedWrapBoxSlot_SetPadding");
static_assert(offsetof(AlignedWrapBoxSlot_SetPadding, InPadding) == 0x000000, "Member 'AlignedWrapBoxSlot_SetPadding::InPadding' has a wrong offset!");

// Function MirMobile.AlignedWrapBoxSlot.SetVerticalAlignment
// 0x0001 (0x0001 - 0x0000)
struct AlignedWrapBoxSlot_SetVerticalAlignment final
{
public:
	EVerticalAlignment                            InVerticalAlignment;                               // 0x0000(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(AlignedWrapBoxSlot_SetVerticalAlignment) == 0x000001, "Wrong alignment on AlignedWrapBoxSlot_SetVerticalAlignment");
static_assert(sizeof(AlignedWrapBoxSlot_SetVerticalAlignment) == 0x000001, "Wrong size on AlignedWrapBoxSlot_SetVerticalAlignment");
static_assert(offsetof(AlignedWrapBoxSlot_SetVerticalAlignment, InVerticalAlignment) == 0x000000, "Member 'AlignedWrapBoxSlot_SetVerticalAlignment::InVerticalAlignment' has a wrong offset!");

// Function MirMobile.DebugLogPanel.InsertLog
// 0x0028 (0x0028 - 0x0000)
struct DebugLogPanel_InsertLog final
{
public:
	EDEBUG                                        EKEY;                                              // 0x0000(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	ELOGTYPE                                      EType;                                             // 0x0001(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2[0x6];                                        // 0x0002(0x0006)(Fixing Size After Last Property [ Dumper-7 ])
	class FString                                 _title;                                            // 0x0008(0x0010)(Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 _contents;                                         // 0x0018(0x0010)(Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(DebugLogPanel_InsertLog) == 0x000008, "Wrong alignment on DebugLogPanel_InsertLog");
static_assert(sizeof(DebugLogPanel_InsertLog) == 0x000028, "Wrong size on DebugLogPanel_InsertLog");
static_assert(offsetof(DebugLogPanel_InsertLog, EKEY) == 0x000000, "Member 'DebugLogPanel_InsertLog::EKEY' has a wrong offset!");
static_assert(offsetof(DebugLogPanel_InsertLog, EType) == 0x000001, "Member 'DebugLogPanel_InsertLog::EType' has a wrong offset!");
static_assert(offsetof(DebugLogPanel_InsertLog, _title) == 0x000008, "Member 'DebugLogPanel_InsertLog::_title' has a wrong offset!");
static_assert(offsetof(DebugLogPanel_InsertLog, _contents) == 0x000018, "Member 'DebugLogPanel_InsertLog::_contents' has a wrong offset!");

// Function MirMobile.LoginSubSystemBase.OnXsollaLogoutUserFail
// 0x0020 (0x0020 - 0x0000)
struct LoginSubSystemBase_OnXsollaLogoutUserFail final
{
public:
	class FString                                 Code;                                              // 0x0000(0x0010)(Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 Description;                                       // 0x0010(0x0010)(Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(LoginSubSystemBase_OnXsollaLogoutUserFail) == 0x000008, "Wrong alignment on LoginSubSystemBase_OnXsollaLogoutUserFail");
static_assert(sizeof(LoginSubSystemBase_OnXsollaLogoutUserFail) == 0x000020, "Wrong size on LoginSubSystemBase_OnXsollaLogoutUserFail");
static_assert(offsetof(LoginSubSystemBase_OnXsollaLogoutUserFail, Code) == 0x000000, "Member 'LoginSubSystemBase_OnXsollaLogoutUserFail::Code' has a wrong offset!");
static_assert(offsetof(LoginSubSystemBase_OnXsollaLogoutUserFail, Description) == 0x000010, "Member 'LoginSubSystemBase_OnXsollaLogoutUserFail::Description' has a wrong offset!");

// Function MirMobile.MapPreviewTool.OnCommitTimeDilationTextBox
// 0x0020 (0x0020 - 0x0000)
struct MapPreviewTool_OnCommitTimeDilationTextBox final
{
public:
	class FText                                   Text;                                              // 0x0000(0x0018)(ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
	ETextCommit                                   Type;                                              // 0x0018(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_19[0x7];                                       // 0x0019(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(MapPreviewTool_OnCommitTimeDilationTextBox) == 0x000008, "Wrong alignment on MapPreviewTool_OnCommitTimeDilationTextBox");
static_assert(sizeof(MapPreviewTool_OnCommitTimeDilationTextBox) == 0x000020, "Wrong size on MapPreviewTool_OnCommitTimeDilationTextBox");
static_assert(offsetof(MapPreviewTool_OnCommitTimeDilationTextBox, Text) == 0x000000, "Member 'MapPreviewTool_OnCommitTimeDilationTextBox::Text' has a wrong offset!");
static_assert(offsetof(MapPreviewTool_OnCommitTimeDilationTextBox, Type) == 0x000018, "Member 'MapPreviewTool_OnCommitTimeDilationTextBox::Type' has a wrong offset!");

// Function MirMobile.MapPreviewTool.OnDragTimeDilationSlider
// 0x0004 (0x0004 - 0x0000)
struct MapPreviewTool_OnDragTimeDilationSlider final
{
public:
	float                                         Value;                                             // 0x0000(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(MapPreviewTool_OnDragTimeDilationSlider) == 0x000004, "Wrong alignment on MapPreviewTool_OnDragTimeDilationSlider");
static_assert(sizeof(MapPreviewTool_OnDragTimeDilationSlider) == 0x000004, "Wrong size on MapPreviewTool_OnDragTimeDilationSlider");
static_assert(offsetof(MapPreviewTool_OnDragTimeDilationSlider, Value) == 0x000000, "Member 'MapPreviewTool_OnDragTimeDilationSlider::Value' has a wrong offset!");

// Function MirMobile.AppleLoginSubSystem.AuthSignInForWithdrawCredentialComplete
// 0x0020 (0x0020 - 0x0000)
struct AppleLoginSubSystem_AuthSignInForWithdrawCredentialComplete final
{
public:
	class UFirebaseUser*                          FirebaseUser;                                      // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         ErrorCode;                                         // 0x0008(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_C[0x4];                                        // 0x000C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class FString                                 ErrorMessage;                                      // 0x0010(0x0010)(Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(AppleLoginSubSystem_AuthSignInForWithdrawCredentialComplete) == 0x000008, "Wrong alignment on AppleLoginSubSystem_AuthSignInForWithdrawCredentialComplete");
static_assert(sizeof(AppleLoginSubSystem_AuthSignInForWithdrawCredentialComplete) == 0x000020, "Wrong size on AppleLoginSubSystem_AuthSignInForWithdrawCredentialComplete");
static_assert(offsetof(AppleLoginSubSystem_AuthSignInForWithdrawCredentialComplete, FirebaseUser) == 0x000000, "Member 'AppleLoginSubSystem_AuthSignInForWithdrawCredentialComplete::FirebaseUser' has a wrong offset!");
static_assert(offsetof(AppleLoginSubSystem_AuthSignInForWithdrawCredentialComplete, ErrorCode) == 0x000008, "Member 'AppleLoginSubSystem_AuthSignInForWithdrawCredentialComplete::ErrorCode' has a wrong offset!");
static_assert(offsetof(AppleLoginSubSystem_AuthSignInForWithdrawCredentialComplete, ErrorMessage) == 0x000010, "Member 'AppleLoginSubSystem_AuthSignInForWithdrawCredentialComplete::ErrorMessage' has a wrong offset!");

// Function MirMobile.AppleLoginSubSystem.AuthSignInWithCredentialComplete
// 0x0020 (0x0020 - 0x0000)
struct AppleLoginSubSystem_AuthSignInWithCredentialComplete final
{
public:
	class UFirebaseUser*                          FirebaseUser;                                      // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         ErrorCode;                                         // 0x0008(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_C[0x4];                                        // 0x000C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class FString                                 ErrorMessage;                                      // 0x0010(0x0010)(Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(AppleLoginSubSystem_AuthSignInWithCredentialComplete) == 0x000008, "Wrong alignment on AppleLoginSubSystem_AuthSignInWithCredentialComplete");
static_assert(sizeof(AppleLoginSubSystem_AuthSignInWithCredentialComplete) == 0x000020, "Wrong size on AppleLoginSubSystem_AuthSignInWithCredentialComplete");
static_assert(offsetof(AppleLoginSubSystem_AuthSignInWithCredentialComplete, FirebaseUser) == 0x000000, "Member 'AppleLoginSubSystem_AuthSignInWithCredentialComplete::FirebaseUser' has a wrong offset!");
static_assert(offsetof(AppleLoginSubSystem_AuthSignInWithCredentialComplete, ErrorCode) == 0x000008, "Member 'AppleLoginSubSystem_AuthSignInWithCredentialComplete::ErrorCode' has a wrong offset!");
static_assert(offsetof(AppleLoginSubSystem_AuthSignInWithCredentialComplete, ErrorMessage) == 0x000010, "Member 'AppleLoginSubSystem_AuthSignInWithCredentialComplete::ErrorMessage' has a wrong offset!");

// Function MirMobile.AppleLoginSubSystem.RequestAppleCredentialComplete
// 0x0020 (0x0020 - 0x0000)
struct AppleLoginSubSystem_RequestAppleCredentialComplete final
{
public:
	bool                                          IsSuccess;                                         // 0x0000(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1[0x7];                                        // 0x0001(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	class UFirebaseCredential*                    Credential;                                        // 0x0008(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 ErrorMessage;                                      // 0x0010(0x0010)(Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(AppleLoginSubSystem_RequestAppleCredentialComplete) == 0x000008, "Wrong alignment on AppleLoginSubSystem_RequestAppleCredentialComplete");
static_assert(sizeof(AppleLoginSubSystem_RequestAppleCredentialComplete) == 0x000020, "Wrong size on AppleLoginSubSystem_RequestAppleCredentialComplete");
static_assert(offsetof(AppleLoginSubSystem_RequestAppleCredentialComplete, IsSuccess) == 0x000000, "Member 'AppleLoginSubSystem_RequestAppleCredentialComplete::IsSuccess' has a wrong offset!");
static_assert(offsetof(AppleLoginSubSystem_RequestAppleCredentialComplete, Credential) == 0x000008, "Member 'AppleLoginSubSystem_RequestAppleCredentialComplete::Credential' has a wrong offset!");
static_assert(offsetof(AppleLoginSubSystem_RequestAppleCredentialComplete, ErrorMessage) == 0x000010, "Member 'AppleLoginSubSystem_RequestAppleCredentialComplete::ErrorMessage' has a wrong offset!");

// Function MirMobile.AppleLoginSubSystem.RequestSignInForWithdrawCredentialComplete
// 0x0020 (0x0020 - 0x0000)
struct AppleLoginSubSystem_RequestSignInForWithdrawCredentialComplete final
{
public:
	bool                                          IsSuccess;                                         // 0x0000(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1[0x7];                                        // 0x0001(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	class UFirebaseCredential*                    Credential;                                        // 0x0008(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 ErrorMessage;                                      // 0x0010(0x0010)(Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(AppleLoginSubSystem_RequestSignInForWithdrawCredentialComplete) == 0x000008, "Wrong alignment on AppleLoginSubSystem_RequestSignInForWithdrawCredentialComplete");
static_assert(sizeof(AppleLoginSubSystem_RequestSignInForWithdrawCredentialComplete) == 0x000020, "Wrong size on AppleLoginSubSystem_RequestSignInForWithdrawCredentialComplete");
static_assert(offsetof(AppleLoginSubSystem_RequestSignInForWithdrawCredentialComplete, IsSuccess) == 0x000000, "Member 'AppleLoginSubSystem_RequestSignInForWithdrawCredentialComplete::IsSuccess' has a wrong offset!");
static_assert(offsetof(AppleLoginSubSystem_RequestSignInForWithdrawCredentialComplete, Credential) == 0x000008, "Member 'AppleLoginSubSystem_RequestSignInForWithdrawCredentialComplete::Credential' has a wrong offset!");
static_assert(offsetof(AppleLoginSubSystem_RequestSignInForWithdrawCredentialComplete, ErrorMessage) == 0x000010, "Member 'AppleLoginSubSystem_RequestSignInForWithdrawCredentialComplete::ErrorMessage' has a wrong offset!");

// Function MirMobile.AutoAirwalkTrigger.ShowGuidEffectEvent
// 0x0001 (0x0001 - 0x0000)
struct AutoAirwalkTrigger_ShowGuidEffectEvent final
{
public:
	bool                                          bShow;                                             // 0x0000(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(AutoAirwalkTrigger_ShowGuidEffectEvent) == 0x000001, "Wrong alignment on AutoAirwalkTrigger_ShowGuidEffectEvent");
static_assert(sizeof(AutoAirwalkTrigger_ShowGuidEffectEvent) == 0x000001, "Wrong size on AutoAirwalkTrigger_ShowGuidEffectEvent");
static_assert(offsetof(AutoAirwalkTrigger_ShowGuidEffectEvent, bShow) == 0x000000, "Member 'AutoAirwalkTrigger_ShowGuidEffectEvent::bShow' has a wrong offset!");

// Function MirMobile.MM_Popup_Guild_WantedSlot.OnToggleCheckOne
// 0x0001 (0x0001 - 0x0000)
struct MM_Popup_Guild_WantedSlot_OnToggleCheckOne final
{
public:
	bool                                          bChecked;                                          // 0x0000(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(MM_Popup_Guild_WantedSlot_OnToggleCheckOne) == 0x000001, "Wrong alignment on MM_Popup_Guild_WantedSlot_OnToggleCheckOne");
static_assert(sizeof(MM_Popup_Guild_WantedSlot_OnToggleCheckOne) == 0x000001, "Wrong size on MM_Popup_Guild_WantedSlot_OnToggleCheckOne");
static_assert(offsetof(MM_Popup_Guild_WantedSlot_OnToggleCheckOne, bChecked) == 0x000000, "Member 'MM_Popup_Guild_WantedSlot_OnToggleCheckOne::bChecked' has a wrong offset!");

// Function MirMobile.MM_Popup_Guild_WantedSlot.OnToggleCheckTwo
// 0x0001 (0x0001 - 0x0000)
struct MM_Popup_Guild_WantedSlot_OnToggleCheckTwo final
{
public:
	bool                                          bChecked;                                          // 0x0000(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(MM_Popup_Guild_WantedSlot_OnToggleCheckTwo) == 0x000001, "Wrong alignment on MM_Popup_Guild_WantedSlot_OnToggleCheckTwo");
static_assert(sizeof(MM_Popup_Guild_WantedSlot_OnToggleCheckTwo) == 0x000001, "Wrong size on MM_Popup_Guild_WantedSlot_OnToggleCheckTwo");
static_assert(offsetof(MM_Popup_Guild_WantedSlot_OnToggleCheckTwo, bChecked) == 0x000000, "Member 'MM_Popup_Guild_WantedSlot_OnToggleCheckTwo::bChecked' has a wrong offset!");

// Function MirMobile.BGMTrigger.PlayFieldBGM
// 0x0008 (0x0008 - 0x0000)
struct BGMTrigger_PlayFieldBGM final
{
public:
	class USoundBase*                             PSound;                                            // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(BGMTrigger_PlayFieldBGM) == 0x000008, "Wrong alignment on BGMTrigger_PlayFieldBGM");
static_assert(sizeof(BGMTrigger_PlayFieldBGM) == 0x000008, "Wrong size on BGMTrigger_PlayFieldBGM");
static_assert(offsetof(BGMTrigger_PlayFieldBGM, PSound) == 0x000000, "Member 'BGMTrigger_PlayFieldBGM::PSound' has a wrong offset!");

// Function MirMobile.MM_AnimInstance.ChangeSubState
// 0x0004 (0x0004 - 0x0000)
struct MM_AnimInstance_ChangeSubState final
{
public:
	int32                                         NewSubState;                                       // 0x0000(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(MM_AnimInstance_ChangeSubState) == 0x000004, "Wrong alignment on MM_AnimInstance_ChangeSubState");
static_assert(sizeof(MM_AnimInstance_ChangeSubState) == 0x000004, "Wrong size on MM_AnimInstance_ChangeSubState");
static_assert(offsetof(MM_AnimInstance_ChangeSubState, NewSubState) == 0x000000, "Member 'MM_AnimInstance_ChangeSubState::NewSubState' has a wrong offset!");

// Function MirMobile.MM_Auction_Slot_BookMark.OnClickBookMark
// 0x0001 (0x0001 - 0x0000)
struct MM_Auction_Slot_BookMark_OnClickBookMark final
{
public:
	bool                                          bCheck;                                            // 0x0000(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(MM_Auction_Slot_BookMark_OnClickBookMark) == 0x000001, "Wrong alignment on MM_Auction_Slot_BookMark_OnClickBookMark");
static_assert(sizeof(MM_Auction_Slot_BookMark_OnClickBookMark) == 0x000001, "Wrong size on MM_Auction_Slot_BookMark_OnClickBookMark");
static_assert(offsetof(MM_Auction_Slot_BookMark_OnClickBookMark, bCheck) == 0x000000, "Member 'MM_Auction_Slot_BookMark_OnClickBookMark::bCheck' has a wrong offset!");

// Function MirMobile.MM_Auction_Slot_BookMark.OnClickItemSlot
// 0x0008 (0x0008 - 0x0000)
struct MM_Auction_Slot_BookMark_OnClickItemSlot final
{
public:
	class UMM_Slot_Base*                          PSlotBase;                                         // 0x0000(0x0008)(Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(MM_Auction_Slot_BookMark_OnClickItemSlot) == 0x000008, "Wrong alignment on MM_Auction_Slot_BookMark_OnClickItemSlot");
static_assert(sizeof(MM_Auction_Slot_BookMark_OnClickItemSlot) == 0x000008, "Wrong size on MM_Auction_Slot_BookMark_OnClickItemSlot");
static_assert(offsetof(MM_Auction_Slot_BookMark_OnClickItemSlot, PSlotBase) == 0x000000, "Member 'MM_Auction_Slot_BookMark_OnClickItemSlot::PSlotBase' has a wrong offset!");

// Function MirMobile.MiniGame_MonsterActor.ChangeDirection_BP
// 0x0001 (0x0001 - 0x0000)
struct MiniGame_MonsterActor_ChangeDirection_BP final
{
public:
	EMiniGameMonsterMoveDirection                 EDirection;                                        // 0x0000(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(MiniGame_MonsterActor_ChangeDirection_BP) == 0x000001, "Wrong alignment on MiniGame_MonsterActor_ChangeDirection_BP");
static_assert(sizeof(MiniGame_MonsterActor_ChangeDirection_BP) == 0x000001, "Wrong size on MiniGame_MonsterActor_ChangeDirection_BP");
static_assert(offsetof(MiniGame_MonsterActor_ChangeDirection_BP, EDirection) == 0x000000, "Member 'MiniGame_MonsterActor_ChangeDirection_BP::EDirection' has a wrong offset!");

// Function MirMobile.MiniGame_MonsterActor.ChangeDisplayByMonsterGrade_BP
// 0x0001 (0x0001 - 0x0000)
struct MiniGame_MonsterActor_ChangeDisplayByMonsterGrade_BP final
{
public:
	EMiniGameMonsterGrade                         EGrade;                                            // 0x0000(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(MiniGame_MonsterActor_ChangeDisplayByMonsterGrade_BP) == 0x000001, "Wrong alignment on MiniGame_MonsterActor_ChangeDisplayByMonsterGrade_BP");
static_assert(sizeof(MiniGame_MonsterActor_ChangeDisplayByMonsterGrade_BP) == 0x000001, "Wrong size on MiniGame_MonsterActor_ChangeDisplayByMonsterGrade_BP");
static_assert(offsetof(MiniGame_MonsterActor_ChangeDisplayByMonsterGrade_BP, EGrade) == 0x000000, "Member 'MiniGame_MonsterActor_ChangeDisplayByMonsterGrade_BP::EGrade' has a wrong offset!");

// Function MirMobile.MiniGame_MonsterActor.ChangeFlipbook_BP
// 0x0002 (0x0002 - 0x0000)
struct MiniGame_MonsterActor_ChangeFlipbook_BP final
{
public:
	EMiniGameMonsterState                         EState;                                            // 0x0000(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EMiniGameMonsterMoveDirection                 EDirection;                                        // 0x0001(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(MiniGame_MonsterActor_ChangeFlipbook_BP) == 0x000001, "Wrong alignment on MiniGame_MonsterActor_ChangeFlipbook_BP");
static_assert(sizeof(MiniGame_MonsterActor_ChangeFlipbook_BP) == 0x000002, "Wrong size on MiniGame_MonsterActor_ChangeFlipbook_BP");
static_assert(offsetof(MiniGame_MonsterActor_ChangeFlipbook_BP, EState) == 0x000000, "Member 'MiniGame_MonsterActor_ChangeFlipbook_BP::EState' has a wrong offset!");
static_assert(offsetof(MiniGame_MonsterActor_ChangeFlipbook_BP, EDirection) == 0x000001, "Member 'MiniGame_MonsterActor_ChangeFlipbook_BP::EDirection' has a wrong offset!");

// Function MirMobile.MiniGame_MonsterActor.GetMiniGameActor
// 0x0008 (0x0008 - 0x0000)
struct MiniGame_MonsterActor_GetMiniGameActor final
{
public:
	class AMiniGame_ManagerActor*                 ReturnValue;                                       // 0x0000(0x0008)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(MiniGame_MonsterActor_GetMiniGameActor) == 0x000008, "Wrong alignment on MiniGame_MonsterActor_GetMiniGameActor");
static_assert(sizeof(MiniGame_MonsterActor_GetMiniGameActor) == 0x000008, "Wrong size on MiniGame_MonsterActor_GetMiniGameActor");
static_assert(offsetof(MiniGame_MonsterActor_GetMiniGameActor, ReturnValue) == 0x000000, "Member 'MiniGame_MonsterActor_GetMiniGameActor::ReturnValue' has a wrong offset!");

// Function MirMobile.MiniGame_MonsterActor.GetMonsterScale_BP
// 0x0004 (0x0004 - 0x0000)
struct MiniGame_MonsterActor_GetMonsterScale_BP final
{
public:
	float                                         ReturnValue;                                       // 0x0000(0x0004)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(MiniGame_MonsterActor_GetMonsterScale_BP) == 0x000004, "Wrong alignment on MiniGame_MonsterActor_GetMonsterScale_BP");
static_assert(sizeof(MiniGame_MonsterActor_GetMonsterScale_BP) == 0x000004, "Wrong size on MiniGame_MonsterActor_GetMonsterScale_BP");
static_assert(offsetof(MiniGame_MonsterActor_GetMonsterScale_BP, ReturnValue) == 0x000000, "Member 'MiniGame_MonsterActor_GetMonsterScale_BP::ReturnValue' has a wrong offset!");

// Function MirMobile.MiniGame_MonsterActor.HitBlank_BP
// 0x0004 (0x0004 - 0x0000)
struct MiniGame_MonsterActor_HitBlank_BP final
{
public:
	float                                         FStartTime;                                        // 0x0000(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(MiniGame_MonsterActor_HitBlank_BP) == 0x000004, "Wrong alignment on MiniGame_MonsterActor_HitBlank_BP");
static_assert(sizeof(MiniGame_MonsterActor_HitBlank_BP) == 0x000004, "Wrong size on MiniGame_MonsterActor_HitBlank_BP");
static_assert(offsetof(MiniGame_MonsterActor_HitBlank_BP, FStartTime) == 0x000000, "Member 'MiniGame_MonsterActor_HitBlank_BP::FStartTime' has a wrong offset!");

// Function MirMobile.MiniGame_MonsterActor.PauseFilpbook_BP
// 0x0001 (0x0001 - 0x0000)
struct MiniGame_MonsterActor_PauseFilpbook_BP final
{
public:
	bool                                          bPause;                                            // 0x0000(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(MiniGame_MonsterActor_PauseFilpbook_BP) == 0x000001, "Wrong alignment on MiniGame_MonsterActor_PauseFilpbook_BP");
static_assert(sizeof(MiniGame_MonsterActor_PauseFilpbook_BP) == 0x000001, "Wrong size on MiniGame_MonsterActor_PauseFilpbook_BP");
static_assert(offsetof(MiniGame_MonsterActor_PauseFilpbook_BP, bPause) == 0x000000, "Member 'MiniGame_MonsterActor_PauseFilpbook_BP::bPause' has a wrong offset!");

// Function MirMobile.MiniGame_MonsterActor.SetHPBarPercent
// 0x0004 (0x0004 - 0x0000)
struct MiniGame_MonsterActor_SetHPBarPercent final
{
public:
	float                                         Percent;                                           // 0x0000(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(MiniGame_MonsterActor_SetHPBarPercent) == 0x000004, "Wrong alignment on MiniGame_MonsterActor_SetHPBarPercent");
static_assert(sizeof(MiniGame_MonsterActor_SetHPBarPercent) == 0x000004, "Wrong size on MiniGame_MonsterActor_SetHPBarPercent");
static_assert(offsetof(MiniGame_MonsterActor_SetHPBarPercent, Percent) == 0x000000, "Member 'MiniGame_MonsterActor_SetHPBarPercent::Percent' has a wrong offset!");

// Function MirMobile.MiniGame_MonsterActor.ShowAttackEffectFilpbook_BP
// 0x0020 (0x0020 - 0x0000)
struct MiniGame_MonsterActor_ShowAttackEffectFilpbook_BP final
{
public:
	EMiniGameMonsterState                         EState;                                            // 0x0000(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1[0x3];                                        // 0x0001(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	struct FVector                                VScale;                                            // 0x0004(0x000C)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                VLoc;                                              // 0x0010(0x000C)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         FDelay;                                            // 0x001C(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(MiniGame_MonsterActor_ShowAttackEffectFilpbook_BP) == 0x000004, "Wrong alignment on MiniGame_MonsterActor_ShowAttackEffectFilpbook_BP");
static_assert(sizeof(MiniGame_MonsterActor_ShowAttackEffectFilpbook_BP) == 0x000020, "Wrong size on MiniGame_MonsterActor_ShowAttackEffectFilpbook_BP");
static_assert(offsetof(MiniGame_MonsterActor_ShowAttackEffectFilpbook_BP, EState) == 0x000000, "Member 'MiniGame_MonsterActor_ShowAttackEffectFilpbook_BP::EState' has a wrong offset!");
static_assert(offsetof(MiniGame_MonsterActor_ShowAttackEffectFilpbook_BP, VScale) == 0x000004, "Member 'MiniGame_MonsterActor_ShowAttackEffectFilpbook_BP::VScale' has a wrong offset!");
static_assert(offsetof(MiniGame_MonsterActor_ShowAttackEffectFilpbook_BP, VLoc) == 0x000010, "Member 'MiniGame_MonsterActor_ShowAttackEffectFilpbook_BP::VLoc' has a wrong offset!");
static_assert(offsetof(MiniGame_MonsterActor_ShowAttackEffectFilpbook_BP, FDelay) == 0x00001C, "Member 'MiniGame_MonsterActor_ShowAttackEffectFilpbook_BP::FDelay' has a wrong offset!");

// Function MirMobile.MiniGame_MonsterActor.ShowHitEffectFilpbook_BP
// 0x001C (0x001C - 0x0000)
struct MiniGame_MonsterActor_ShowHitEffectFilpbook_BP final
{
public:
	struct FVector                                VScale;                                            // 0x0000(0x000C)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                VLoc;                                              // 0x000C(0x000C)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         FDelay;                                            // 0x0018(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(MiniGame_MonsterActor_ShowHitEffectFilpbook_BP) == 0x000004, "Wrong alignment on MiniGame_MonsterActor_ShowHitEffectFilpbook_BP");
static_assert(sizeof(MiniGame_MonsterActor_ShowHitEffectFilpbook_BP) == 0x00001C, "Wrong size on MiniGame_MonsterActor_ShowHitEffectFilpbook_BP");
static_assert(offsetof(MiniGame_MonsterActor_ShowHitEffectFilpbook_BP, VScale) == 0x000000, "Member 'MiniGame_MonsterActor_ShowHitEffectFilpbook_BP::VScale' has a wrong offset!");
static_assert(offsetof(MiniGame_MonsterActor_ShowHitEffectFilpbook_BP, VLoc) == 0x00000C, "Member 'MiniGame_MonsterActor_ShowHitEffectFilpbook_BP::VLoc' has a wrong offset!");
static_assert(offsetof(MiniGame_MonsterActor_ShowHitEffectFilpbook_BP, FDelay) == 0x000018, "Member 'MiniGame_MonsterActor_ShowHitEffectFilpbook_BP::FDelay' has a wrong offset!");

// Function MirMobile.MiniGame_MonsterActor.ShowMonsterActor_BP
// 0x0001 (0x0001 - 0x0000)
struct MiniGame_MonsterActor_ShowMonsterActor_BP final
{
public:
	bool                                          bShow;                                             // 0x0000(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(MiniGame_MonsterActor_ShowMonsterActor_BP) == 0x000001, "Wrong alignment on MiniGame_MonsterActor_ShowMonsterActor_BP");
static_assert(sizeof(MiniGame_MonsterActor_ShowMonsterActor_BP) == 0x000001, "Wrong size on MiniGame_MonsterActor_ShowMonsterActor_BP");
static_assert(offsetof(MiniGame_MonsterActor_ShowMonsterActor_BP, bShow) == 0x000000, "Member 'MiniGame_MonsterActor_ShowMonsterActor_BP::bShow' has a wrong offset!");

// Function MirMobile.MM_GuildPerusePopup.OnClickCombatPower
// 0x0001 (0x0001 - 0x0000)
struct MM_GuildPerusePopup_OnClickCombatPower final
{
public:
	bool                                          Checked_;                                          // 0x0000(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(MM_GuildPerusePopup_OnClickCombatPower) == 0x000001, "Wrong alignment on MM_GuildPerusePopup_OnClickCombatPower");
static_assert(sizeof(MM_GuildPerusePopup_OnClickCombatPower) == 0x000001, "Wrong size on MM_GuildPerusePopup_OnClickCombatPower");
static_assert(offsetof(MM_GuildPerusePopup_OnClickCombatPower, Checked_) == 0x000000, "Member 'MM_GuildPerusePopup_OnClickCombatPower::Checked_' has a wrong offset!");

// Function MirMobile.MM_GuildPerusePopup.OnClickInvited
// 0x0001 (0x0001 - 0x0000)
struct MM_GuildPerusePopup_OnClickInvited final
{
public:
	bool                                          Checked_;                                          // 0x0000(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(MM_GuildPerusePopup_OnClickInvited) == 0x000001, "Wrong alignment on MM_GuildPerusePopup_OnClickInvited");
static_assert(sizeof(MM_GuildPerusePopup_OnClickInvited) == 0x000001, "Wrong size on MM_GuildPerusePopup_OnClickInvited");
static_assert(offsetof(MM_GuildPerusePopup_OnClickInvited, Checked_) == 0x000000, "Member 'MM_GuildPerusePopup_OnClickInvited::Checked_' has a wrong offset!");

// Function MirMobile.MM_GuildPerusePopup.OnClickLevel
// 0x0001 (0x0001 - 0x0000)
struct MM_GuildPerusePopup_OnClickLevel final
{
public:
	bool                                          Checked_;                                          // 0x0000(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(MM_GuildPerusePopup_OnClickLevel) == 0x000001, "Wrong alignment on MM_GuildPerusePopup_OnClickLevel");
static_assert(sizeof(MM_GuildPerusePopup_OnClickLevel) == 0x000001, "Wrong size on MM_GuildPerusePopup_OnClickLevel");
static_assert(offsetof(MM_GuildPerusePopup_OnClickLevel, Checked_) == 0x000000, "Member 'MM_GuildPerusePopup_OnClickLevel::Checked_' has a wrong offset!");

// Function MirMobile.MM_GuildPerusePopup.OnClickNone
// 0x0001 (0x0001 - 0x0000)
struct MM_GuildPerusePopup_OnClickNone final
{
public:
	bool                                          Checked_;                                          // 0x0000(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(MM_GuildPerusePopup_OnClickNone) == 0x000001, "Wrong alignment on MM_GuildPerusePopup_OnClickNone");
static_assert(sizeof(MM_GuildPerusePopup_OnClickNone) == 0x000001, "Wrong size on MM_GuildPerusePopup_OnClickNone");
static_assert(offsetof(MM_GuildPerusePopup_OnClickNone, Checked_) == 0x000000, "Member 'MM_GuildPerusePopup_OnClickNone::Checked_' has a wrong offset!");

// Function MirMobile.MM_GuildPerusePopup.OnClickRecommend
// 0x0001 (0x0001 - 0x0000)
struct MM_GuildPerusePopup_OnClickRecommend final
{
public:
	bool                                          Checked_;                                          // 0x0000(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(MM_GuildPerusePopup_OnClickRecommend) == 0x000001, "Wrong alignment on MM_GuildPerusePopup_OnClickRecommend");
static_assert(sizeof(MM_GuildPerusePopup_OnClickRecommend) == 0x000001, "Wrong size on MM_GuildPerusePopup_OnClickRecommend");
static_assert(offsetof(MM_GuildPerusePopup_OnClickRecommend, Checked_) == 0x000000, "Member 'MM_GuildPerusePopup_OnClickRecommend::Checked_' has a wrong offset!");

// Function MirMobile.MM_GuildPerusePopup.OnClickRequest
// 0x0001 (0x0001 - 0x0000)
struct MM_GuildPerusePopup_OnClickRequest final
{
public:
	bool                                          Checked_;                                          // 0x0000(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(MM_GuildPerusePopup_OnClickRequest) == 0x000001, "Wrong alignment on MM_GuildPerusePopup_OnClickRequest");
static_assert(sizeof(MM_GuildPerusePopup_OnClickRequest) == 0x000001, "Wrong size on MM_GuildPerusePopup_OnClickRequest");
static_assert(offsetof(MM_GuildPerusePopup_OnClickRequest, Checked_) == 0x000000, "Member 'MM_GuildPerusePopup_OnClickRequest::Checked_' has a wrong offset!");

// Function MirMobile.MM_Popup_Sabuk_EmperorOrder_Effect_Slot.Bind_ClickDelegate
// 0x0018 (0x0018 - 0x0000)
struct MM_Popup_Sabuk_EmperorOrder_Effect_Slot_Bind_ClickDelegate final
{
public:
	int32                                         IIndex;                                            // 0x0000(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_4[0x4];                                        // 0x0004(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class UObject*                                PObj;                                              // 0x0008(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   FunctionName;                                      // 0x0010(0x0008)(ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(MM_Popup_Sabuk_EmperorOrder_Effect_Slot_Bind_ClickDelegate) == 0x000008, "Wrong alignment on MM_Popup_Sabuk_EmperorOrder_Effect_Slot_Bind_ClickDelegate");
static_assert(sizeof(MM_Popup_Sabuk_EmperorOrder_Effect_Slot_Bind_ClickDelegate) == 0x000018, "Wrong size on MM_Popup_Sabuk_EmperorOrder_Effect_Slot_Bind_ClickDelegate");
static_assert(offsetof(MM_Popup_Sabuk_EmperorOrder_Effect_Slot_Bind_ClickDelegate, IIndex) == 0x000000, "Member 'MM_Popup_Sabuk_EmperorOrder_Effect_Slot_Bind_ClickDelegate::IIndex' has a wrong offset!");
static_assert(offsetof(MM_Popup_Sabuk_EmperorOrder_Effect_Slot_Bind_ClickDelegate, PObj) == 0x000008, "Member 'MM_Popup_Sabuk_EmperorOrder_Effect_Slot_Bind_ClickDelegate::PObj' has a wrong offset!");
static_assert(offsetof(MM_Popup_Sabuk_EmperorOrder_Effect_Slot_Bind_ClickDelegate, FunctionName) == 0x000010, "Member 'MM_Popup_Sabuk_EmperorOrder_Effect_Slot_Bind_ClickDelegate::FunctionName' has a wrong offset!");

// Function MirMobile.MirScaleBox.OnChangedDeviceState
// 0x0004 (0x0004 - 0x0000)
struct MirScaleBox_OnChangedDeviceState final
{
public:
	EPostureDeviceState                           EDeviceState;                                      // 0x0000(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(MirScaleBox_OnChangedDeviceState) == 0x000004, "Wrong alignment on MirScaleBox_OnChangedDeviceState");
static_assert(sizeof(MirScaleBox_OnChangedDeviceState) == 0x000004, "Wrong size on MirScaleBox_OnChangedDeviceState");
static_assert(offsetof(MirScaleBox_OnChangedDeviceState, EDeviceState) == 0x000000, "Member 'MirScaleBox_OnChangedDeviceState::EDeviceState' has a wrong offset!");

// Function MirMobile.MirPanZoomCanvas.FocusZoom
// 0x0010 (0x0010 - 0x0000)
struct MirPanZoomCanvas_FocusZoom final
{
public:
	float                                         FNewZoom;                                          // 0x0000(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector2D                              VScreenPos;                                        // 0x0004(0x0008)(ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bImmediately;                                      // 0x000C(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_D[0x3];                                        // 0x000D(0x0003)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(MirPanZoomCanvas_FocusZoom) == 0x000004, "Wrong alignment on MirPanZoomCanvas_FocusZoom");
static_assert(sizeof(MirPanZoomCanvas_FocusZoom) == 0x000010, "Wrong size on MirPanZoomCanvas_FocusZoom");
static_assert(offsetof(MirPanZoomCanvas_FocusZoom, FNewZoom) == 0x000000, "Member 'MirPanZoomCanvas_FocusZoom::FNewZoom' has a wrong offset!");
static_assert(offsetof(MirPanZoomCanvas_FocusZoom, VScreenPos) == 0x000004, "Member 'MirPanZoomCanvas_FocusZoom::VScreenPos' has a wrong offset!");
static_assert(offsetof(MirPanZoomCanvas_FocusZoom, bImmediately) == 0x00000C, "Member 'MirPanZoomCanvas_FocusZoom::bImmediately' has a wrong offset!");

// Function MirMobile.MirPanZoomCanvas.GetDest
// 0x000C (0x000C - 0x0000)
struct MirPanZoomCanvas_GetDest final
{
public:
	float                                         FDestZoom;                                         // 0x0000(0x0004)(Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector2D                              VDestPan;                                          // 0x0004(0x0008)(Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(MirPanZoomCanvas_GetDest) == 0x000004, "Wrong alignment on MirPanZoomCanvas_GetDest");
static_assert(sizeof(MirPanZoomCanvas_GetDest) == 0x00000C, "Wrong size on MirPanZoomCanvas_GetDest");
static_assert(offsetof(MirPanZoomCanvas_GetDest, FDestZoom) == 0x000000, "Member 'MirPanZoomCanvas_GetDest::FDestZoom' has a wrong offset!");
static_assert(offsetof(MirPanZoomCanvas_GetDest, VDestPan) == 0x000004, "Member 'MirPanZoomCanvas_GetDest::VDestPan' has a wrong offset!");

// Function MirMobile.MirPanZoomCanvas.GetMinMax
// 0x0018 (0x0018 - 0x0000)
struct MirPanZoomCanvas_GetMinMax final
{
public:
	float                                         FZoomMin;                                          // 0x0000(0x0004)(Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         FZoomMax;                                          // 0x0004(0x0004)(Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector2D                              VPanMin;                                           // 0x0008(0x0008)(Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector2D                              VPanMax;                                           // 0x0010(0x0008)(Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(MirPanZoomCanvas_GetMinMax) == 0x000004, "Wrong alignment on MirPanZoomCanvas_GetMinMax");
static_assert(sizeof(MirPanZoomCanvas_GetMinMax) == 0x000018, "Wrong size on MirPanZoomCanvas_GetMinMax");
static_assert(offsetof(MirPanZoomCanvas_GetMinMax, FZoomMin) == 0x000000, "Member 'MirPanZoomCanvas_GetMinMax::FZoomMin' has a wrong offset!");
static_assert(offsetof(MirPanZoomCanvas_GetMinMax, FZoomMax) == 0x000004, "Member 'MirPanZoomCanvas_GetMinMax::FZoomMax' has a wrong offset!");
static_assert(offsetof(MirPanZoomCanvas_GetMinMax, VPanMin) == 0x000008, "Member 'MirPanZoomCanvas_GetMinMax::VPanMin' has a wrong offset!");
static_assert(offsetof(MirPanZoomCanvas_GetMinMax, VPanMax) == 0x000010, "Member 'MirPanZoomCanvas_GetMinMax::VPanMax' has a wrong offset!");

// Function MirMobile.MirPanZoomCanvas.GoToHome
// 0x0001 (0x0001 - 0x0000)
struct MirPanZoomCanvas_GoToHome final
{
public:
	bool                                          bImmediately;                                      // 0x0000(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(MirPanZoomCanvas_GoToHome) == 0x000001, "Wrong alignment on MirPanZoomCanvas_GoToHome");
static_assert(sizeof(MirPanZoomCanvas_GoToHome) == 0x000001, "Wrong size on MirPanZoomCanvas_GoToHome");
static_assert(offsetof(MirPanZoomCanvas_GoToHome, bImmediately) == 0x000000, "Member 'MirPanZoomCanvas_GoToHome::bImmediately' has a wrong offset!");

// Function MirMobile.MirPanZoomCanvas.GoToWidget
// 0x0020 (0x0020 - 0x0000)
struct MirPanZoomCanvas_GoToWidget final
{
public:
	float                                         FNewZoom;                                          // 0x0000(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_4[0x4];                                        // 0x0004(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class UWidget*                                PTarget;                                           // 0x0008(0x0008)(Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector2D                              VCenterOffset;                                     // 0x0010(0x0008)(ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bImmediately;                                      // 0x0018(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_19[0x7];                                       // 0x0019(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(MirPanZoomCanvas_GoToWidget) == 0x000008, "Wrong alignment on MirPanZoomCanvas_GoToWidget");
static_assert(sizeof(MirPanZoomCanvas_GoToWidget) == 0x000020, "Wrong size on MirPanZoomCanvas_GoToWidget");
static_assert(offsetof(MirPanZoomCanvas_GoToWidget, FNewZoom) == 0x000000, "Member 'MirPanZoomCanvas_GoToWidget::FNewZoom' has a wrong offset!");
static_assert(offsetof(MirPanZoomCanvas_GoToWidget, PTarget) == 0x000008, "Member 'MirPanZoomCanvas_GoToWidget::PTarget' has a wrong offset!");
static_assert(offsetof(MirPanZoomCanvas_GoToWidget, VCenterOffset) == 0x000010, "Member 'MirPanZoomCanvas_GoToWidget::VCenterOffset' has a wrong offset!");
static_assert(offsetof(MirPanZoomCanvas_GoToWidget, bImmediately) == 0x000018, "Member 'MirPanZoomCanvas_GoToWidget::bImmediately' has a wrong offset!");

// Function MirMobile.MirPanZoomCanvas.IsDebugMode
// 0x0001 (0x0001 - 0x0000)
struct MirPanZoomCanvas_IsDebugMode final
{
public:
	bool                                          ReturnValue;                                       // 0x0000(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(MirPanZoomCanvas_IsDebugMode) == 0x000001, "Wrong alignment on MirPanZoomCanvas_IsDebugMode");
static_assert(sizeof(MirPanZoomCanvas_IsDebugMode) == 0x000001, "Wrong size on MirPanZoomCanvas_IsDebugMode");
static_assert(offsetof(MirPanZoomCanvas_IsDebugMode, ReturnValue) == 0x000000, "Member 'MirPanZoomCanvas_IsDebugMode::ReturnValue' has a wrong offset!");

// Function MirMobile.MirPanZoomCanvas.SetPan
// 0x000C (0x000C - 0x0000)
struct MirPanZoomCanvas_SetPan final
{
public:
	struct FVector2D                              VNewPan;                                           // 0x0000(0x0008)(ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bImmediately;                                      // 0x0008(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_9[0x3];                                        // 0x0009(0x0003)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(MirPanZoomCanvas_SetPan) == 0x000004, "Wrong alignment on MirPanZoomCanvas_SetPan");
static_assert(sizeof(MirPanZoomCanvas_SetPan) == 0x00000C, "Wrong size on MirPanZoomCanvas_SetPan");
static_assert(offsetof(MirPanZoomCanvas_SetPan, VNewPan) == 0x000000, "Member 'MirPanZoomCanvas_SetPan::VNewPan' has a wrong offset!");
static_assert(offsetof(MirPanZoomCanvas_SetPan, bImmediately) == 0x000008, "Member 'MirPanZoomCanvas_SetPan::bImmediately' has a wrong offset!");

// Function MirMobile.MirPanZoomCanvas.SetZoom
// 0x0008 (0x0008 - 0x0000)
struct MirPanZoomCanvas_SetZoom final
{
public:
	float                                         FNewZoom;                                          // 0x0000(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bImmediately;                                      // 0x0004(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_5[0x3];                                        // 0x0005(0x0003)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(MirPanZoomCanvas_SetZoom) == 0x000004, "Wrong alignment on MirPanZoomCanvas_SetZoom");
static_assert(sizeof(MirPanZoomCanvas_SetZoom) == 0x000008, "Wrong size on MirPanZoomCanvas_SetZoom");
static_assert(offsetof(MirPanZoomCanvas_SetZoom, FNewZoom) == 0x000000, "Member 'MirPanZoomCanvas_SetZoom::FNewZoom' has a wrong offset!");
static_assert(offsetof(MirPanZoomCanvas_SetZoom, bImmediately) == 0x000004, "Member 'MirPanZoomCanvas_SetZoom::bImmediately' has a wrong offset!");

// Function MirMobile.MirPanZoomCanvas.SetZoomPan
// 0x0010 (0x0010 - 0x0000)
struct MirPanZoomCanvas_SetZoomPan final
{
public:
	float                                         FNewZoom;                                          // 0x0000(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector2D                              VNewPan;                                           // 0x0004(0x0008)(ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bImmediately;                                      // 0x000C(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_D[0x3];                                        // 0x000D(0x0003)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(MirPanZoomCanvas_SetZoomPan) == 0x000004, "Wrong alignment on MirPanZoomCanvas_SetZoomPan");
static_assert(sizeof(MirPanZoomCanvas_SetZoomPan) == 0x000010, "Wrong size on MirPanZoomCanvas_SetZoomPan");
static_assert(offsetof(MirPanZoomCanvas_SetZoomPan, FNewZoom) == 0x000000, "Member 'MirPanZoomCanvas_SetZoomPan::FNewZoom' has a wrong offset!");
static_assert(offsetof(MirPanZoomCanvas_SetZoomPan, VNewPan) == 0x000004, "Member 'MirPanZoomCanvas_SetZoomPan::VNewPan' has a wrong offset!");
static_assert(offsetof(MirPanZoomCanvas_SetZoomPan, bImmediately) == 0x00000C, "Member 'MirPanZoomCanvas_SetZoomPan::bImmediately' has a wrong offset!");

// Function MirMobile.MM_Popup_DominionGuildMember.Bind_ClickDelegate
// 0x0010 (0x0010 - 0x0000)
struct MM_Popup_DominionGuildMember_Bind_ClickDelegate final
{
public:
	class UObject*                                PObj;                                              // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   FunctionName;                                      // 0x0008(0x0008)(ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(MM_Popup_DominionGuildMember_Bind_ClickDelegate) == 0x000008, "Wrong alignment on MM_Popup_DominionGuildMember_Bind_ClickDelegate");
static_assert(sizeof(MM_Popup_DominionGuildMember_Bind_ClickDelegate) == 0x000010, "Wrong size on MM_Popup_DominionGuildMember_Bind_ClickDelegate");
static_assert(offsetof(MM_Popup_DominionGuildMember_Bind_ClickDelegate, PObj) == 0x000000, "Member 'MM_Popup_DominionGuildMember_Bind_ClickDelegate::PObj' has a wrong offset!");
static_assert(offsetof(MM_Popup_DominionGuildMember_Bind_ClickDelegate, FunctionName) == 0x000008, "Member 'MM_Popup_DominionGuildMember_Bind_ClickDelegate::FunctionName' has a wrong offset!");

// Function MirMobile.MM_Popup_DominionGuildMember.OnClickCheckBoxSort
// 0x0001 (0x0001 - 0x0000)
struct MM_Popup_DominionGuildMember_OnClickCheckBoxSort final
{
public:
	bool                                          Checked_;                                          // 0x0000(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(MM_Popup_DominionGuildMember_OnClickCheckBoxSort) == 0x000001, "Wrong alignment on MM_Popup_DominionGuildMember_OnClickCheckBoxSort");
static_assert(sizeof(MM_Popup_DominionGuildMember_OnClickCheckBoxSort) == 0x000001, "Wrong size on MM_Popup_DominionGuildMember_OnClickCheckBoxSort");
static_assert(offsetof(MM_Popup_DominionGuildMember_OnClickCheckBoxSort, Checked_) == 0x000000, "Member 'MM_Popup_DominionGuildMember_OnClickCheckBoxSort::Checked_' has a wrong offset!");

// Function MirMobile.MM_Popup_DominionGuildMember.OnClickGuildMember
// 0x0008 (0x0008 - 0x0000)
struct MM_Popup_DominionGuildMember_OnClickGuildMember final
{
public:
	int64                                         IMemberUID;                                        // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(MM_Popup_DominionGuildMember_OnClickGuildMember) == 0x000008, "Wrong alignment on MM_Popup_DominionGuildMember_OnClickGuildMember");
static_assert(sizeof(MM_Popup_DominionGuildMember_OnClickGuildMember) == 0x000008, "Wrong size on MM_Popup_DominionGuildMember_OnClickGuildMember");
static_assert(offsetof(MM_Popup_DominionGuildMember_OnClickGuildMember, IMemberUID) == 0x000000, "Member 'MM_Popup_DominionGuildMember_OnClickGuildMember::IMemberUID' has a wrong offset!");

// Function MirMobile.CameraControlBase.CameraInitialize
// 0x0008 (0x0008 - 0x0000)
struct CameraControlBase_CameraInitialize final
{
public:
	class AMM_MainPC*                             MainPC;                                            // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(CameraControlBase_CameraInitialize) == 0x000008, "Wrong alignment on CameraControlBase_CameraInitialize");
static_assert(sizeof(CameraControlBase_CameraInitialize) == 0x000008, "Wrong size on CameraControlBase_CameraInitialize");
static_assert(offsetof(CameraControlBase_CameraInitialize, MainPC) == 0x000000, "Member 'CameraControlBase_CameraInitialize::MainPC' has a wrong offset!");

// Function MirMobile.CameraControlBase.ZoomScreen
// 0x0004 (0x0004 - 0x0000)
struct CameraControlBase_ZoomScreen final
{
public:
	float                                         Zoomsize;                                          // 0x0000(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(CameraControlBase_ZoomScreen) == 0x000004, "Wrong alignment on CameraControlBase_ZoomScreen");
static_assert(sizeof(CameraControlBase_ZoomScreen) == 0x000004, "Wrong size on CameraControlBase_ZoomScreen");
static_assert(offsetof(CameraControlBase_ZoomScreen, Zoomsize) == 0x000000, "Member 'CameraControlBase_ZoomScreen::Zoomsize' has a wrong offset!");

// Function MirMobile.CameraShakeTrigger.SetShakeAreaExtent
// 0x000C (0x000C - 0x0000)
struct CameraShakeTrigger_SetShakeAreaExtent final
{
public:
	struct FVector                                BoxExtent;                                         // 0x0000(0x000C)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(CameraShakeTrigger_SetShakeAreaExtent) == 0x000004, "Wrong alignment on CameraShakeTrigger_SetShakeAreaExtent");
static_assert(sizeof(CameraShakeTrigger_SetShakeAreaExtent) == 0x00000C, "Wrong size on CameraShakeTrigger_SetShakeAreaExtent");
static_assert(offsetof(CameraShakeTrigger_SetShakeAreaExtent, BoxExtent) == 0x000000, "Member 'CameraShakeTrigger_SetShakeAreaExtent::BoxExtent' has a wrong offset!");

// Function MirMobile.MM_VehicleInfo.OnDragScreen
// 0x0008 (0x0008 - 0x0000)
struct MM_VehicleInfo_OnDragScreen final
{
public:
	struct FVector2D                              DragDelta;                                         // 0x0000(0x0008)(ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(MM_VehicleInfo_OnDragScreen) == 0x000004, "Wrong alignment on MM_VehicleInfo_OnDragScreen");
static_assert(sizeof(MM_VehicleInfo_OnDragScreen) == 0x000008, "Wrong size on MM_VehicleInfo_OnDragScreen");
static_assert(offsetof(MM_VehicleInfo_OnDragScreen, DragDelta) == 0x000000, "Member 'MM_VehicleInfo_OnDragScreen::DragDelta' has a wrong offset!");

// Function MirMobile.CinematicAnimInstance.GetFirstAnim
// 0x0008 (0x0008 - 0x0000)
struct CinematicAnimInstance_GetFirstAnim final
{
public:
	class UAnimSequenceBase*                      ReturnValue;                                       // 0x0000(0x0008)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(CinematicAnimInstance_GetFirstAnim) == 0x000008, "Wrong alignment on CinematicAnimInstance_GetFirstAnim");
static_assert(sizeof(CinematicAnimInstance_GetFirstAnim) == 0x000008, "Wrong size on CinematicAnimInstance_GetFirstAnim");
static_assert(offsetof(CinematicAnimInstance_GetFirstAnim, ReturnValue) == 0x000000, "Member 'CinematicAnimInstance_GetFirstAnim::ReturnValue' has a wrong offset!");

// Function MirMobile.CinematicAnimInstance.GetSecondAnim
// 0x0008 (0x0008 - 0x0000)
struct CinematicAnimInstance_GetSecondAnim final
{
public:
	class UAnimSequenceBase*                      ReturnValue;                                       // 0x0000(0x0008)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(CinematicAnimInstance_GetSecondAnim) == 0x000008, "Wrong alignment on CinematicAnimInstance_GetSecondAnim");
static_assert(sizeof(CinematicAnimInstance_GetSecondAnim) == 0x000008, "Wrong size on CinematicAnimInstance_GetSecondAnim");
static_assert(offsetof(CinematicAnimInstance_GetSecondAnim, ReturnValue) == 0x000000, "Member 'CinematicAnimInstance_GetSecondAnim::ReturnValue' has a wrong offset!");

// Function MirMobile.MM_GameInstance.CalculateAttackDamage
// 0x0024 (0x0024 - 0x0000)
struct MM_GameInstance_CalculateAttackDamage final
{
public:
	struct FATTACK_DATA                           ATTACK_DATA;                                       // 0x0000(0x0020)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	float                                         ReturnValue;                                       // 0x0020(0x0004)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(MM_GameInstance_CalculateAttackDamage) == 0x000004, "Wrong alignment on MM_GameInstance_CalculateAttackDamage");
static_assert(sizeof(MM_GameInstance_CalculateAttackDamage) == 0x000024, "Wrong size on MM_GameInstance_CalculateAttackDamage");
static_assert(offsetof(MM_GameInstance_CalculateAttackDamage, ATTACK_DATA) == 0x000000, "Member 'MM_GameInstance_CalculateAttackDamage::ATTACK_DATA' has a wrong offset!");
static_assert(offsetof(MM_GameInstance_CalculateAttackDamage, ReturnValue) == 0x000020, "Member 'MM_GameInstance_CalculateAttackDamage::ReturnValue' has a wrong offset!");

// Function MirMobile.MM_GameInstance.LoadLevelInstance
// 0x0018 (0x0018 - 0x0000)
struct MM_GameInstance_LoadLevelInstance final
{
public:
	class FString                                 LevelName;                                         // 0x0000(0x0010)(Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class ULevelStreamingDynamic*                 ReturnValue;                                       // 0x0010(0x0008)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(MM_GameInstance_LoadLevelInstance) == 0x000008, "Wrong alignment on MM_GameInstance_LoadLevelInstance");
static_assert(sizeof(MM_GameInstance_LoadLevelInstance) == 0x000018, "Wrong size on MM_GameInstance_LoadLevelInstance");
static_assert(offsetof(MM_GameInstance_LoadLevelInstance, LevelName) == 0x000000, "Member 'MM_GameInstance_LoadLevelInstance::LevelName' has a wrong offset!");
static_assert(offsetof(MM_GameInstance_LoadLevelInstance, ReturnValue) == 0x000010, "Member 'MM_GameInstance_LoadLevelInstance::ReturnValue' has a wrong offset!");

// Function MirMobile.MM_GameInstance.OnLevelStreamingProgress
// 0x0008 (0x0008 - 0x0000)
struct MM_GameInstance_OnLevelStreamingProgress final
{
public:
	int32                                         IProcessed;                                        // 0x0000(0x0004)(ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         ITotal;                                            // 0x0004(0x0004)(ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(MM_GameInstance_OnLevelStreamingProgress) == 0x000004, "Wrong alignment on MM_GameInstance_OnLevelStreamingProgress");
static_assert(sizeof(MM_GameInstance_OnLevelStreamingProgress) == 0x000008, "Wrong size on MM_GameInstance_OnLevelStreamingProgress");
static_assert(offsetof(MM_GameInstance_OnLevelStreamingProgress, IProcessed) == 0x000000, "Member 'MM_GameInstance_OnLevelStreamingProgress::IProcessed' has a wrong offset!");
static_assert(offsetof(MM_GameInstance_OnLevelStreamingProgress, ITotal) == 0x000004, "Member 'MM_GameInstance_OnLevelStreamingProgress::ITotal' has a wrong offset!");

// Function MirMobile.MM_GameInstance.OnParticleSystemFinished
// 0x0008 (0x0008 - 0x0000)
struct MM_GameInstance_OnParticleSystemFinished final
{
public:
	class UParticleSystemComponent*               FinishedComponent;                                 // 0x0000(0x0008)(Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(MM_GameInstance_OnParticleSystemFinished) == 0x000008, "Wrong alignment on MM_GameInstance_OnParticleSystemFinished");
static_assert(sizeof(MM_GameInstance_OnParticleSystemFinished) == 0x000008, "Wrong size on MM_GameInstance_OnParticleSystemFinished");
static_assert(offsetof(MM_GameInstance_OnParticleSystemFinished, FinishedComponent) == 0x000000, "Member 'MM_GameInstance_OnParticleSystemFinished::FinishedComponent' has a wrong offset!");

// Function MirMobile.MM_GameInstance.RELEASE_UNUSED_MEMORY_START
// 0x0004 (0x0004 - 0x0000)
struct MM_GameInstance_RELEASE_UNUSED_MEMORY_START final
{
public:
	float                                         FInterval;                                         // 0x0000(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(MM_GameInstance_RELEASE_UNUSED_MEMORY_START) == 0x000004, "Wrong alignment on MM_GameInstance_RELEASE_UNUSED_MEMORY_START");
static_assert(sizeof(MM_GameInstance_RELEASE_UNUSED_MEMORY_START) == 0x000004, "Wrong size on MM_GameInstance_RELEASE_UNUSED_MEMORY_START");
static_assert(offsetof(MM_GameInstance_RELEASE_UNUSED_MEMORY_START, FInterval) == 0x000000, "Member 'MM_GameInstance_RELEASE_UNUSED_MEMORY_START::FInterval' has a wrong offset!");

// Function MirMobile.CombatPointPopupWidget.GetChagePercent
// 0x0004 (0x0004 - 0x0000)
struct CombatPointPopupWidget_GetChagePercent final
{
public:
	float                                         ReturnValue;                                       // 0x0000(0x0004)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(CombatPointPopupWidget_GetChagePercent) == 0x000004, "Wrong alignment on CombatPointPopupWidget_GetChagePercent");
static_assert(sizeof(CombatPointPopupWidget_GetChagePercent) == 0x000004, "Wrong size on CombatPointPopupWidget_GetChagePercent");
static_assert(offsetof(CombatPointPopupWidget_GetChagePercent, ReturnValue) == 0x000000, "Member 'CombatPointPopupWidget_GetChagePercent::ReturnValue' has a wrong offset!");

// Function MirMobile.MM_GameOption_Select.GetSelectSlot
// 0x0004 (0x0004 - 0x0000)
struct MM_GameOption_Select_GetSelectSlot final
{
public:
	int32                                         ReturnValue;                                       // 0x0000(0x0004)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(MM_GameOption_Select_GetSelectSlot) == 0x000004, "Wrong alignment on MM_GameOption_Select_GetSelectSlot");
static_assert(sizeof(MM_GameOption_Select_GetSelectSlot) == 0x000004, "Wrong size on MM_GameOption_Select_GetSelectSlot");
static_assert(offsetof(MM_GameOption_Select_GetSelectSlot, ReturnValue) == 0x000000, "Member 'MM_GameOption_Select_GetSelectSlot::ReturnValue' has a wrong offset!");

// Function MirMobile.MM_GameOption_Select.OnClickeSelect0
// 0x0001 (0x0001 - 0x0000)
struct MM_GameOption_Select_OnClickeSelect0 final
{
public:
	bool                                          bChecked;                                          // 0x0000(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(MM_GameOption_Select_OnClickeSelect0) == 0x000001, "Wrong alignment on MM_GameOption_Select_OnClickeSelect0");
static_assert(sizeof(MM_GameOption_Select_OnClickeSelect0) == 0x000001, "Wrong size on MM_GameOption_Select_OnClickeSelect0");
static_assert(offsetof(MM_GameOption_Select_OnClickeSelect0, bChecked) == 0x000000, "Member 'MM_GameOption_Select_OnClickeSelect0::bChecked' has a wrong offset!");

// Function MirMobile.MM_GameOption_Select.OnClickeSelect1
// 0x0001 (0x0001 - 0x0000)
struct MM_GameOption_Select_OnClickeSelect1 final
{
public:
	bool                                          bChecked;                                          // 0x0000(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(MM_GameOption_Select_OnClickeSelect1) == 0x000001, "Wrong alignment on MM_GameOption_Select_OnClickeSelect1");
static_assert(sizeof(MM_GameOption_Select_OnClickeSelect1) == 0x000001, "Wrong size on MM_GameOption_Select_OnClickeSelect1");
static_assert(offsetof(MM_GameOption_Select_OnClickeSelect1, bChecked) == 0x000000, "Member 'MM_GameOption_Select_OnClickeSelect1::bChecked' has a wrong offset!");

// Function MirMobile.MM_GameOption_Select.OnClickeSelect2
// 0x0001 (0x0001 - 0x0000)
struct MM_GameOption_Select_OnClickeSelect2 final
{
public:
	bool                                          bChecked;                                          // 0x0000(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(MM_GameOption_Select_OnClickeSelect2) == 0x000001, "Wrong alignment on MM_GameOption_Select_OnClickeSelect2");
static_assert(sizeof(MM_GameOption_Select_OnClickeSelect2) == 0x000001, "Wrong size on MM_GameOption_Select_OnClickeSelect2");
static_assert(offsetof(MM_GameOption_Select_OnClickeSelect2, bChecked) == 0x000000, "Member 'MM_GameOption_Select_OnClickeSelect2::bChecked' has a wrong offset!");

// Function MirMobile.MM_GameOption_Select.OnClickeSelect3
// 0x0001 (0x0001 - 0x0000)
struct MM_GameOption_Select_OnClickeSelect3 final
{
public:
	bool                                          bChecked;                                          // 0x0000(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(MM_GameOption_Select_OnClickeSelect3) == 0x000001, "Wrong alignment on MM_GameOption_Select_OnClickeSelect3");
static_assert(sizeof(MM_GameOption_Select_OnClickeSelect3) == 0x000001, "Wrong size on MM_GameOption_Select_OnClickeSelect3");
static_assert(offsetof(MM_GameOption_Select_OnClickeSelect3, bChecked) == 0x000000, "Member 'MM_GameOption_Select_OnClickeSelect3::bChecked' has a wrong offset!");

// Function MirMobile.MM_GameOption_Select.OnClickeSelect4
// 0x0001 (0x0001 - 0x0000)
struct MM_GameOption_Select_OnClickeSelect4 final
{
public:
	bool                                          bChecked;                                          // 0x0000(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(MM_GameOption_Select_OnClickeSelect4) == 0x000001, "Wrong alignment on MM_GameOption_Select_OnClickeSelect4");
static_assert(sizeof(MM_GameOption_Select_OnClickeSelect4) == 0x000001, "Wrong size on MM_GameOption_Select_OnClickeSelect4");
static_assert(offsetof(MM_GameOption_Select_OnClickeSelect4, bChecked) == 0x000000, "Member 'MM_GameOption_Select_OnClickeSelect4::bChecked' has a wrong offset!");

// Function MirMobile.MM_GameOption_Select.OnClickeSelect5
// 0x0001 (0x0001 - 0x0000)
struct MM_GameOption_Select_OnClickeSelect5 final
{
public:
	bool                                          bChecked;                                          // 0x0000(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(MM_GameOption_Select_OnClickeSelect5) == 0x000001, "Wrong alignment on MM_GameOption_Select_OnClickeSelect5");
static_assert(sizeof(MM_GameOption_Select_OnClickeSelect5) == 0x000001, "Wrong size on MM_GameOption_Select_OnClickeSelect5");
static_assert(offsetof(MM_GameOption_Select_OnClickeSelect5, bChecked) == 0x000000, "Member 'MM_GameOption_Select_OnClickeSelect5::bChecked' has a wrong offset!");

// Function MirMobile.MM_GameOption_Select.SetSelectSlot
// 0x0004 (0x0004 - 0x0000)
struct MM_GameOption_Select_SetSelectSlot final
{
public:
	int32                                         _Idx;                                              // 0x0000(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(MM_GameOption_Select_SetSelectSlot) == 0x000004, "Wrong alignment on MM_GameOption_Select_SetSelectSlot");
static_assert(sizeof(MM_GameOption_Select_SetSelectSlot) == 0x000004, "Wrong size on MM_GameOption_Select_SetSelectSlot");
static_assert(offsetof(MM_GameOption_Select_SetSelectSlot, _Idx) == 0x000000, "Member 'MM_GameOption_Select_SetSelectSlot::_Idx' has a wrong offset!");

// Function MirMobile.ComboWidget.Calc100000Num
// 0x0008 (0x0008 - 0x0000)
struct ComboWidget_Calc100000Num final
{
public:
	int32                                         FullNum;                                           // 0x0000(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         ReturnValue;                                       // 0x0004(0x0004)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(ComboWidget_Calc100000Num) == 0x000004, "Wrong alignment on ComboWidget_Calc100000Num");
static_assert(sizeof(ComboWidget_Calc100000Num) == 0x000008, "Wrong size on ComboWidget_Calc100000Num");
static_assert(offsetof(ComboWidget_Calc100000Num, FullNum) == 0x000000, "Member 'ComboWidget_Calc100000Num::FullNum' has a wrong offset!");
static_assert(offsetof(ComboWidget_Calc100000Num, ReturnValue) == 0x000004, "Member 'ComboWidget_Calc100000Num::ReturnValue' has a wrong offset!");

// Function MirMobile.ComboWidget.Calc10000Num
// 0x0008 (0x0008 - 0x0000)
struct ComboWidget_Calc10000Num final
{
public:
	int32                                         FullNum;                                           // 0x0000(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         ReturnValue;                                       // 0x0004(0x0004)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(ComboWidget_Calc10000Num) == 0x000004, "Wrong alignment on ComboWidget_Calc10000Num");
static_assert(sizeof(ComboWidget_Calc10000Num) == 0x000008, "Wrong size on ComboWidget_Calc10000Num");
static_assert(offsetof(ComboWidget_Calc10000Num, FullNum) == 0x000000, "Member 'ComboWidget_Calc10000Num::FullNum' has a wrong offset!");
static_assert(offsetof(ComboWidget_Calc10000Num, ReturnValue) == 0x000004, "Member 'ComboWidget_Calc10000Num::ReturnValue' has a wrong offset!");

// Function MirMobile.ComboWidget.Calc1000Num
// 0x0008 (0x0008 - 0x0000)
struct ComboWidget_Calc1000Num final
{
public:
	int32                                         FullNum;                                           // 0x0000(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         ReturnValue;                                       // 0x0004(0x0004)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(ComboWidget_Calc1000Num) == 0x000004, "Wrong alignment on ComboWidget_Calc1000Num");
static_assert(sizeof(ComboWidget_Calc1000Num) == 0x000008, "Wrong size on ComboWidget_Calc1000Num");
static_assert(offsetof(ComboWidget_Calc1000Num, FullNum) == 0x000000, "Member 'ComboWidget_Calc1000Num::FullNum' has a wrong offset!");
static_assert(offsetof(ComboWidget_Calc1000Num, ReturnValue) == 0x000004, "Member 'ComboWidget_Calc1000Num::ReturnValue' has a wrong offset!");

// Function MirMobile.ComboWidget.Calc100Num
// 0x0008 (0x0008 - 0x0000)
struct ComboWidget_Calc100Num final
{
public:
	int32                                         FullNum;                                           // 0x0000(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         ReturnValue;                                       // 0x0004(0x0004)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(ComboWidget_Calc100Num) == 0x000004, "Wrong alignment on ComboWidget_Calc100Num");
static_assert(sizeof(ComboWidget_Calc100Num) == 0x000008, "Wrong size on ComboWidget_Calc100Num");
static_assert(offsetof(ComboWidget_Calc100Num, FullNum) == 0x000000, "Member 'ComboWidget_Calc100Num::FullNum' has a wrong offset!");
static_assert(offsetof(ComboWidget_Calc100Num, ReturnValue) == 0x000004, "Member 'ComboWidget_Calc100Num::ReturnValue' has a wrong offset!");

// Function MirMobile.ComboWidget.Calc10Num
// 0x0008 (0x0008 - 0x0000)
struct ComboWidget_Calc10Num final
{
public:
	int32                                         FullNum;                                           // 0x0000(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         ReturnValue;                                       // 0x0004(0x0004)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(ComboWidget_Calc10Num) == 0x000004, "Wrong alignment on ComboWidget_Calc10Num");
static_assert(sizeof(ComboWidget_Calc10Num) == 0x000008, "Wrong size on ComboWidget_Calc10Num");
static_assert(offsetof(ComboWidget_Calc10Num, FullNum) == 0x000000, "Member 'ComboWidget_Calc10Num::FullNum' has a wrong offset!");
static_assert(offsetof(ComboWidget_Calc10Num, ReturnValue) == 0x000004, "Member 'ComboWidget_Calc10Num::ReturnValue' has a wrong offset!");

// Function MirMobile.ComboWidget.Calc1Num
// 0x0008 (0x0008 - 0x0000)
struct ComboWidget_Calc1Num final
{
public:
	int32                                         FullNum;                                           // 0x0000(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         ReturnValue;                                       // 0x0004(0x0004)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(ComboWidget_Calc1Num) == 0x000004, "Wrong alignment on ComboWidget_Calc1Num");
static_assert(sizeof(ComboWidget_Calc1Num) == 0x000008, "Wrong size on ComboWidget_Calc1Num");
static_assert(offsetof(ComboWidget_Calc1Num, FullNum) == 0x000000, "Member 'ComboWidget_Calc1Num::FullNum' has a wrong offset!");
static_assert(offsetof(ComboWidget_Calc1Num, ReturnValue) == 0x000004, "Member 'ComboWidget_Calc1Num::ReturnValue' has a wrong offset!");

// Function MirMobile.ComboWidget.CalcDigitNum
// 0x0008 (0x0008 - 0x0000)
struct ComboWidget_CalcDigitNum final
{
public:
	int32                                         FullNum;                                           // 0x0000(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         ReturnValue;                                       // 0x0004(0x0004)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(ComboWidget_CalcDigitNum) == 0x000004, "Wrong alignment on ComboWidget_CalcDigitNum");
static_assert(sizeof(ComboWidget_CalcDigitNum) == 0x000008, "Wrong size on ComboWidget_CalcDigitNum");
static_assert(offsetof(ComboWidget_CalcDigitNum, FullNum) == 0x000000, "Member 'ComboWidget_CalcDigitNum::FullNum' has a wrong offset!");
static_assert(offsetof(ComboWidget_CalcDigitNum, ReturnValue) == 0x000004, "Member 'ComboWidget_CalcDigitNum::ReturnValue' has a wrong offset!");

// Function MirMobile.ComboWidget.SetAnimTime
// 0x0008 (0x0008 - 0x0000)
struct ComboWidget_SetAnimTime final
{
public:
	float                                         StartTime;                                         // 0x0000(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         EndTime;                                           // 0x0004(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(ComboWidget_SetAnimTime) == 0x000004, "Wrong alignment on ComboWidget_SetAnimTime");
static_assert(sizeof(ComboWidget_SetAnimTime) == 0x000008, "Wrong size on ComboWidget_SetAnimTime");
static_assert(offsetof(ComboWidget_SetAnimTime, StartTime) == 0x000000, "Member 'ComboWidget_SetAnimTime::StartTime' has a wrong offset!");
static_assert(offsetof(ComboWidget_SetAnimTime, EndTime) == 0x000004, "Member 'ComboWidget_SetAnimTime::EndTime' has a wrong offset!");

// Function MirMobile.LobbyCameraControl.PlayScriptCameraShake
// 0x0004 (0x0004 - 0x0000)
struct LobbyCameraControl_PlayScriptCameraShake final
{
public:
	float                                         Duration;                                          // 0x0000(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(LobbyCameraControl_PlayScriptCameraShake) == 0x000004, "Wrong alignment on LobbyCameraControl_PlayScriptCameraShake");
static_assert(sizeof(LobbyCameraControl_PlayScriptCameraShake) == 0x000004, "Wrong size on LobbyCameraControl_PlayScriptCameraShake");
static_assert(offsetof(LobbyCameraControl_PlayScriptCameraShake, Duration) == 0x000000, "Member 'LobbyCameraControl_PlayScriptCameraShake::Duration' has a wrong offset!");

// Function MirMobile.LobbyCameraControl.PlayScriptCameraShake_Event
// 0x0008 (0x0008 - 0x0000)
struct LobbyCameraControl_PlayScriptCameraShake_Event final
{
public:
	class UCameraShake*                           ReturnValue;                                       // 0x0000(0x0008)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(LobbyCameraControl_PlayScriptCameraShake_Event) == 0x000008, "Wrong alignment on LobbyCameraControl_PlayScriptCameraShake_Event");
static_assert(sizeof(LobbyCameraControl_PlayScriptCameraShake_Event) == 0x000008, "Wrong size on LobbyCameraControl_PlayScriptCameraShake_Event");
static_assert(offsetof(LobbyCameraControl_PlayScriptCameraShake_Event, ReturnValue) == 0x000000, "Member 'LobbyCameraControl_PlayScriptCameraShake_Event::ReturnValue' has a wrong offset!");

// Function MirMobile.LobbyCameraControl.SetCameraTarget
// 0x0008 (0x0008 - 0x0000)
struct LobbyCameraControl_SetCameraTarget final
{
public:
	class AMM_EntityBase*                         PCharacter;                                        // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(LobbyCameraControl_SetCameraTarget) == 0x000008, "Wrong alignment on LobbyCameraControl_SetCameraTarget");
static_assert(sizeof(LobbyCameraControl_SetCameraTarget) == 0x000008, "Wrong size on LobbyCameraControl_SetCameraTarget");
static_assert(offsetof(LobbyCameraControl_SetCameraTarget, PCharacter) == 0x000000, "Member 'LobbyCameraControl_SetCameraTarget::PCharacter' has a wrong offset!");

// Function MirMobile.LobbyCameraControl.ShowPhaseEnterEffect
// 0x0001 (0x0001 - 0x0000)
struct LobbyCameraControl_ShowPhaseEnterEffect final
{
public:
	bool                                          bPhaseIn;                                          // 0x0000(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(LobbyCameraControl_ShowPhaseEnterEffect) == 0x000001, "Wrong alignment on LobbyCameraControl_ShowPhaseEnterEffect");
static_assert(sizeof(LobbyCameraControl_ShowPhaseEnterEffect) == 0x000001, "Wrong size on LobbyCameraControl_ShowPhaseEnterEffect");
static_assert(offsetof(LobbyCameraControl_ShowPhaseEnterEffect, bPhaseIn) == 0x000000, "Member 'LobbyCameraControl_ShowPhaseEnterEffect::bPhaseIn' has a wrong offset!");

// Function MirMobile.LobbyCameraControl.StopScriptCameraShake_Event
// 0x0008 (0x0008 - 0x0000)
struct LobbyCameraControl_StopScriptCameraShake_Event final
{
public:
	class UCameraShake*                           PCameraShake;                                      // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(LobbyCameraControl_StopScriptCameraShake_Event) == 0x000008, "Wrong alignment on LobbyCameraControl_StopScriptCameraShake_Event");
static_assert(sizeof(LobbyCameraControl_StopScriptCameraShake_Event) == 0x000008, "Wrong size on LobbyCameraControl_StopScriptCameraShake_Event");
static_assert(offsetof(LobbyCameraControl_StopScriptCameraShake_Event, PCameraShake) == 0x000000, "Member 'LobbyCameraControl_StopScriptCameraShake_Event::PCameraShake' has a wrong offset!");

// Function MirMobile.LobbyCameraControl.UpdateLockOnCamera
// 0x0030 (0x0030 - 0x0000)
struct LobbyCameraControl_UpdateLockOnCamera final
{
public:
	struct FVector                                CurrentLoc;                                        // 0x0000(0x000C)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FRotator                               CurrentRot;                                        // 0x000C(0x000C)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	struct FVector                                RefLoc;                                            // 0x0018(0x000C)(Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FRotator                               RefRot;                                            // 0x0024(0x000C)(Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(LobbyCameraControl_UpdateLockOnCamera) == 0x000004, "Wrong alignment on LobbyCameraControl_UpdateLockOnCamera");
static_assert(sizeof(LobbyCameraControl_UpdateLockOnCamera) == 0x000030, "Wrong size on LobbyCameraControl_UpdateLockOnCamera");
static_assert(offsetof(LobbyCameraControl_UpdateLockOnCamera, CurrentLoc) == 0x000000, "Member 'LobbyCameraControl_UpdateLockOnCamera::CurrentLoc' has a wrong offset!");
static_assert(offsetof(LobbyCameraControl_UpdateLockOnCamera, CurrentRot) == 0x00000C, "Member 'LobbyCameraControl_UpdateLockOnCamera::CurrentRot' has a wrong offset!");
static_assert(offsetof(LobbyCameraControl_UpdateLockOnCamera, RefLoc) == 0x000018, "Member 'LobbyCameraControl_UpdateLockOnCamera::RefLoc' has a wrong offset!");
static_assert(offsetof(LobbyCameraControl_UpdateLockOnCamera, RefRot) == 0x000024, "Member 'LobbyCameraControl_UpdateLockOnCamera::RefRot' has a wrong offset!");

// Function MirMobile.MM_GachaManagerActor.ChangeCameraView
// 0x0001 (0x0001 - 0x0000)
struct MM_GachaManagerActor_ChangeCameraView final
{
public:
	EGachaViewType                                ViewType;                                          // 0x0000(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(MM_GachaManagerActor_ChangeCameraView) == 0x000001, "Wrong alignment on MM_GachaManagerActor_ChangeCameraView");
static_assert(sizeof(MM_GachaManagerActor_ChangeCameraView) == 0x000001, "Wrong size on MM_GachaManagerActor_ChangeCameraView");
static_assert(offsetof(MM_GachaManagerActor_ChangeCameraView, ViewType) == 0x000000, "Member 'MM_GachaManagerActor_ChangeCameraView::ViewType' has a wrong offset!");

// Function MirMobile.MM_GachaManagerActor.ChangeGachaViewEvent
// 0x0001 (0x0001 - 0x0000)
struct MM_GachaManagerActor_ChangeGachaViewEvent final
{
public:
	EGachaViewType                                ViewType;                                          // 0x0000(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(MM_GachaManagerActor_ChangeGachaViewEvent) == 0x000001, "Wrong alignment on MM_GachaManagerActor_ChangeGachaViewEvent");
static_assert(sizeof(MM_GachaManagerActor_ChangeGachaViewEvent) == 0x000001, "Wrong size on MM_GachaManagerActor_ChangeGachaViewEvent");
static_assert(offsetof(MM_GachaManagerActor_ChangeGachaViewEvent, ViewType) == 0x000000, "Member 'MM_GachaManagerActor_ChangeGachaViewEvent::ViewType' has a wrong offset!");

// Function MirMobile.MM_GachaManagerActor.OnClickGachaList
// 0x0001 (0x0001 - 0x0000)
struct MM_GachaManagerActor_OnClickGachaList final
{
public:
	EGachaResultType                              GachaRewardType;                                   // 0x0000(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(MM_GachaManagerActor_OnClickGachaList) == 0x000001, "Wrong alignment on MM_GachaManagerActor_OnClickGachaList");
static_assert(sizeof(MM_GachaManagerActor_OnClickGachaList) == 0x000001, "Wrong size on MM_GachaManagerActor_OnClickGachaList");
static_assert(offsetof(MM_GachaManagerActor_OnClickGachaList, GachaRewardType) == 0x000000, "Member 'MM_GachaManagerActor_OnClickGachaList::GachaRewardType' has a wrong offset!");

// Function MirMobile.MM_GachaManagerActor.SetGachaInteractionObjectActor
// 0x0008 (0x0008 - 0x0000)
struct MM_GachaManagerActor_SetGachaInteractionObjectActor final
{
public:
	const class UChildActorComponent*             ChildActorComponent;                               // 0x0000(0x0008)(ConstParm, Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(MM_GachaManagerActor_SetGachaInteractionObjectActor) == 0x000008, "Wrong alignment on MM_GachaManagerActor_SetGachaInteractionObjectActor");
static_assert(sizeof(MM_GachaManagerActor_SetGachaInteractionObjectActor) == 0x000008, "Wrong size on MM_GachaManagerActor_SetGachaInteractionObjectActor");
static_assert(offsetof(MM_GachaManagerActor_SetGachaInteractionObjectActor, ChildActorComponent) == 0x000000, "Member 'MM_GachaManagerActor_SetGachaInteractionObjectActor::ChildActorComponent' has a wrong offset!");

// Function MirMobile.MM_GachaManagerActor.SetGachaObjectActors
// 0x0010 (0x0010 - 0x0000)
struct MM_GachaManagerActor_SetGachaObjectActors final
{
public:
	TArray<class UChildActorComponent*>           ChildActorComponents;                              // 0x0000(0x0010)(ConstParm, Parm, ZeroConstructor, ContainsInstancedReference, NativeAccessSpecifierPublic)
};
static_assert(alignof(MM_GachaManagerActor_SetGachaObjectActors) == 0x000008, "Wrong alignment on MM_GachaManagerActor_SetGachaObjectActors");
static_assert(sizeof(MM_GachaManagerActor_SetGachaObjectActors) == 0x000010, "Wrong size on MM_GachaManagerActor_SetGachaObjectActors");
static_assert(offsetof(MM_GachaManagerActor_SetGachaObjectActors, ChildActorComponents) == 0x000000, "Member 'MM_GachaManagerActor_SetGachaObjectActors::ChildActorComponents' has a wrong offset!");

// Function MirMobile.MM_GachaManagerActor.SetGachaObjectData
// 0x0038 (0x0038 - 0x0000)
struct MM_GachaManagerActor_SetGachaObjectData final
{
public:
	bool                                          bSkip;                                             // 0x0000(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EGachaType                                    GachaType;                                         // 0x0001(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2[0x6];                                        // 0x0002(0x0006)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<EGachaResultType>                      GachaResultTypeList;                               // 0x0008(0x0010)(ConstParm, Parm, ZeroConstructor, NativeAccessSpecifierPublic)
	TArray<int32>                                 ItemIDList;                                        // 0x0018(0x0010)(ConstParm, Parm, ZeroConstructor, NativeAccessSpecifierPublic)
	TArray<int32>                                 ItemGradeList;                                     // 0x0028(0x0010)(ConstParm, Parm, ZeroConstructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(MM_GachaManagerActor_SetGachaObjectData) == 0x000008, "Wrong alignment on MM_GachaManagerActor_SetGachaObjectData");
static_assert(sizeof(MM_GachaManagerActor_SetGachaObjectData) == 0x000038, "Wrong size on MM_GachaManagerActor_SetGachaObjectData");
static_assert(offsetof(MM_GachaManagerActor_SetGachaObjectData, bSkip) == 0x000000, "Member 'MM_GachaManagerActor_SetGachaObjectData::bSkip' has a wrong offset!");
static_assert(offsetof(MM_GachaManagerActor_SetGachaObjectData, GachaType) == 0x000001, "Member 'MM_GachaManagerActor_SetGachaObjectData::GachaType' has a wrong offset!");
static_assert(offsetof(MM_GachaManagerActor_SetGachaObjectData, GachaResultTypeList) == 0x000008, "Member 'MM_GachaManagerActor_SetGachaObjectData::GachaResultTypeList' has a wrong offset!");
static_assert(offsetof(MM_GachaManagerActor_SetGachaObjectData, ItemIDList) == 0x000018, "Member 'MM_GachaManagerActor_SetGachaObjectData::ItemIDList' has a wrong offset!");
static_assert(offsetof(MM_GachaManagerActor_SetGachaObjectData, ItemGradeList) == 0x000028, "Member 'MM_GachaManagerActor_SetGachaObjectData::ItemGradeList' has a wrong offset!");

// Function MirMobile.MM_GachaManagerActor.SetGachaObjectPosition
// 0x0001 (0x0001 - 0x0000)
struct MM_GachaManagerActor_SetGachaObjectPosition final
{
public:
	bool                                          b11Gacha;                                          // 0x0000(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(MM_GachaManagerActor_SetGachaObjectPosition) == 0x000001, "Wrong alignment on MM_GachaManagerActor_SetGachaObjectPosition");
static_assert(sizeof(MM_GachaManagerActor_SetGachaObjectPosition) == 0x000001, "Wrong size on MM_GachaManagerActor_SetGachaObjectPosition");
static_assert(offsetof(MM_GachaManagerActor_SetGachaObjectPosition, b11Gacha) == 0x000000, "Member 'MM_GachaManagerActor_SetGachaObjectPosition::b11Gacha' has a wrong offset!");

// Function MirMobile.MM_GachaManagerActor.SetGachaVisualSettings
// 0x0001 (0x0001 - 0x0000)
struct MM_GachaManagerActor_SetGachaVisualSettings final
{
public:
	EGachaVisualSettingsType                      SettingsType;                                      // 0x0000(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(MM_GachaManagerActor_SetGachaVisualSettings) == 0x000001, "Wrong alignment on MM_GachaManagerActor_SetGachaVisualSettings");
static_assert(sizeof(MM_GachaManagerActor_SetGachaVisualSettings) == 0x000001, "Wrong size on MM_GachaManagerActor_SetGachaVisualSettings");
static_assert(offsetof(MM_GachaManagerActor_SetGachaVisualSettings, SettingsType) == 0x000000, "Member 'MM_GachaManagerActor_SetGachaVisualSettings::SettingsType' has a wrong offset!");

// Function MirMobile.MM_GachaManagerActor.ShowGachaAutoCount
// 0x0001 (0x0001 - 0x0000)
struct MM_GachaManagerActor_ShowGachaAutoCount final
{
public:
	bool                                          bAutoMode;                                         // 0x0000(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(MM_GachaManagerActor_ShowGachaAutoCount) == 0x000001, "Wrong alignment on MM_GachaManagerActor_ShowGachaAutoCount");
static_assert(sizeof(MM_GachaManagerActor_ShowGachaAutoCount) == 0x000001, "Wrong size on MM_GachaManagerActor_ShowGachaAutoCount");
static_assert(offsetof(MM_GachaManagerActor_ShowGachaAutoCount, bAutoMode) == 0x000000, "Member 'MM_GachaManagerActor_ShowGachaAutoCount::bAutoMode' has a wrong offset!");

// Function MirMobile.MM_GachaManagerActor.ShowSkipButton
// 0x0001 (0x0001 - 0x0000)
struct MM_GachaManagerActor_ShowSkipButton final
{
public:
	EGachaSkipButtonType                          SkipType;                                          // 0x0000(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(MM_GachaManagerActor_ShowSkipButton) == 0x000001, "Wrong alignment on MM_GachaManagerActor_ShowSkipButton");
static_assert(sizeof(MM_GachaManagerActor_ShowSkipButton) == 0x000001, "Wrong size on MM_GachaManagerActor_ShowSkipButton");
static_assert(offsetof(MM_GachaManagerActor_ShowSkipButton, SkipType) == 0x000000, "Member 'MM_GachaManagerActor_ShowSkipButton::SkipType' has a wrong offset!");

// Function MirMobile.MM_GachaManagerActor.UpdateGachaAutoCount
// 0x0010 (0x0010 - 0x0000)
struct MM_GachaManagerActor_UpdateGachaAutoCount final
{
public:
	class FString                                 AutoCount;                                         // 0x0000(0x0010)(Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(MM_GachaManagerActor_UpdateGachaAutoCount) == 0x000008, "Wrong alignment on MM_GachaManagerActor_UpdateGachaAutoCount");
static_assert(sizeof(MM_GachaManagerActor_UpdateGachaAutoCount) == 0x000010, "Wrong size on MM_GachaManagerActor_UpdateGachaAutoCount");
static_assert(offsetof(MM_GachaManagerActor_UpdateGachaAutoCount, AutoCount) == 0x000000, "Member 'MM_GachaManagerActor_UpdateGachaAutoCount::AutoCount' has a wrong offset!");

// Function MirMobile.MM_PopupGuildSearchSlot.OnClickCheckBox
// 0x0001 (0x0001 - 0x0000)
struct MM_PopupGuildSearchSlot_OnClickCheckBox final
{
public:
	bool                                          Checked_;                                          // 0x0000(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(MM_PopupGuildSearchSlot_OnClickCheckBox) == 0x000001, "Wrong alignment on MM_PopupGuildSearchSlot_OnClickCheckBox");
static_assert(sizeof(MM_PopupGuildSearchSlot_OnClickCheckBox) == 0x000001, "Wrong size on MM_PopupGuildSearchSlot_OnClickCheckBox");
static_assert(offsetof(MM_PopupGuildSearchSlot_OnClickCheckBox, Checked_) == 0x000000, "Member 'MM_PopupGuildSearchSlot_OnClickCheckBox::Checked_' has a wrong offset!");

// Function MirMobile.ContentsLightManager.SetCustomizeSceneEffect
// 0x0020 (0x0020 - 0x0000)
struct ContentsLightManager_SetCustomizeSceneEffect final
{
public:
	class ADirectionalLight*                      PDirectional;                                      // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class APointLight*                            PPoint1;                                           // 0x0008(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class APointLight*                            PPoint2;                                           // 0x0010(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class AMM_PostProcessVolume*                  PPostProcess;                                      // 0x0018(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(ContentsLightManager_SetCustomizeSceneEffect) == 0x000008, "Wrong alignment on ContentsLightManager_SetCustomizeSceneEffect");
static_assert(sizeof(ContentsLightManager_SetCustomizeSceneEffect) == 0x000020, "Wrong size on ContentsLightManager_SetCustomizeSceneEffect");
static_assert(offsetof(ContentsLightManager_SetCustomizeSceneEffect, PDirectional) == 0x000000, "Member 'ContentsLightManager_SetCustomizeSceneEffect::PDirectional' has a wrong offset!");
static_assert(offsetof(ContentsLightManager_SetCustomizeSceneEffect, PPoint1) == 0x000008, "Member 'ContentsLightManager_SetCustomizeSceneEffect::PPoint1' has a wrong offset!");
static_assert(offsetof(ContentsLightManager_SetCustomizeSceneEffect, PPoint2) == 0x000010, "Member 'ContentsLightManager_SetCustomizeSceneEffect::PPoint2' has a wrong offset!");
static_assert(offsetof(ContentsLightManager_SetCustomizeSceneEffect, PPostProcess) == 0x000018, "Member 'ContentsLightManager_SetCustomizeSceneEffect::PPostProcess' has a wrong offset!");

// Function MirMobile.ContentsLightManager.SetCustomizingLight
// 0x0018 (0x0018 - 0x0000)
struct ContentsLightManager_SetCustomizingLight final
{
public:
	class ADirectionalLight*                      PDirectional;                                      // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class APointLight*                            PPoint1;                                           // 0x0008(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class APointLight*                            PPoint2;                                           // 0x0010(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(ContentsLightManager_SetCustomizingLight) == 0x000008, "Wrong alignment on ContentsLightManager_SetCustomizingLight");
static_assert(sizeof(ContentsLightManager_SetCustomizingLight) == 0x000018, "Wrong size on ContentsLightManager_SetCustomizingLight");
static_assert(offsetof(ContentsLightManager_SetCustomizingLight, PDirectional) == 0x000000, "Member 'ContentsLightManager_SetCustomizingLight::PDirectional' has a wrong offset!");
static_assert(offsetof(ContentsLightManager_SetCustomizingLight, PPoint1) == 0x000008, "Member 'ContentsLightManager_SetCustomizingLight::PPoint1' has a wrong offset!");
static_assert(offsetof(ContentsLightManager_SetCustomizingLight, PPoint2) == 0x000010, "Member 'ContentsLightManager_SetCustomizingLight::PPoint2' has a wrong offset!");

// Function MirMobile.CustomLoginSubSystem.AuthSignInWithCredentialComplete
// 0x0020 (0x0020 - 0x0000)
struct CustomLoginSubSystem_AuthSignInWithCredentialComplete final
{
public:
	class UFirebaseUser*                          FirebaseUser;                                      // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         ErrorCode;                                         // 0x0008(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_C[0x4];                                        // 0x000C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class FString                                 ErrorMessage;                                      // 0x0010(0x0010)(Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(CustomLoginSubSystem_AuthSignInWithCredentialComplete) == 0x000008, "Wrong alignment on CustomLoginSubSystem_AuthSignInWithCredentialComplete");
static_assert(sizeof(CustomLoginSubSystem_AuthSignInWithCredentialComplete) == 0x000020, "Wrong size on CustomLoginSubSystem_AuthSignInWithCredentialComplete");
static_assert(offsetof(CustomLoginSubSystem_AuthSignInWithCredentialComplete, FirebaseUser) == 0x000000, "Member 'CustomLoginSubSystem_AuthSignInWithCredentialComplete::FirebaseUser' has a wrong offset!");
static_assert(offsetof(CustomLoginSubSystem_AuthSignInWithCredentialComplete, ErrorCode) == 0x000008, "Member 'CustomLoginSubSystem_AuthSignInWithCredentialComplete::ErrorCode' has a wrong offset!");
static_assert(offsetof(CustomLoginSubSystem_AuthSignInWithCredentialComplete, ErrorMessage) == 0x000010, "Member 'CustomLoginSubSystem_AuthSignInWithCredentialComplete::ErrorMessage' has a wrong offset!");

// Function MirMobile.CustomLoginSubSystem.GetFirebaseUserTokenComplete
// 0x0028 (0x0028 - 0x0000)
struct CustomLoginSubSystem_GetFirebaseUserTokenComplete final
{
public:
	class FString                                 TokenID;                                           // 0x0000(0x0010)(Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         ErrorCode;                                         // 0x0010(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_14[0x4];                                       // 0x0014(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class FString                                 ErrorMessage;                                      // 0x0018(0x0010)(Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(CustomLoginSubSystem_GetFirebaseUserTokenComplete) == 0x000008, "Wrong alignment on CustomLoginSubSystem_GetFirebaseUserTokenComplete");
static_assert(sizeof(CustomLoginSubSystem_GetFirebaseUserTokenComplete) == 0x000028, "Wrong size on CustomLoginSubSystem_GetFirebaseUserTokenComplete");
static_assert(offsetof(CustomLoginSubSystem_GetFirebaseUserTokenComplete, TokenID) == 0x000000, "Member 'CustomLoginSubSystem_GetFirebaseUserTokenComplete::TokenID' has a wrong offset!");
static_assert(offsetof(CustomLoginSubSystem_GetFirebaseUserTokenComplete, ErrorCode) == 0x000010, "Member 'CustomLoginSubSystem_GetFirebaseUserTokenComplete::ErrorCode' has a wrong offset!");
static_assert(offsetof(CustomLoginSubSystem_GetFirebaseUserTokenComplete, ErrorMessage) == 0x000018, "Member 'CustomLoginSubSystem_GetFirebaseUserTokenComplete::ErrorMessage' has a wrong offset!");

// Function MirMobile.MM_GuildSupply.OnClickGuildGiftInventoryTab
// 0x0004 (0x0004 - 0x0000)
struct MM_GuildSupply_OnClickGuildGiftInventoryTab final
{
public:
	int32                                         Tab_index_;                                        // 0x0000(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(MM_GuildSupply_OnClickGuildGiftInventoryTab) == 0x000004, "Wrong alignment on MM_GuildSupply_OnClickGuildGiftInventoryTab");
static_assert(sizeof(MM_GuildSupply_OnClickGuildGiftInventoryTab) == 0x000004, "Wrong size on MM_GuildSupply_OnClickGuildGiftInventoryTab");
static_assert(offsetof(MM_GuildSupply_OnClickGuildGiftInventoryTab, Tab_index_) == 0x000000, "Member 'MM_GuildSupply_OnClickGuildGiftInventoryTab::Tab_index_' has a wrong offset!");

// Function MirMobile.MM_GuildSupply.OnClickTab
// 0x0008 (0x0008 - 0x0000)
struct MM_GuildSupply_OnClickTab final
{
public:
	int32                                         Index_;                                            // 0x0000(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bLocked;                                           // 0x0004(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_5[0x3];                                        // 0x0005(0x0003)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(MM_GuildSupply_OnClickTab) == 0x000004, "Wrong alignment on MM_GuildSupply_OnClickTab");
static_assert(sizeof(MM_GuildSupply_OnClickTab) == 0x000008, "Wrong size on MM_GuildSupply_OnClickTab");
static_assert(offsetof(MM_GuildSupply_OnClickTab, Index_) == 0x000000, "Member 'MM_GuildSupply_OnClickTab::Index_' has a wrong offset!");
static_assert(offsetof(MM_GuildSupply_OnClickTab, bLocked) == 0x000004, "Member 'MM_GuildSupply_OnClickTab::bLocked' has a wrong offset!");

// Function MirMobile.MM_GuildPeruse.OnClickAll
// 0x0001 (0x0001 - 0x0000)
struct MM_GuildPeruse_OnClickAll final
{
public:
	bool                                          Checked_;                                          // 0x0000(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(MM_GuildPeruse_OnClickAll) == 0x000001, "Wrong alignment on MM_GuildPeruse_OnClickAll");
static_assert(sizeof(MM_GuildPeruse_OnClickAll) == 0x000001, "Wrong size on MM_GuildPeruse_OnClickAll");
static_assert(offsetof(MM_GuildPeruse_OnClickAll, Checked_) == 0x000000, "Member 'MM_GuildPeruse_OnClickAll::Checked_' has a wrong offset!");

// Function MirMobile.MM_GuildPeruse.OnClickInvited
// 0x0001 (0x0001 - 0x0000)
struct MM_GuildPeruse_OnClickInvited final
{
public:
	bool                                          Checked_;                                          // 0x0000(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(MM_GuildPeruse_OnClickInvited) == 0x000001, "Wrong alignment on MM_GuildPeruse_OnClickInvited");
static_assert(sizeof(MM_GuildPeruse_OnClickInvited) == 0x000001, "Wrong size on MM_GuildPeruse_OnClickInvited");
static_assert(offsetof(MM_GuildPeruse_OnClickInvited, Checked_) == 0x000000, "Member 'MM_GuildPeruse_OnClickInvited::Checked_' has a wrong offset!");

// Function MirMobile.MM_GuildPeruse.OnClickRecommend
// 0x0001 (0x0001 - 0x0000)
struct MM_GuildPeruse_OnClickRecommend final
{
public:
	bool                                          Checked_;                                          // 0x0000(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(MM_GuildPeruse_OnClickRecommend) == 0x000001, "Wrong alignment on MM_GuildPeruse_OnClickRecommend");
static_assert(sizeof(MM_GuildPeruse_OnClickRecommend) == 0x000001, "Wrong size on MM_GuildPeruse_OnClickRecommend");
static_assert(offsetof(MM_GuildPeruse_OnClickRecommend, Checked_) == 0x000000, "Member 'MM_GuildPeruse_OnClickRecommend::Checked_' has a wrong offset!");

// Function MirMobile.MM_GuildPeruse.OnClickRequest
// 0x0001 (0x0001 - 0x0000)
struct MM_GuildPeruse_OnClickRequest final
{
public:
	bool                                          Checked_;                                          // 0x0000(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(MM_GuildPeruse_OnClickRequest) == 0x000001, "Wrong alignment on MM_GuildPeruse_OnClickRequest");
static_assert(sizeof(MM_GuildPeruse_OnClickRequest) == 0x000001, "Wrong size on MM_GuildPeruse_OnClickRequest");
static_assert(offsetof(MM_GuildPeruse_OnClickRequest, Checked_) == 0x000000, "Member 'MM_GuildPeruse_OnClickRequest::Checked_' has a wrong offset!");

// Function MirMobile.DirectingTrigger.PlayLevelSequenceEvent
// 0x0008 (0x0008 - 0x0000)
struct DirectingTrigger_PlayLevelSequenceEvent final
{
public:
	class ULevelSequence*                         PLevelSequenceAsset;                               // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(DirectingTrigger_PlayLevelSequenceEvent) == 0x000008, "Wrong alignment on DirectingTrigger_PlayLevelSequenceEvent");
static_assert(sizeof(DirectingTrigger_PlayLevelSequenceEvent) == 0x000008, "Wrong size on DirectingTrigger_PlayLevelSequenceEvent");
static_assert(offsetof(DirectingTrigger_PlayLevelSequenceEvent, PLevelSequenceAsset) == 0x000000, "Member 'DirectingTrigger_PlayLevelSequenceEvent::PLevelSequenceAsset' has a wrong offset!");

// Function MirMobile.MM_B_Hud.OnClickQuickTabSymbol
// 0x0004 (0x0004 - 0x0000)
struct MM_B_Hud_OnClickQuickTabSymbol final
{
public:
	int32                                         Index_0;                                           // 0x0000(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(MM_B_Hud_OnClickQuickTabSymbol) == 0x000004, "Wrong alignment on MM_B_Hud_OnClickQuickTabSymbol");
static_assert(sizeof(MM_B_Hud_OnClickQuickTabSymbol) == 0x000004, "Wrong size on MM_B_Hud_OnClickQuickTabSymbol");
static_assert(offsetof(MM_B_Hud_OnClickQuickTabSymbol, Index_0) == 0x000000, "Member 'MM_B_Hud_OnClickQuickTabSymbol::Index_0' has a wrong offset!");

// Function MirMobile.EffectShowTrigger.GetEffectSystem
// 0x0018 (0x0018 - 0x0000)
struct EffectShowTrigger_GetEffectSystem final
{
public:
	class FString                                 StrPath;                                           // 0x0000(0x0010)(Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UObject*                                ReturnValue;                                       // 0x0010(0x0008)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(EffectShowTrigger_GetEffectSystem) == 0x000008, "Wrong alignment on EffectShowTrigger_GetEffectSystem");
static_assert(sizeof(EffectShowTrigger_GetEffectSystem) == 0x000018, "Wrong size on EffectShowTrigger_GetEffectSystem");
static_assert(offsetof(EffectShowTrigger_GetEffectSystem, StrPath) == 0x000000, "Member 'EffectShowTrigger_GetEffectSystem::StrPath' has a wrong offset!");
static_assert(offsetof(EffectShowTrigger_GetEffectSystem, ReturnValue) == 0x000010, "Member 'EffectShowTrigger_GetEffectSystem::ReturnValue' has a wrong offset!");

// Function MirMobile.EffectShowTrigger.ShowEffectComponent
// 0x0001 (0x0001 - 0x0000)
struct EffectShowTrigger_ShowEffectComponent final
{
public:
	bool                                          bShow;                                             // 0x0000(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(EffectShowTrigger_ShowEffectComponent) == 0x000001, "Wrong alignment on EffectShowTrigger_ShowEffectComponent");
static_assert(sizeof(EffectShowTrigger_ShowEffectComponent) == 0x000001, "Wrong size on EffectShowTrigger_ShowEffectComponent");
static_assert(offsetof(EffectShowTrigger_ShowEffectComponent, bShow) == 0x000000, "Member 'EffectShowTrigger_ShowEffectComponent::bShow' has a wrong offset!");

// Function MirMobile.EffectShowTrigger.SpawnEffectComponent
// 0x0008 (0x0008 - 0x0000)
struct EffectShowTrigger_SpawnEffectComponent final
{
public:
	class UObject*                                PEffectObject;                                     // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(EffectShowTrigger_SpawnEffectComponent) == 0x000008, "Wrong alignment on EffectShowTrigger_SpawnEffectComponent");
static_assert(sizeof(EffectShowTrigger_SpawnEffectComponent) == 0x000008, "Wrong size on EffectShowTrigger_SpawnEffectComponent");
static_assert(offsetof(EffectShowTrigger_SpawnEffectComponent, PEffectObject) == 0x000000, "Member 'EffectShowTrigger_SpawnEffectComponent::PEffectObject' has a wrong offset!");

// Function MirMobile.FacebookLoginSubSystem.AuthSignInWithCredentialComplete
// 0x0020 (0x0020 - 0x0000)
struct FacebookLoginSubSystem_AuthSignInWithCredentialComplete final
{
public:
	class UFirebaseUser*                          FirebaseUser;                                      // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         ErrorCode;                                         // 0x0008(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_C[0x4];                                        // 0x000C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class FString                                 ErrorMessage;                                      // 0x0010(0x0010)(Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FacebookLoginSubSystem_AuthSignInWithCredentialComplete) == 0x000008, "Wrong alignment on FacebookLoginSubSystem_AuthSignInWithCredentialComplete");
static_assert(sizeof(FacebookLoginSubSystem_AuthSignInWithCredentialComplete) == 0x000020, "Wrong size on FacebookLoginSubSystem_AuthSignInWithCredentialComplete");
static_assert(offsetof(FacebookLoginSubSystem_AuthSignInWithCredentialComplete, FirebaseUser) == 0x000000, "Member 'FacebookLoginSubSystem_AuthSignInWithCredentialComplete::FirebaseUser' has a wrong offset!");
static_assert(offsetof(FacebookLoginSubSystem_AuthSignInWithCredentialComplete, ErrorCode) == 0x000008, "Member 'FacebookLoginSubSystem_AuthSignInWithCredentialComplete::ErrorCode' has a wrong offset!");
static_assert(offsetof(FacebookLoginSubSystem_AuthSignInWithCredentialComplete, ErrorMessage) == 0x000010, "Member 'FacebookLoginSubSystem_AuthSignInWithCredentialComplete::ErrorMessage' has a wrong offset!");

// Function MirMobile.FacebookLoginSubSystem.RequestFacebookCredentialComplete
// 0x0010 (0x0010 - 0x0000)
struct FacebookLoginSubSystem_RequestFacebookCredentialComplete final
{
public:
	bool                                          IsSuccess;                                         // 0x0000(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1[0x7];                                        // 0x0001(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	class UFirebaseCredential*                    Credential;                                        // 0x0008(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FacebookLoginSubSystem_RequestFacebookCredentialComplete) == 0x000008, "Wrong alignment on FacebookLoginSubSystem_RequestFacebookCredentialComplete");
static_assert(sizeof(FacebookLoginSubSystem_RequestFacebookCredentialComplete) == 0x000010, "Wrong size on FacebookLoginSubSystem_RequestFacebookCredentialComplete");
static_assert(offsetof(FacebookLoginSubSystem_RequestFacebookCredentialComplete, IsSuccess) == 0x000000, "Member 'FacebookLoginSubSystem_RequestFacebookCredentialComplete::IsSuccess' has a wrong offset!");
static_assert(offsetof(FacebookLoginSubSystem_RequestFacebookCredentialComplete, Credential) == 0x000008, "Member 'FacebookLoginSubSystem_RequestFacebookCredentialComplete::Credential' has a wrong offset!");

// Function MirMobile.MM_Popup_Addressbook.OnCheckBoxAllSelect
// 0x0001 (0x0001 - 0x0000)
struct MM_Popup_Addressbook_OnCheckBoxAllSelect final
{
public:
	bool                                          bChecked;                                          // 0x0000(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(MM_Popup_Addressbook_OnCheckBoxAllSelect) == 0x000001, "Wrong alignment on MM_Popup_Addressbook_OnCheckBoxAllSelect");
static_assert(sizeof(MM_Popup_Addressbook_OnCheckBoxAllSelect) == 0x000001, "Wrong size on MM_Popup_Addressbook_OnCheckBoxAllSelect");
static_assert(offsetof(MM_Popup_Addressbook_OnCheckBoxAllSelect, bChecked) == 0x000000, "Member 'MM_Popup_Addressbook_OnCheckBoxAllSelect::bChecked' has a wrong offset!");

// Function MirMobile.MM_Popup_Addressbook.OnTextCommitted
// 0x0020 (0x0020 - 0x0000)
struct MM_Popup_Addressbook_OnTextCommitted final
{
public:
	class FText                                   Text_;                                             // 0x0000(0x0018)(ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
	ETextCommit                                   Commit_method_;                                    // 0x0018(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_19[0x7];                                       // 0x0019(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(MM_Popup_Addressbook_OnTextCommitted) == 0x000008, "Wrong alignment on MM_Popup_Addressbook_OnTextCommitted");
static_assert(sizeof(MM_Popup_Addressbook_OnTextCommitted) == 0x000020, "Wrong size on MM_Popup_Addressbook_OnTextCommitted");
static_assert(offsetof(MM_Popup_Addressbook_OnTextCommitted, Text_) == 0x000000, "Member 'MM_Popup_Addressbook_OnTextCommitted::Text_' has a wrong offset!");
static_assert(offsetof(MM_Popup_Addressbook_OnTextCommitted, Commit_method_) == 0x000018, "Member 'MM_Popup_Addressbook_OnTextCommitted::Commit_method_' has a wrong offset!");

// Function MirMobile.MM_Popup_PaintRegist.OnClickSlot
// 0x0008 (0x0008 - 0x0000)
struct MM_Popup_PaintRegist_OnClickSlot final
{
public:
	class UMM_UserEvent_Paint_Slot*               PSlot;                                             // 0x0000(0x0008)(Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(MM_Popup_PaintRegist_OnClickSlot) == 0x000008, "Wrong alignment on MM_Popup_PaintRegist_OnClickSlot");
static_assert(sizeof(MM_Popup_PaintRegist_OnClickSlot) == 0x000008, "Wrong size on MM_Popup_PaintRegist_OnClickSlot");
static_assert(offsetof(MM_Popup_PaintRegist_OnClickSlot, PSlot) == 0x000000, "Member 'MM_Popup_PaintRegist_OnClickSlot::PSlot' has a wrong offset!");

// Function MirMobile.MM_Popup_PaintRegist.OnClickSlotGive
// 0x0008 (0x0008 - 0x0000)
struct MM_Popup_PaintRegist_OnClickSlotGive final
{
public:
	class UMM_UserEvent_Paint_Slot*               PSlot;                                             // 0x0000(0x0008)(Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(MM_Popup_PaintRegist_OnClickSlotGive) == 0x000008, "Wrong alignment on MM_Popup_PaintRegist_OnClickSlotGive");
static_assert(sizeof(MM_Popup_PaintRegist_OnClickSlotGive) == 0x000008, "Wrong size on MM_Popup_PaintRegist_OnClickSlotGive");
static_assert(offsetof(MM_Popup_PaintRegist_OnClickSlotGive, PSlot) == 0x000000, "Member 'MM_Popup_PaintRegist_OnClickSlotGive::PSlot' has a wrong offset!");

// Function MirMobile.MM_Popup_PaintRegist.OnClickSlotTake
// 0x0008 (0x0008 - 0x0000)
struct MM_Popup_PaintRegist_OnClickSlotTake final
{
public:
	class UMM_UserEvent_Paint_Slot*               PSlot;                                             // 0x0000(0x0008)(Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(MM_Popup_PaintRegist_OnClickSlotTake) == 0x000008, "Wrong alignment on MM_Popup_PaintRegist_OnClickSlotTake");
static_assert(sizeof(MM_Popup_PaintRegist_OnClickSlotTake) == 0x000008, "Wrong size on MM_Popup_PaintRegist_OnClickSlotTake");
static_assert(offsetof(MM_Popup_PaintRegist_OnClickSlotTake, PSlot) == 0x000000, "Member 'MM_Popup_PaintRegist_OnClickSlotTake::PSlot' has a wrong offset!");

// Function MirMobile.MM_ClassPhase_SkillInfoSlot.OnClickSkillSlot
// 0x0008 (0x0008 - 0x0000)
struct MM_ClassPhase_SkillInfoSlot_OnClickSkillSlot final
{
public:
	int32                                         ISlotID;                                           // 0x0000(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         ISkillID;                                          // 0x0004(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(MM_ClassPhase_SkillInfoSlot_OnClickSkillSlot) == 0x000004, "Wrong alignment on MM_ClassPhase_SkillInfoSlot_OnClickSkillSlot");
static_assert(sizeof(MM_ClassPhase_SkillInfoSlot_OnClickSkillSlot) == 0x000008, "Wrong size on MM_ClassPhase_SkillInfoSlot_OnClickSkillSlot");
static_assert(offsetof(MM_ClassPhase_SkillInfoSlot_OnClickSkillSlot, ISlotID) == 0x000000, "Member 'MM_ClassPhase_SkillInfoSlot_OnClickSkillSlot::ISlotID' has a wrong offset!");
static_assert(offsetof(MM_ClassPhase_SkillInfoSlot_OnClickSkillSlot, ISkillID) == 0x000004, "Member 'MM_ClassPhase_SkillInfoSlot_OnClickSkillSlot::ISkillID' has a wrong offset!");

// Function MirMobile.MM_PopUp_GameOption.OnClickMainTab
// 0x0008 (0x0008 - 0x0000)
struct MM_PopUp_GameOption_OnClickMainTab final
{
public:
	int32                                         TabIndex;                                          // 0x0000(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bLocked;                                           // 0x0004(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_5[0x3];                                        // 0x0005(0x0003)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(MM_PopUp_GameOption_OnClickMainTab) == 0x000004, "Wrong alignment on MM_PopUp_GameOption_OnClickMainTab");
static_assert(sizeof(MM_PopUp_GameOption_OnClickMainTab) == 0x000008, "Wrong size on MM_PopUp_GameOption_OnClickMainTab");
static_assert(offsetof(MM_PopUp_GameOption_OnClickMainTab, TabIndex) == 0x000000, "Member 'MM_PopUp_GameOption_OnClickMainTab::TabIndex' has a wrong offset!");
static_assert(offsetof(MM_PopUp_GameOption_OnClickMainTab, bLocked) == 0x000004, "Member 'MM_PopUp_GameOption_OnClickMainTab::bLocked' has a wrong offset!");

// Function MirMobile.MM_PopUp_GameOption.OnLinkIDPComplete
// 0x0018 (0x0018 - 0x0000)
struct MM_PopUp_GameOption_OnLinkIDPComplete final
{
public:
	bool                                          Success;                                           // 0x0000(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1[0x7];                                        // 0x0001(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	class FString                                 Message;                                           // 0x0008(0x0010)(Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(MM_PopUp_GameOption_OnLinkIDPComplete) == 0x000008, "Wrong alignment on MM_PopUp_GameOption_OnLinkIDPComplete");
static_assert(sizeof(MM_PopUp_GameOption_OnLinkIDPComplete) == 0x000018, "Wrong size on MM_PopUp_GameOption_OnLinkIDPComplete");
static_assert(offsetof(MM_PopUp_GameOption_OnLinkIDPComplete, Success) == 0x000000, "Member 'MM_PopUp_GameOption_OnLinkIDPComplete::Success' has a wrong offset!");
static_assert(offsetof(MM_PopUp_GameOption_OnLinkIDPComplete, Message) == 0x000008, "Member 'MM_PopUp_GameOption_OnLinkIDPComplete::Message' has a wrong offset!");

// Function MirMobile.MM_CharSelState.SetCharacterSelectLevelData
// 0x0050 (0x0050 - 0x0000)
struct MM_CharSelState_SetCharacterSelectLevelData final
{
public:
	class ACameraActor*                           PMainCamera;                                       // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         CameraDefaultFOV;                                  // 0x0008(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                CameraDefaultLocation;                             // 0x000C(0x000C)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FRotator                               CameraDefaultRotation;                             // 0x0018(0x000C)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	struct FVector                                ModelingLocation;                                  // 0x0024(0x000C)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FRotator                               ModelingRotation;                                  // 0x0030(0x000C)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	uint8                                         Pad_3C[0x4];                                       // 0x003C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<class ACameraActor*>                   ZoomCameraActorArray;                              // 0x0040(0x0010)(Parm, ZeroConstructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(MM_CharSelState_SetCharacterSelectLevelData) == 0x000008, "Wrong alignment on MM_CharSelState_SetCharacterSelectLevelData");
static_assert(sizeof(MM_CharSelState_SetCharacterSelectLevelData) == 0x000050, "Wrong size on MM_CharSelState_SetCharacterSelectLevelData");
static_assert(offsetof(MM_CharSelState_SetCharacterSelectLevelData, PMainCamera) == 0x000000, "Member 'MM_CharSelState_SetCharacterSelectLevelData::PMainCamera' has a wrong offset!");
static_assert(offsetof(MM_CharSelState_SetCharacterSelectLevelData, CameraDefaultFOV) == 0x000008, "Member 'MM_CharSelState_SetCharacterSelectLevelData::CameraDefaultFOV' has a wrong offset!");
static_assert(offsetof(MM_CharSelState_SetCharacterSelectLevelData, CameraDefaultLocation) == 0x00000C, "Member 'MM_CharSelState_SetCharacterSelectLevelData::CameraDefaultLocation' has a wrong offset!");
static_assert(offsetof(MM_CharSelState_SetCharacterSelectLevelData, CameraDefaultRotation) == 0x000018, "Member 'MM_CharSelState_SetCharacterSelectLevelData::CameraDefaultRotation' has a wrong offset!");
static_assert(offsetof(MM_CharSelState_SetCharacterSelectLevelData, ModelingLocation) == 0x000024, "Member 'MM_CharSelState_SetCharacterSelectLevelData::ModelingLocation' has a wrong offset!");
static_assert(offsetof(MM_CharSelState_SetCharacterSelectLevelData, ModelingRotation) == 0x000030, "Member 'MM_CharSelState_SetCharacterSelectLevelData::ModelingRotation' has a wrong offset!");
static_assert(offsetof(MM_CharSelState_SetCharacterSelectLevelData, ZoomCameraActorArray) == 0x000040, "Member 'MM_CharSelState_SetCharacterSelectLevelData::ZoomCameraActorArray' has a wrong offset!");

// Function MirMobile.MM_CharSelState.ZoomScreen
// 0x0004 (0x0004 - 0x0000)
struct MM_CharSelState_ZoomScreen final
{
public:
	float                                         ZoomLength;                                        // 0x0000(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(MM_CharSelState_ZoomScreen) == 0x000004, "Wrong alignment on MM_CharSelState_ZoomScreen");
static_assert(sizeof(MM_CharSelState_ZoomScreen) == 0x000004, "Wrong size on MM_CharSelState_ZoomScreen");
static_assert(offsetof(MM_CharSelState_ZoomScreen, ZoomLength) == 0x000000, "Member 'MM_CharSelState_ZoomScreen::ZoomLength' has a wrong offset!");

// Function MirMobile.MM_B_Luxury.OnClickSubWeaponDisalbeSetting
// 0x0001 (0x0001 - 0x0000)
struct MM_B_Luxury_OnClickSubWeaponDisalbeSetting final
{
public:
	bool                                          Checked;                                           // 0x0000(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(MM_B_Luxury_OnClickSubWeaponDisalbeSetting) == 0x000001, "Wrong alignment on MM_B_Luxury_OnClickSubWeaponDisalbeSetting");
static_assert(sizeof(MM_B_Luxury_OnClickSubWeaponDisalbeSetting) == 0x000001, "Wrong size on MM_B_Luxury_OnClickSubWeaponDisalbeSetting");
static_assert(offsetof(MM_B_Luxury_OnClickSubWeaponDisalbeSetting, Checked) == 0x000000, "Member 'MM_B_Luxury_OnClickSubWeaponDisalbeSetting::Checked' has a wrong offset!");

// Function MirMobile.MM_AddOptionList.OnClickItemInfo
// 0x0008 (0x0008 - 0x0000)
struct MM_AddOptionList_OnClickItemInfo final
{
public:
	class UMM_Slot_Base*                          _Slot;                                             // 0x0000(0x0008)(Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(MM_AddOptionList_OnClickItemInfo) == 0x000008, "Wrong alignment on MM_AddOptionList_OnClickItemInfo");
static_assert(sizeof(MM_AddOptionList_OnClickItemInfo) == 0x000008, "Wrong size on MM_AddOptionList_OnClickItemInfo");
static_assert(offsetof(MM_AddOptionList_OnClickItemInfo, _Slot) == 0x000000, "Member 'MM_AddOptionList_OnClickItemInfo::_Slot' has a wrong offset!");

// Function MirMobile.GhostSkeletalMesh.SetGhostTrailData
// 0x0030 (0x0030 - 0x0000)
struct GhostSkeletalMesh_SetGhostTrailData final
{
public:
	struct FGhostTrailData                        GhostChar;                                         // 0x0000(0x0018)(Parm, NoDestructor, NativeAccessSpecifierPublic)
	struct FGhostTrailData                        GhostWpn;                                          // 0x0018(0x0018)(Parm, NoDestructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(GhostSkeletalMesh_SetGhostTrailData) == 0x000008, "Wrong alignment on GhostSkeletalMesh_SetGhostTrailData");
static_assert(sizeof(GhostSkeletalMesh_SetGhostTrailData) == 0x000030, "Wrong size on GhostSkeletalMesh_SetGhostTrailData");
static_assert(offsetof(GhostSkeletalMesh_SetGhostTrailData, GhostChar) == 0x000000, "Member 'GhostSkeletalMesh_SetGhostTrailData::GhostChar' has a wrong offset!");
static_assert(offsetof(GhostSkeletalMesh_SetGhostTrailData, GhostWpn) == 0x000018, "Member 'GhostSkeletalMesh_SetGhostTrailData::GhostWpn' has a wrong offset!");

// Function MirMobile.GoogleLoginSubSystem.AuthSignInWithCredentialComplete
// 0x0020 (0x0020 - 0x0000)
struct GoogleLoginSubSystem_AuthSignInWithCredentialComplete final
{
public:
	class UFirebaseUser*                          FirebaseUser;                                      // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         ErrorCode;                                         // 0x0008(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_C[0x4];                                        // 0x000C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class FString                                 ErrorMessage;                                      // 0x0010(0x0010)(Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(GoogleLoginSubSystem_AuthSignInWithCredentialComplete) == 0x000008, "Wrong alignment on GoogleLoginSubSystem_AuthSignInWithCredentialComplete");
static_assert(sizeof(GoogleLoginSubSystem_AuthSignInWithCredentialComplete) == 0x000020, "Wrong size on GoogleLoginSubSystem_AuthSignInWithCredentialComplete");
static_assert(offsetof(GoogleLoginSubSystem_AuthSignInWithCredentialComplete, FirebaseUser) == 0x000000, "Member 'GoogleLoginSubSystem_AuthSignInWithCredentialComplete::FirebaseUser' has a wrong offset!");
static_assert(offsetof(GoogleLoginSubSystem_AuthSignInWithCredentialComplete, ErrorCode) == 0x000008, "Member 'GoogleLoginSubSystem_AuthSignInWithCredentialComplete::ErrorCode' has a wrong offset!");
static_assert(offsetof(GoogleLoginSubSystem_AuthSignInWithCredentialComplete, ErrorMessage) == 0x000010, "Member 'GoogleLoginSubSystem_AuthSignInWithCredentialComplete::ErrorMessage' has a wrong offset!");

// Function MirMobile.GoogleLoginSubSystem.RequestGoogleCredentialComplete
// 0x0010 (0x0010 - 0x0000)
struct GoogleLoginSubSystem_RequestGoogleCredentialComplete final
{
public:
	bool                                          IsSuccess;                                         // 0x0000(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1[0x7];                                        // 0x0001(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	class UFirebaseCredential*                    Credential;                                        // 0x0008(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(GoogleLoginSubSystem_RequestGoogleCredentialComplete) == 0x000008, "Wrong alignment on GoogleLoginSubSystem_RequestGoogleCredentialComplete");
static_assert(sizeof(GoogleLoginSubSystem_RequestGoogleCredentialComplete) == 0x000010, "Wrong size on GoogleLoginSubSystem_RequestGoogleCredentialComplete");
static_assert(offsetof(GoogleLoginSubSystem_RequestGoogleCredentialComplete, IsSuccess) == 0x000000, "Member 'GoogleLoginSubSystem_RequestGoogleCredentialComplete::IsSuccess' has a wrong offset!");
static_assert(offsetof(GoogleLoginSubSystem_RequestGoogleCredentialComplete, Credential) == 0x000008, "Member 'GoogleLoginSubSystem_RequestGoogleCredentialComplete::Credential' has a wrong offset!");

// Function MirMobile.MM_Auction_Tab_Search_Enchant.Bind_ClickDelegate
// 0x0010 (0x0010 - 0x0000)
struct MM_Auction_Tab_Search_Enchant_Bind_ClickDelegate final
{
public:
	class UObject*                                PObj;                                              // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   FunctionName;                                      // 0x0008(0x0008)(ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(MM_Auction_Tab_Search_Enchant_Bind_ClickDelegate) == 0x000008, "Wrong alignment on MM_Auction_Tab_Search_Enchant_Bind_ClickDelegate");
static_assert(sizeof(MM_Auction_Tab_Search_Enchant_Bind_ClickDelegate) == 0x000010, "Wrong size on MM_Auction_Tab_Search_Enchant_Bind_ClickDelegate");
static_assert(offsetof(MM_Auction_Tab_Search_Enchant_Bind_ClickDelegate, PObj) == 0x000000, "Member 'MM_Auction_Tab_Search_Enchant_Bind_ClickDelegate::PObj' has a wrong offset!");
static_assert(offsetof(MM_Auction_Tab_Search_Enchant_Bind_ClickDelegate, FunctionName) == 0x000008, "Member 'MM_Auction_Tab_Search_Enchant_Bind_ClickDelegate::FunctionName' has a wrong offset!");

// Function MirMobile.MM_Auction_Tab_Search_Enchant.Bind_ClickSlotDelegate
// 0x0010 (0x0010 - 0x0000)
struct MM_Auction_Tab_Search_Enchant_Bind_ClickSlotDelegate final
{
public:
	class UObject*                                PObj;                                              // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   FunctionName;                                      // 0x0008(0x0008)(ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(MM_Auction_Tab_Search_Enchant_Bind_ClickSlotDelegate) == 0x000008, "Wrong alignment on MM_Auction_Tab_Search_Enchant_Bind_ClickSlotDelegate");
static_assert(sizeof(MM_Auction_Tab_Search_Enchant_Bind_ClickSlotDelegate) == 0x000010, "Wrong size on MM_Auction_Tab_Search_Enchant_Bind_ClickSlotDelegate");
static_assert(offsetof(MM_Auction_Tab_Search_Enchant_Bind_ClickSlotDelegate, PObj) == 0x000000, "Member 'MM_Auction_Tab_Search_Enchant_Bind_ClickSlotDelegate::PObj' has a wrong offset!");
static_assert(offsetof(MM_Auction_Tab_Search_Enchant_Bind_ClickSlotDelegate, FunctionName) == 0x000008, "Member 'MM_Auction_Tab_Search_Enchant_Bind_ClickSlotDelegate::FunctionName' has a wrong offset!");

// Function MirMobile.MM_Auction_Tab_Search_Enchant.OnClickComboList
// 0x0004 (0x0004 - 0x0000)
struct MM_Auction_Tab_Search_Enchant_OnClickComboList final
{
public:
	int32                                         IIndex;                                            // 0x0000(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(MM_Auction_Tab_Search_Enchant_OnClickComboList) == 0x000004, "Wrong alignment on MM_Auction_Tab_Search_Enchant_OnClickComboList");
static_assert(sizeof(MM_Auction_Tab_Search_Enchant_OnClickComboList) == 0x000004, "Wrong size on MM_Auction_Tab_Search_Enchant_OnClickComboList");
static_assert(offsetof(MM_Auction_Tab_Search_Enchant_OnClickComboList, IIndex) == 0x000000, "Member 'MM_Auction_Tab_Search_Enchant_OnClickComboList::IIndex' has a wrong offset!");

// Function MirMobile.MM_Auction_Tab_Search_Enchant.OnClickSlotMax
// 0x0008 (0x0008 - 0x0000)
struct MM_Auction_Tab_Search_Enchant_OnClickSlotMax final
{
public:
	int32                                         IIndex;                                            // 0x0000(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bSlotUpdate;                                       // 0x0004(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_5[0x3];                                        // 0x0005(0x0003)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(MM_Auction_Tab_Search_Enchant_OnClickSlotMax) == 0x000004, "Wrong alignment on MM_Auction_Tab_Search_Enchant_OnClickSlotMax");
static_assert(sizeof(MM_Auction_Tab_Search_Enchant_OnClickSlotMax) == 0x000008, "Wrong size on MM_Auction_Tab_Search_Enchant_OnClickSlotMax");
static_assert(offsetof(MM_Auction_Tab_Search_Enchant_OnClickSlotMax, IIndex) == 0x000000, "Member 'MM_Auction_Tab_Search_Enchant_OnClickSlotMax::IIndex' has a wrong offset!");
static_assert(offsetof(MM_Auction_Tab_Search_Enchant_OnClickSlotMax, bSlotUpdate) == 0x000004, "Member 'MM_Auction_Tab_Search_Enchant_OnClickSlotMax::bSlotUpdate' has a wrong offset!");

// Function MirMobile.MM_Auction_Tab_Search_Enchant.OnClickSlotMin
// 0x0008 (0x0008 - 0x0000)
struct MM_Auction_Tab_Search_Enchant_OnClickSlotMin final
{
public:
	int32                                         IIndex;                                            // 0x0000(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bSlotUpdate;                                       // 0x0004(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_5[0x3];                                        // 0x0005(0x0003)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(MM_Auction_Tab_Search_Enchant_OnClickSlotMin) == 0x000004, "Wrong alignment on MM_Auction_Tab_Search_Enchant_OnClickSlotMin");
static_assert(sizeof(MM_Auction_Tab_Search_Enchant_OnClickSlotMin) == 0x000008, "Wrong size on MM_Auction_Tab_Search_Enchant_OnClickSlotMin");
static_assert(offsetof(MM_Auction_Tab_Search_Enchant_OnClickSlotMin, IIndex) == 0x000000, "Member 'MM_Auction_Tab_Search_Enchant_OnClickSlotMin::IIndex' has a wrong offset!");
static_assert(offsetof(MM_Auction_Tab_Search_Enchant_OnClickSlotMin, bSlotUpdate) == 0x000004, "Member 'MM_Auction_Tab_Search_Enchant_OnClickSlotMin::bSlotUpdate' has a wrong offset!");

// Function MirMobile.MM_Auction_Slot_Normal.OnClickItemSlot
// 0x0008 (0x0008 - 0x0000)
struct MM_Auction_Slot_Normal_OnClickItemSlot final
{
public:
	class UMM_Slot_Base*                          PSlotBase;                                         // 0x0000(0x0008)(Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(MM_Auction_Slot_Normal_OnClickItemSlot) == 0x000008, "Wrong alignment on MM_Auction_Slot_Normal_OnClickItemSlot");
static_assert(sizeof(MM_Auction_Slot_Normal_OnClickItemSlot) == 0x000008, "Wrong size on MM_Auction_Slot_Normal_OnClickItemSlot");
static_assert(offsetof(MM_Auction_Slot_Normal_OnClickItemSlot, PSlotBase) == 0x000000, "Member 'MM_Auction_Slot_Normal_OnClickItemSlot::PSlotBase' has a wrong offset!");

// Function MirMobile.MM_FSMComponent.ChangeFSM
// 0x000C (0x000C - 0x0000)
struct MM_FSMComponent_ChangeFSM final
{
public:
	EFSM_TYPE                                     FSMType;                                           // 0x0000(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          IsForce;                                           // 0x0001(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2[0x2];                                        // 0x0002(0x0002)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         Param01;                                           // 0x0004(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         Param02;                                           // 0x0008(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(MM_FSMComponent_ChangeFSM) == 0x000004, "Wrong alignment on MM_FSMComponent_ChangeFSM");
static_assert(sizeof(MM_FSMComponent_ChangeFSM) == 0x00000C, "Wrong size on MM_FSMComponent_ChangeFSM");
static_assert(offsetof(MM_FSMComponent_ChangeFSM, FSMType) == 0x000000, "Member 'MM_FSMComponent_ChangeFSM::FSMType' has a wrong offset!");
static_assert(offsetof(MM_FSMComponent_ChangeFSM, IsForce) == 0x000001, "Member 'MM_FSMComponent_ChangeFSM::IsForce' has a wrong offset!");
static_assert(offsetof(MM_FSMComponent_ChangeFSM, Param01) == 0x000004, "Member 'MM_FSMComponent_ChangeFSM::Param01' has a wrong offset!");
static_assert(offsetof(MM_FSMComponent_ChangeFSM, Param02) == 0x000008, "Member 'MM_FSMComponent_ChangeFSM::Param02' has a wrong offset!");

// Function MirMobile.MM_FSMComponent.OnEvent
// 0x0008 (0x0008 - 0x0000)
struct MM_FSMComponent_OnEvent final
{
public:
	EFSM_TYPE                                     EventType;                                         // 0x0000(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1[0x3];                                        // 0x0001(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         EventValue;                                        // 0x0004(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(MM_FSMComponent_OnEvent) == 0x000004, "Wrong alignment on MM_FSMComponent_OnEvent");
static_assert(sizeof(MM_FSMComponent_OnEvent) == 0x000008, "Wrong size on MM_FSMComponent_OnEvent");
static_assert(offsetof(MM_FSMComponent_OnEvent, EventType) == 0x000000, "Member 'MM_FSMComponent_OnEvent::EventType' has a wrong offset!");
static_assert(offsetof(MM_FSMComponent_OnEvent, EventValue) == 0x000004, "Member 'MM_FSMComponent_OnEvent::EventValue' has a wrong offset!");

// Function MirMobile.MM_FSMComponent.OnHit
// 0x0010 (0x0010 - 0x0000)
struct MM_FSMComponent_OnHit final
{
public:
	int64                                         AttackerUID;                                       // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         AttackID;                                          // 0x0008(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         Damage;                                            // 0x000C(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(MM_FSMComponent_OnHit) == 0x000008, "Wrong alignment on MM_FSMComponent_OnHit");
static_assert(sizeof(MM_FSMComponent_OnHit) == 0x000010, "Wrong size on MM_FSMComponent_OnHit");
static_assert(offsetof(MM_FSMComponent_OnHit, AttackerUID) == 0x000000, "Member 'MM_FSMComponent_OnHit::AttackerUID' has a wrong offset!");
static_assert(offsetof(MM_FSMComponent_OnHit, AttackID) == 0x000008, "Member 'MM_FSMComponent_OnHit::AttackID' has a wrong offset!");
static_assert(offsetof(MM_FSMComponent_OnHit, Damage) == 0x00000C, "Member 'MM_FSMComponent_OnHit::Damage' has a wrong offset!");

// Function MirMobile.MM_GameModeBase.GetCurGameState
// 0x0008 (0x0008 - 0x0000)
struct MM_GameModeBase_GetCurGameState final
{
public:
	class AMM_GameStateBase*                      ReturnValue;                                       // 0x0000(0x0008)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(MM_GameModeBase_GetCurGameState) == 0x000008, "Wrong alignment on MM_GameModeBase_GetCurGameState");
static_assert(sizeof(MM_GameModeBase_GetCurGameState) == 0x000008, "Wrong size on MM_GameModeBase_GetCurGameState");
static_assert(offsetof(MM_GameModeBase_GetCurGameState, ReturnValue) == 0x000000, "Member 'MM_GameModeBase_GetCurGameState::ReturnValue' has a wrong offset!");

// Function MirMobile.MM_GameModeBase.OnFinishDirectingEvent
// 0x0001 (0x0001 - 0x0000)
struct MM_GameModeBase_OnFinishDirectingEvent final
{
public:
	bool                                          bHudOpen;                                          // 0x0000(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(MM_GameModeBase_OnFinishDirectingEvent) == 0x000001, "Wrong alignment on MM_GameModeBase_OnFinishDirectingEvent");
static_assert(sizeof(MM_GameModeBase_OnFinishDirectingEvent) == 0x000001, "Wrong size on MM_GameModeBase_OnFinishDirectingEvent");
static_assert(offsetof(MM_GameModeBase_OnFinishDirectingEvent, bHudOpen) == 0x000000, "Member 'MM_GameModeBase_OnFinishDirectingEvent::bHudOpen' has a wrong offset!");

// Function MirMobile.MM_GameModeBase.UpdatePortrait
// 0x0002 (0x0002 - 0x0000)
struct MM_GameModeBase_UpdatePortrait final
{
public:
	bool                                          bDelayCapture;                                     // 0x0000(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bTest;                                             // 0x0001(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(MM_GameModeBase_UpdatePortrait) == 0x000001, "Wrong alignment on MM_GameModeBase_UpdatePortrait");
static_assert(sizeof(MM_GameModeBase_UpdatePortrait) == 0x000002, "Wrong size on MM_GameModeBase_UpdatePortrait");
static_assert(offsetof(MM_GameModeBase_UpdatePortrait, bDelayCapture) == 0x000000, "Member 'MM_GameModeBase_UpdatePortrait::bDelayCapture' has a wrong offset!");
static_assert(offsetof(MM_GameModeBase_UpdatePortrait, bTest) == 0x000001, "Member 'MM_GameModeBase_UpdatePortrait::bTest' has a wrong offset!");

// Function MirMobile.HeavenTrainingRenderRoom.ChangeMainState
// 0x0004 (0x0004 - 0x0000)
struct HeavenTrainingRenderRoom_ChangeMainState final
{
public:
	int32                                         NewMainState;                                      // 0x0000(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(HeavenTrainingRenderRoom_ChangeMainState) == 0x000004, "Wrong alignment on HeavenTrainingRenderRoom_ChangeMainState");
static_assert(sizeof(HeavenTrainingRenderRoom_ChangeMainState) == 0x000004, "Wrong size on HeavenTrainingRenderRoom_ChangeMainState");
static_assert(offsetof(HeavenTrainingRenderRoom_ChangeMainState, NewMainState) == 0x000000, "Member 'HeavenTrainingRenderRoom_ChangeMainState::NewMainState' has a wrong offset!");

// Function MirMobile.HeavenTrainingRenderRoom.ChangeSubState
// 0x0004 (0x0004 - 0x0000)
struct HeavenTrainingRenderRoom_ChangeSubState final
{
public:
	int32                                         NewSubState;                                       // 0x0000(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(HeavenTrainingRenderRoom_ChangeSubState) == 0x000004, "Wrong alignment on HeavenTrainingRenderRoom_ChangeSubState");
static_assert(sizeof(HeavenTrainingRenderRoom_ChangeSubState) == 0x000004, "Wrong size on HeavenTrainingRenderRoom_ChangeSubState");
static_assert(offsetof(HeavenTrainingRenderRoom_ChangeSubState, NewSubState) == 0x000000, "Member 'HeavenTrainingRenderRoom_ChangeSubState::NewSubState' has a wrong offset!");

// Function MirMobile.HeavenTrainingRenderRoom.GetSelectedPetID
// 0x0004 (0x0004 - 0x0000)
struct HeavenTrainingRenderRoom_GetSelectedPetID final
{
public:
	int32                                         ReturnValue;                                       // 0x0000(0x0004)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(HeavenTrainingRenderRoom_GetSelectedPetID) == 0x000004, "Wrong alignment on HeavenTrainingRenderRoom_GetSelectedPetID");
static_assert(sizeof(HeavenTrainingRenderRoom_GetSelectedPetID) == 0x000004, "Wrong size on HeavenTrainingRenderRoom_GetSelectedPetID");
static_assert(offsetof(HeavenTrainingRenderRoom_GetSelectedPetID, ReturnValue) == 0x000000, "Member 'HeavenTrainingRenderRoom_GetSelectedPetID::ReturnValue' has a wrong offset!");

// Function MirMobile.HeavenTrainingRenderRoom.OnChangePetTierEvent
// 0x0004 (0x0004 - 0x0000)
struct HeavenTrainingRenderRoom_OnChangePetTierEvent final
{
public:
	int32                                         PetTier;                                           // 0x0000(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(HeavenTrainingRenderRoom_OnChangePetTierEvent) == 0x000004, "Wrong alignment on HeavenTrainingRenderRoom_OnChangePetTierEvent");
static_assert(sizeof(HeavenTrainingRenderRoom_OnChangePetTierEvent) == 0x000004, "Wrong size on HeavenTrainingRenderRoom_OnChangePetTierEvent");
static_assert(offsetof(HeavenTrainingRenderRoom_OnChangePetTierEvent, PetTier) == 0x000000, "Member 'HeavenTrainingRenderRoom_OnChangePetTierEvent::PetTier' has a wrong offset!");

// Function MirMobile.HeavenTrainingRenderRoom.OnMeshLoadCompleteEvent
// 0x0004 (0x0004 - 0x0000)
struct HeavenTrainingRenderRoom_OnMeshLoadCompleteEvent final
{
public:
	int32                                         PetTier;                                           // 0x0000(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(HeavenTrainingRenderRoom_OnMeshLoadCompleteEvent) == 0x000004, "Wrong alignment on HeavenTrainingRenderRoom_OnMeshLoadCompleteEvent");
static_assert(sizeof(HeavenTrainingRenderRoom_OnMeshLoadCompleteEvent) == 0x000004, "Wrong size on HeavenTrainingRenderRoom_OnMeshLoadCompleteEvent");
static_assert(offsetof(HeavenTrainingRenderRoom_OnMeshLoadCompleteEvent, PetTier) == 0x000000, "Member 'HeavenTrainingRenderRoom_OnMeshLoadCompleteEvent::PetTier' has a wrong offset!");

// Function MirMobile.HeavenTrainingRenderRoom.SetCameraFOV
// 0x0004 (0x0004 - 0x0000)
struct HeavenTrainingRenderRoom_SetCameraFOV final
{
public:
	float                                         CameraFov;                                         // 0x0000(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(HeavenTrainingRenderRoom_SetCameraFOV) == 0x000004, "Wrong alignment on HeavenTrainingRenderRoom_SetCameraFOV");
static_assert(sizeof(HeavenTrainingRenderRoom_SetCameraFOV) == 0x000004, "Wrong size on HeavenTrainingRenderRoom_SetCameraFOV");
static_assert(offsetof(HeavenTrainingRenderRoom_SetCameraFOV, CameraFov) == 0x000000, "Member 'HeavenTrainingRenderRoom_SetCameraFOV::CameraFov' has a wrong offset!");

// Function MirMobile.HeavenTrainingRenderRoom.SetFloorData
// 0x001C (0x001C - 0x0000)
struct HeavenTrainingRenderRoom_SetFloorData final
{
public:
	float                                         FloorScale;                                        // 0x0000(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                FloorLocation;                                     // 0x0004(0x000C)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FRotator                               FloorRotation;                                     // 0x0010(0x000C)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(HeavenTrainingRenderRoom_SetFloorData) == 0x000004, "Wrong alignment on HeavenTrainingRenderRoom_SetFloorData");
static_assert(sizeof(HeavenTrainingRenderRoom_SetFloorData) == 0x00001C, "Wrong size on HeavenTrainingRenderRoom_SetFloorData");
static_assert(offsetof(HeavenTrainingRenderRoom_SetFloorData, FloorScale) == 0x000000, "Member 'HeavenTrainingRenderRoom_SetFloorData::FloorScale' has a wrong offset!");
static_assert(offsetof(HeavenTrainingRenderRoom_SetFloorData, FloorLocation) == 0x000004, "Member 'HeavenTrainingRenderRoom_SetFloorData::FloorLocation' has a wrong offset!");
static_assert(offsetof(HeavenTrainingRenderRoom_SetFloorData, FloorRotation) == 0x000010, "Member 'HeavenTrainingRenderRoom_SetFloorData::FloorRotation' has a wrong offset!");

// Function MirMobile.HeavenTrainingRenderRoom.SetPetPlacement
// 0x0018 (0x0018 - 0x0000)
struct HeavenTrainingRenderRoom_SetPetPlacement final
{
public:
	struct FVector                                PetLoc;                                            // 0x0000(0x000C)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FRotator                               PetRot;                                            // 0x000C(0x000C)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(HeavenTrainingRenderRoom_SetPetPlacement) == 0x000004, "Wrong alignment on HeavenTrainingRenderRoom_SetPetPlacement");
static_assert(sizeof(HeavenTrainingRenderRoom_SetPetPlacement) == 0x000018, "Wrong size on HeavenTrainingRenderRoom_SetPetPlacement");
static_assert(offsetof(HeavenTrainingRenderRoom_SetPetPlacement, PetLoc) == 0x000000, "Member 'HeavenTrainingRenderRoom_SetPetPlacement::PetLoc' has a wrong offset!");
static_assert(offsetof(HeavenTrainingRenderRoom_SetPetPlacement, PetRot) == 0x00000C, "Member 'HeavenTrainingRenderRoom_SetPetPlacement::PetRot' has a wrong offset!");

// Function MirMobile.HeavenTrainingRenderRoom.SetPetScale
// 0x0004 (0x0004 - 0x0000)
struct HeavenTrainingRenderRoom_SetPetScale final
{
public:
	float                                         PetScale;                                          // 0x0000(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(HeavenTrainingRenderRoom_SetPetScale) == 0x000004, "Wrong alignment on HeavenTrainingRenderRoom_SetPetScale");
static_assert(sizeof(HeavenTrainingRenderRoom_SetPetScale) == 0x000004, "Wrong size on HeavenTrainingRenderRoom_SetPetScale");
static_assert(offsetof(HeavenTrainingRenderRoom_SetPetScale, PetScale) == 0x000000, "Member 'HeavenTrainingRenderRoom_SetPetScale::PetScale' has a wrong offset!");

// Function MirMobile.HeavenTrainingRenderRoom.ShowLoadingEffect
// 0x0001 (0x0001 - 0x0000)
struct HeavenTrainingRenderRoom_ShowLoadingEffect final
{
public:
	bool                                          bShow;                                             // 0x0000(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(HeavenTrainingRenderRoom_ShowLoadingEffect) == 0x000001, "Wrong alignment on HeavenTrainingRenderRoom_ShowLoadingEffect");
static_assert(sizeof(HeavenTrainingRenderRoom_ShowLoadingEffect) == 0x000001, "Wrong size on HeavenTrainingRenderRoom_ShowLoadingEffect");
static_assert(offsetof(HeavenTrainingRenderRoom_ShowLoadingEffect, bShow) == 0x000000, "Member 'HeavenTrainingRenderRoom_ShowLoadingEffect::bShow' has a wrong offset!");

// Function MirMobile.HeavenTrainingRenderRoom.ShowupParticleEvent
// 0x0004 (0x0004 - 0x0000)
struct HeavenTrainingRenderRoom_ShowupParticleEvent final
{
public:
	int32                                         PetTier;                                           // 0x0000(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(HeavenTrainingRenderRoom_ShowupParticleEvent) == 0x000004, "Wrong alignment on HeavenTrainingRenderRoom_ShowupParticleEvent");
static_assert(sizeof(HeavenTrainingRenderRoom_ShowupParticleEvent) == 0x000004, "Wrong size on HeavenTrainingRenderRoom_ShowupParticleEvent");
static_assert(offsetof(HeavenTrainingRenderRoom_ShowupParticleEvent, PetTier) == 0x000000, "Member 'HeavenTrainingRenderRoom_ShowupParticleEvent::PetTier' has a wrong offset!");

// Function MirMobile.HeroInfoCamera.ChangeMainState
// 0x0004 (0x0004 - 0x0000)
struct HeroInfoCamera_ChangeMainState final
{
public:
	int32                                         NewMainState;                                      // 0x0000(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(HeroInfoCamera_ChangeMainState) == 0x000004, "Wrong alignment on HeroInfoCamera_ChangeMainState");
static_assert(sizeof(HeroInfoCamera_ChangeMainState) == 0x000004, "Wrong size on HeroInfoCamera_ChangeMainState");
static_assert(offsetof(HeroInfoCamera_ChangeMainState, NewMainState) == 0x000000, "Member 'HeroInfoCamera_ChangeMainState::NewMainState' has a wrong offset!");

// Function MirMobile.HeroInfoCamera.ChangeSubState
// 0x0004 (0x0004 - 0x0000)
struct HeroInfoCamera_ChangeSubState final
{
public:
	int32                                         NewSubState;                                       // 0x0000(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(HeroInfoCamera_ChangeSubState) == 0x000004, "Wrong alignment on HeroInfoCamera_ChangeSubState");
static_assert(sizeof(HeroInfoCamera_ChangeSubState) == 0x000004, "Wrong size on HeroInfoCamera_ChangeSubState");
static_assert(offsetof(HeroInfoCamera_ChangeSubState, NewSubState) == 0x000000, "Member 'HeroInfoCamera_ChangeSubState::NewSubState' has a wrong offset!");

// Function MirMobile.HeroInfoCamera.SetHeroInfoVisibility
// 0x0001 (0x0001 - 0x0000)
struct HeroInfoCamera_SetHeroInfoVisibility final
{
public:
	bool                                          IsVisible;                                         // 0x0000(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(HeroInfoCamera_SetHeroInfoVisibility) == 0x000001, "Wrong alignment on HeroInfoCamera_SetHeroInfoVisibility");
static_assert(sizeof(HeroInfoCamera_SetHeroInfoVisibility) == 0x000001, "Wrong size on HeroInfoCamera_SetHeroInfoVisibility");
static_assert(offsetof(HeroInfoCamera_SetHeroInfoVisibility, IsVisible) == 0x000000, "Member 'HeroInfoCamera_SetHeroInfoVisibility::IsVisible' has a wrong offset!");

// Function MirMobile.MirTileView.ChangeEntryWidget
// 0x0008 (0x0008 - 0x0000)
struct MirTileView_ChangeEntryWidget final
{
public:
	int32                                         IIndex;                                            // 0x0000(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          ReturnValue;                                       // 0x0004(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_5[0x3];                                        // 0x0005(0x0003)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(MirTileView_ChangeEntryWidget) == 0x000004, "Wrong alignment on MirTileView_ChangeEntryWidget");
static_assert(sizeof(MirTileView_ChangeEntryWidget) == 0x000008, "Wrong size on MirTileView_ChangeEntryWidget");
static_assert(offsetof(MirTileView_ChangeEntryWidget, IIndex) == 0x000000, "Member 'MirTileView_ChangeEntryWidget::IIndex' has a wrong offset!");
static_assert(offsetof(MirTileView_ChangeEntryWidget, ReturnValue) == 0x000004, "Member 'MirTileView_ChangeEntryWidget::ReturnValue' has a wrong offset!");

// Function MirMobile.MM_PopUp_DragonicGear_EquipAuto.OnClickEquipSlot
// 0x0010 (0x0010 - 0x0000)
struct MM_PopUp_DragonicGear_EquipAuto_OnClickEquipSlot final
{
public:
	int64                                         InItemUID;                                         // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         InItemTID;                                         // 0x0008(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         InPartIndex;                                       // 0x000C(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(MM_PopUp_DragonicGear_EquipAuto_OnClickEquipSlot) == 0x000008, "Wrong alignment on MM_PopUp_DragonicGear_EquipAuto_OnClickEquipSlot");
static_assert(sizeof(MM_PopUp_DragonicGear_EquipAuto_OnClickEquipSlot) == 0x000010, "Wrong size on MM_PopUp_DragonicGear_EquipAuto_OnClickEquipSlot");
static_assert(offsetof(MM_PopUp_DragonicGear_EquipAuto_OnClickEquipSlot, InItemUID) == 0x000000, "Member 'MM_PopUp_DragonicGear_EquipAuto_OnClickEquipSlot::InItemUID' has a wrong offset!");
static_assert(offsetof(MM_PopUp_DragonicGear_EquipAuto_OnClickEquipSlot, InItemTID) == 0x000008, "Member 'MM_PopUp_DragonicGear_EquipAuto_OnClickEquipSlot::InItemTID' has a wrong offset!");
static_assert(offsetof(MM_PopUp_DragonicGear_EquipAuto_OnClickEquipSlot, InPartIndex) == 0x00000C, "Member 'MM_PopUp_DragonicGear_EquipAuto_OnClickEquipSlot::InPartIndex' has a wrong offset!");

// Function MirMobile.HuaweiPushHelper.OnResponseHuaweiPushDeleteToken
// 0x0008 (0x0008 - 0x0000)
struct HuaweiPushHelper_OnResponseHuaweiPushDeleteToken final
{
public:
	bool                                          bSuccess;                                          // 0x0000(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1[0x3];                                        // 0x0001(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         ResultCode;                                        // 0x0004(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(HuaweiPushHelper_OnResponseHuaweiPushDeleteToken) == 0x000004, "Wrong alignment on HuaweiPushHelper_OnResponseHuaweiPushDeleteToken");
static_assert(sizeof(HuaweiPushHelper_OnResponseHuaweiPushDeleteToken) == 0x000008, "Wrong size on HuaweiPushHelper_OnResponseHuaweiPushDeleteToken");
static_assert(offsetof(HuaweiPushHelper_OnResponseHuaweiPushDeleteToken, bSuccess) == 0x000000, "Member 'HuaweiPushHelper_OnResponseHuaweiPushDeleteToken::bSuccess' has a wrong offset!");
static_assert(offsetof(HuaweiPushHelper_OnResponseHuaweiPushDeleteToken, ResultCode) == 0x000004, "Member 'HuaweiPushHelper_OnResponseHuaweiPushDeleteToken::ResultCode' has a wrong offset!");

// Function MirMobile.HuaweiPushHelper.OnResponseHuaweiPushGetToken
// 0x0018 (0x0018 - 0x0000)
struct HuaweiPushHelper_OnResponseHuaweiPushGetToken final
{
public:
	bool                                          bSuccess;                                          // 0x0000(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1[0x3];                                        // 0x0001(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         ResultCode;                                        // 0x0004(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 Token;                                             // 0x0008(0x0010)(ConstParm, Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(HuaweiPushHelper_OnResponseHuaweiPushGetToken) == 0x000008, "Wrong alignment on HuaweiPushHelper_OnResponseHuaweiPushGetToken");
static_assert(sizeof(HuaweiPushHelper_OnResponseHuaweiPushGetToken) == 0x000018, "Wrong size on HuaweiPushHelper_OnResponseHuaweiPushGetToken");
static_assert(offsetof(HuaweiPushHelper_OnResponseHuaweiPushGetToken, bSuccess) == 0x000000, "Member 'HuaweiPushHelper_OnResponseHuaweiPushGetToken::bSuccess' has a wrong offset!");
static_assert(offsetof(HuaweiPushHelper_OnResponseHuaweiPushGetToken, ResultCode) == 0x000004, "Member 'HuaweiPushHelper_OnResponseHuaweiPushGetToken::ResultCode' has a wrong offset!");
static_assert(offsetof(HuaweiPushHelper_OnResponseHuaweiPushGetToken, Token) == 0x000008, "Member 'HuaweiPushHelper_OnResponseHuaweiPushGetToken::Token' has a wrong offset!");

// Function MirMobile.HuaweiPushHelper.OnResponseHuaweiPushMessageReceived
// 0x0018 (0x0018 - 0x0000)
struct HuaweiPushHelper_OnResponseHuaweiPushMessageReceived final
{
public:
	bool                                          bSuccess;                                          // 0x0000(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1[0x3];                                        // 0x0001(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         ResultCode;                                        // 0x0004(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 Message;                                           // 0x0008(0x0010)(ConstParm, Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(HuaweiPushHelper_OnResponseHuaweiPushMessageReceived) == 0x000008, "Wrong alignment on HuaweiPushHelper_OnResponseHuaweiPushMessageReceived");
static_assert(sizeof(HuaweiPushHelper_OnResponseHuaweiPushMessageReceived) == 0x000018, "Wrong size on HuaweiPushHelper_OnResponseHuaweiPushMessageReceived");
static_assert(offsetof(HuaweiPushHelper_OnResponseHuaweiPushMessageReceived, bSuccess) == 0x000000, "Member 'HuaweiPushHelper_OnResponseHuaweiPushMessageReceived::bSuccess' has a wrong offset!");
static_assert(offsetof(HuaweiPushHelper_OnResponseHuaweiPushMessageReceived, ResultCode) == 0x000004, "Member 'HuaweiPushHelper_OnResponseHuaweiPushMessageReceived::ResultCode' has a wrong offset!");
static_assert(offsetof(HuaweiPushHelper_OnResponseHuaweiPushMessageReceived, Message) == 0x000008, "Member 'HuaweiPushHelper_OnResponseHuaweiPushMessageReceived::Message' has a wrong offset!");

// Function MirMobile.HuaweiPushHelper.OnResponseHuaweiPushNewToken
// 0x0018 (0x0018 - 0x0000)
struct HuaweiPushHelper_OnResponseHuaweiPushNewToken final
{
public:
	bool                                          bSuccess;                                          // 0x0000(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1[0x3];                                        // 0x0001(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         ResultCode;                                        // 0x0004(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 Token;                                             // 0x0008(0x0010)(ConstParm, Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(HuaweiPushHelper_OnResponseHuaweiPushNewToken) == 0x000008, "Wrong alignment on HuaweiPushHelper_OnResponseHuaweiPushNewToken");
static_assert(sizeof(HuaweiPushHelper_OnResponseHuaweiPushNewToken) == 0x000018, "Wrong size on HuaweiPushHelper_OnResponseHuaweiPushNewToken");
static_assert(offsetof(HuaweiPushHelper_OnResponseHuaweiPushNewToken, bSuccess) == 0x000000, "Member 'HuaweiPushHelper_OnResponseHuaweiPushNewToken::bSuccess' has a wrong offset!");
static_assert(offsetof(HuaweiPushHelper_OnResponseHuaweiPushNewToken, ResultCode) == 0x000004, "Member 'HuaweiPushHelper_OnResponseHuaweiPushNewToken::ResultCode' has a wrong offset!");
static_assert(offsetof(HuaweiPushHelper_OnResponseHuaweiPushNewToken, Token) == 0x000008, "Member 'HuaweiPushHelper_OnResponseHuaweiPushNewToken::Token' has a wrong offset!");

// Function MirMobile.HuaweiPushHelper.OnResponseHuaweiPushSubscribe
// 0x0008 (0x0008 - 0x0000)
struct HuaweiPushHelper_OnResponseHuaweiPushSubscribe final
{
public:
	bool                                          bSuccess;                                          // 0x0000(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1[0x3];                                        // 0x0001(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         ResultCode;                                        // 0x0004(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(HuaweiPushHelper_OnResponseHuaweiPushSubscribe) == 0x000004, "Wrong alignment on HuaweiPushHelper_OnResponseHuaweiPushSubscribe");
static_assert(sizeof(HuaweiPushHelper_OnResponseHuaweiPushSubscribe) == 0x000008, "Wrong size on HuaweiPushHelper_OnResponseHuaweiPushSubscribe");
static_assert(offsetof(HuaweiPushHelper_OnResponseHuaweiPushSubscribe, bSuccess) == 0x000000, "Member 'HuaweiPushHelper_OnResponseHuaweiPushSubscribe::bSuccess' has a wrong offset!");
static_assert(offsetof(HuaweiPushHelper_OnResponseHuaweiPushSubscribe, ResultCode) == 0x000004, "Member 'HuaweiPushHelper_OnResponseHuaweiPushSubscribe::ResultCode' has a wrong offset!");

// Function MirMobile.HuaweiPushHelper.OnResponseHuaweiPushUnSubscribe
// 0x0008 (0x0008 - 0x0000)
struct HuaweiPushHelper_OnResponseHuaweiPushUnSubscribe final
{
public:
	bool                                          bSuccess;                                          // 0x0000(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1[0x3];                                        // 0x0001(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         ResultCode;                                        // 0x0004(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(HuaweiPushHelper_OnResponseHuaweiPushUnSubscribe) == 0x000004, "Wrong alignment on HuaweiPushHelper_OnResponseHuaweiPushUnSubscribe");
static_assert(sizeof(HuaweiPushHelper_OnResponseHuaweiPushUnSubscribe) == 0x000008, "Wrong size on HuaweiPushHelper_OnResponseHuaweiPushUnSubscribe");
static_assert(offsetof(HuaweiPushHelper_OnResponseHuaweiPushUnSubscribe, bSuccess) == 0x000000, "Member 'HuaweiPushHelper_OnResponseHuaweiPushUnSubscribe::bSuccess' has a wrong offset!");
static_assert(offsetof(HuaweiPushHelper_OnResponseHuaweiPushUnSubscribe, ResultCode) == 0x000004, "Member 'HuaweiPushHelper_OnResponseHuaweiPushUnSubscribe::ResultCode' has a wrong offset!");

// Function MirMobile.IAPGalaxyStoreModule.OnResponseConsumePurchasedItems
// 0x00B0 (0x00B0 - 0x0000)
struct IAPGalaxyStoreModule_OnResponseConsumePurchasedItems final
{
public:
	bool                                          bSuccess;                                          // 0x0000(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1[0x3];                                        // 0x0001(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         ErrorCode;                                         // 0x0004(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FIAPProductData                        ProductData;                                       // 0x0008(0x00A8)(ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
};
static_assert(alignof(IAPGalaxyStoreModule_OnResponseConsumePurchasedItems) == 0x000008, "Wrong alignment on IAPGalaxyStoreModule_OnResponseConsumePurchasedItems");
static_assert(sizeof(IAPGalaxyStoreModule_OnResponseConsumePurchasedItems) == 0x0000B0, "Wrong size on IAPGalaxyStoreModule_OnResponseConsumePurchasedItems");
static_assert(offsetof(IAPGalaxyStoreModule_OnResponseConsumePurchasedItems, bSuccess) == 0x000000, "Member 'IAPGalaxyStoreModule_OnResponseConsumePurchasedItems::bSuccess' has a wrong offset!");
static_assert(offsetof(IAPGalaxyStoreModule_OnResponseConsumePurchasedItems, ErrorCode) == 0x000004, "Member 'IAPGalaxyStoreModule_OnResponseConsumePurchasedItems::ErrorCode' has a wrong offset!");
static_assert(offsetof(IAPGalaxyStoreModule_OnResponseConsumePurchasedItems, ProductData) == 0x000008, "Member 'IAPGalaxyStoreModule_OnResponseConsumePurchasedItems::ProductData' has a wrong offset!");

// Function MirMobile.IAPGalaxyStoreModule.OnResponseGetProducts
// 0x00B0 (0x00B0 - 0x0000)
struct IAPGalaxyStoreModule_OnResponseGetProducts final
{
public:
	bool                                          bSuccess;                                          // 0x0000(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1[0x3];                                        // 0x0001(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         ErrorCode;                                         // 0x0004(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FIAPProductData                        ProductData;                                       // 0x0008(0x00A8)(ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
};
static_assert(alignof(IAPGalaxyStoreModule_OnResponseGetProducts) == 0x000008, "Wrong alignment on IAPGalaxyStoreModule_OnResponseGetProducts");
static_assert(sizeof(IAPGalaxyStoreModule_OnResponseGetProducts) == 0x0000B0, "Wrong size on IAPGalaxyStoreModule_OnResponseGetProducts");
static_assert(offsetof(IAPGalaxyStoreModule_OnResponseGetProducts, bSuccess) == 0x000000, "Member 'IAPGalaxyStoreModule_OnResponseGetProducts::bSuccess' has a wrong offset!");
static_assert(offsetof(IAPGalaxyStoreModule_OnResponseGetProducts, ErrorCode) == 0x000004, "Member 'IAPGalaxyStoreModule_OnResponseGetProducts::ErrorCode' has a wrong offset!");
static_assert(offsetof(IAPGalaxyStoreModule_OnResponseGetProducts, ProductData) == 0x000008, "Member 'IAPGalaxyStoreModule_OnResponseGetProducts::ProductData' has a wrong offset!");

// Function MirMobile.IAPGalaxyStoreModule.OnResponseOwnedProduct
// 0x0018 (0x0018 - 0x0000)
struct IAPGalaxyStoreModule_OnResponseOwnedProduct final
{
public:
	bool                                          bSuccess;                                          // 0x0000(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1[0x3];                                        // 0x0001(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         ErrorCode;                                         // 0x0004(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<struct FIAPProductData>                ProductList;                                       // 0x0008(0x0010)(ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, NativeAccessSpecifierPublic)
};
static_assert(alignof(IAPGalaxyStoreModule_OnResponseOwnedProduct) == 0x000008, "Wrong alignment on IAPGalaxyStoreModule_OnResponseOwnedProduct");
static_assert(sizeof(IAPGalaxyStoreModule_OnResponseOwnedProduct) == 0x000018, "Wrong size on IAPGalaxyStoreModule_OnResponseOwnedProduct");
static_assert(offsetof(IAPGalaxyStoreModule_OnResponseOwnedProduct, bSuccess) == 0x000000, "Member 'IAPGalaxyStoreModule_OnResponseOwnedProduct::bSuccess' has a wrong offset!");
static_assert(offsetof(IAPGalaxyStoreModule_OnResponseOwnedProduct, ErrorCode) == 0x000004, "Member 'IAPGalaxyStoreModule_OnResponseOwnedProduct::ErrorCode' has a wrong offset!");
static_assert(offsetof(IAPGalaxyStoreModule_OnResponseOwnedProduct, ProductList) == 0x000008, "Member 'IAPGalaxyStoreModule_OnResponseOwnedProduct::ProductList' has a wrong offset!");

// Function MirMobile.IAPGalaxyStoreModule.OnResponsePayment
// 0x00B0 (0x00B0 - 0x0000)
struct IAPGalaxyStoreModule_OnResponsePayment final
{
public:
	bool                                          bSuccess;                                          // 0x0000(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1[0x3];                                        // 0x0001(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         ErrorCode;                                         // 0x0004(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FIAPProductData                        ProductData;                                       // 0x0008(0x00A8)(ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
};
static_assert(alignof(IAPGalaxyStoreModule_OnResponsePayment) == 0x000008, "Wrong alignment on IAPGalaxyStoreModule_OnResponsePayment");
static_assert(sizeof(IAPGalaxyStoreModule_OnResponsePayment) == 0x0000B0, "Wrong size on IAPGalaxyStoreModule_OnResponsePayment");
static_assert(offsetof(IAPGalaxyStoreModule_OnResponsePayment, bSuccess) == 0x000000, "Member 'IAPGalaxyStoreModule_OnResponsePayment::bSuccess' has a wrong offset!");
static_assert(offsetof(IAPGalaxyStoreModule_OnResponsePayment, ErrorCode) == 0x000004, "Member 'IAPGalaxyStoreModule_OnResponsePayment::ErrorCode' has a wrong offset!");
static_assert(offsetof(IAPGalaxyStoreModule_OnResponsePayment, ProductData) == 0x000008, "Member 'IAPGalaxyStoreModule_OnResponsePayment::ProductData' has a wrong offset!");

// Function MirMobile.IAPHuaweiStoreModule.OnResponseConsumePurchasedItems
// 0x00B0 (0x00B0 - 0x0000)
struct IAPHuaweiStoreModule_OnResponseConsumePurchasedItems final
{
public:
	bool                                          bSuccess;                                          // 0x0000(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1[0x3];                                        // 0x0001(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         ErrorCode;                                         // 0x0004(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FIAPProductData                        ProductData;                                       // 0x0008(0x00A8)(ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
};
static_assert(alignof(IAPHuaweiStoreModule_OnResponseConsumePurchasedItems) == 0x000008, "Wrong alignment on IAPHuaweiStoreModule_OnResponseConsumePurchasedItems");
static_assert(sizeof(IAPHuaweiStoreModule_OnResponseConsumePurchasedItems) == 0x0000B0, "Wrong size on IAPHuaweiStoreModule_OnResponseConsumePurchasedItems");
static_assert(offsetof(IAPHuaweiStoreModule_OnResponseConsumePurchasedItems, bSuccess) == 0x000000, "Member 'IAPHuaweiStoreModule_OnResponseConsumePurchasedItems::bSuccess' has a wrong offset!");
static_assert(offsetof(IAPHuaweiStoreModule_OnResponseConsumePurchasedItems, ErrorCode) == 0x000004, "Member 'IAPHuaweiStoreModule_OnResponseConsumePurchasedItems::ErrorCode' has a wrong offset!");
static_assert(offsetof(IAPHuaweiStoreModule_OnResponseConsumePurchasedItems, ProductData) == 0x000008, "Member 'IAPHuaweiStoreModule_OnResponseConsumePurchasedItems::ProductData' has a wrong offset!");

// Function MirMobile.IAPHuaweiStoreModule.OnResponseGetProducts
// 0x0018 (0x0018 - 0x0000)
struct IAPHuaweiStoreModule_OnResponseGetProducts final
{
public:
	bool                                          bSuccess;                                          // 0x0000(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1[0x3];                                        // 0x0001(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         ErrorCode;                                         // 0x0004(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<struct FIAPMarketProductData>          ProductData;                                       // 0x0008(0x0010)(ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, NativeAccessSpecifierPublic)
};
static_assert(alignof(IAPHuaweiStoreModule_OnResponseGetProducts) == 0x000008, "Wrong alignment on IAPHuaweiStoreModule_OnResponseGetProducts");
static_assert(sizeof(IAPHuaweiStoreModule_OnResponseGetProducts) == 0x000018, "Wrong size on IAPHuaweiStoreModule_OnResponseGetProducts");
static_assert(offsetof(IAPHuaweiStoreModule_OnResponseGetProducts, bSuccess) == 0x000000, "Member 'IAPHuaweiStoreModule_OnResponseGetProducts::bSuccess' has a wrong offset!");
static_assert(offsetof(IAPHuaweiStoreModule_OnResponseGetProducts, ErrorCode) == 0x000004, "Member 'IAPHuaweiStoreModule_OnResponseGetProducts::ErrorCode' has a wrong offset!");
static_assert(offsetof(IAPHuaweiStoreModule_OnResponseGetProducts, ProductData) == 0x000008, "Member 'IAPHuaweiStoreModule_OnResponseGetProducts::ProductData' has a wrong offset!");

// Function MirMobile.IAPHuaweiStoreModule.OnResponseOwnedProduct
// 0x0018 (0x0018 - 0x0000)
struct IAPHuaweiStoreModule_OnResponseOwnedProduct final
{
public:
	bool                                          bSuccess;                                          // 0x0000(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1[0x3];                                        // 0x0001(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         ErrorCode;                                         // 0x0004(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<struct FIAPProductData>                ProductList;                                       // 0x0008(0x0010)(ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, NativeAccessSpecifierPublic)
};
static_assert(alignof(IAPHuaweiStoreModule_OnResponseOwnedProduct) == 0x000008, "Wrong alignment on IAPHuaweiStoreModule_OnResponseOwnedProduct");
static_assert(sizeof(IAPHuaweiStoreModule_OnResponseOwnedProduct) == 0x000018, "Wrong size on IAPHuaweiStoreModule_OnResponseOwnedProduct");
static_assert(offsetof(IAPHuaweiStoreModule_OnResponseOwnedProduct, bSuccess) == 0x000000, "Member 'IAPHuaweiStoreModule_OnResponseOwnedProduct::bSuccess' has a wrong offset!");
static_assert(offsetof(IAPHuaweiStoreModule_OnResponseOwnedProduct, ErrorCode) == 0x000004, "Member 'IAPHuaweiStoreModule_OnResponseOwnedProduct::ErrorCode' has a wrong offset!");
static_assert(offsetof(IAPHuaweiStoreModule_OnResponseOwnedProduct, ProductList) == 0x000008, "Member 'IAPHuaweiStoreModule_OnResponseOwnedProduct::ProductList' has a wrong offset!");

// Function MirMobile.IAPHuaweiStoreModule.OnResponsePayment
// 0x00B0 (0x00B0 - 0x0000)
struct IAPHuaweiStoreModule_OnResponsePayment final
{
public:
	bool                                          bSuccess;                                          // 0x0000(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1[0x3];                                        // 0x0001(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         ErrorCode;                                         // 0x0004(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FIAPProductData                        ProductData;                                       // 0x0008(0x00A8)(ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
};
static_assert(alignof(IAPHuaweiStoreModule_OnResponsePayment) == 0x000008, "Wrong alignment on IAPHuaweiStoreModule_OnResponsePayment");
static_assert(sizeof(IAPHuaweiStoreModule_OnResponsePayment) == 0x0000B0, "Wrong size on IAPHuaweiStoreModule_OnResponsePayment");
static_assert(offsetof(IAPHuaweiStoreModule_OnResponsePayment, bSuccess) == 0x000000, "Member 'IAPHuaweiStoreModule_OnResponsePayment::bSuccess' has a wrong offset!");
static_assert(offsetof(IAPHuaweiStoreModule_OnResponsePayment, ErrorCode) == 0x000004, "Member 'IAPHuaweiStoreModule_OnResponsePayment::ErrorCode' has a wrong offset!");
static_assert(offsetof(IAPHuaweiStoreModule_OnResponsePayment, ProductData) == 0x000008, "Member 'IAPHuaweiStoreModule_OnResponsePayment::ProductData' has a wrong offset!");

// Function MirMobile.MM_GameOption_InGame_Target.OnSelectedTargetingType
// 0x0004 (0x0004 - 0x0000)
struct MM_GameOption_InGame_Target_OnSelectedTargetingType final
{
public:
	int32                                         Idx;                                               // 0x0000(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(MM_GameOption_InGame_Target_OnSelectedTargetingType) == 0x000004, "Wrong alignment on MM_GameOption_InGame_Target_OnSelectedTargetingType");
static_assert(sizeof(MM_GameOption_InGame_Target_OnSelectedTargetingType) == 0x000004, "Wrong size on MM_GameOption_InGame_Target_OnSelectedTargetingType");
static_assert(offsetof(MM_GameOption_InGame_Target_OnSelectedTargetingType, Idx) == 0x000000, "Member 'MM_GameOption_InGame_Target_OnSelectedTargetingType::Idx' has a wrong offset!");

// Function MirMobile.MM_PhotoModeAnimInstance.IsEquarAnimIndex
// 0x0008 (0x0008 - 0x0000)
struct MM_PhotoModeAnimInstance_IsEquarAnimIndex final
{
public:
	int32                                         AnimIndex;                                         // 0x0000(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          ReturnValue;                                       // 0x0004(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_5[0x3];                                        // 0x0005(0x0003)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(MM_PhotoModeAnimInstance_IsEquarAnimIndex) == 0x000004, "Wrong alignment on MM_PhotoModeAnimInstance_IsEquarAnimIndex");
static_assert(sizeof(MM_PhotoModeAnimInstance_IsEquarAnimIndex) == 0x000008, "Wrong size on MM_PhotoModeAnimInstance_IsEquarAnimIndex");
static_assert(offsetof(MM_PhotoModeAnimInstance_IsEquarAnimIndex, AnimIndex) == 0x000000, "Member 'MM_PhotoModeAnimInstance_IsEquarAnimIndex::AnimIndex' has a wrong offset!");
static_assert(offsetof(MM_PhotoModeAnimInstance_IsEquarAnimIndex, ReturnValue) == 0x000004, "Member 'MM_PhotoModeAnimInstance_IsEquarAnimIndex::ReturnValue' has a wrong offset!");

// Function MirMobile.MM_Popup_Chat_Macro.OnSaveMacroText
// 0x0018 (0x0018 - 0x0000)
struct MM_Popup_Chat_Macro_OnSaveMacroText final
{
public:
	int32                                         SlotIndex;                                         // 0x0000(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_4[0x4];                                        // 0x0004(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class FString                                 MacroText;                                         // 0x0008(0x0010)(Parm, OutParm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(MM_Popup_Chat_Macro_OnSaveMacroText) == 0x000008, "Wrong alignment on MM_Popup_Chat_Macro_OnSaveMacroText");
static_assert(sizeof(MM_Popup_Chat_Macro_OnSaveMacroText) == 0x000018, "Wrong size on MM_Popup_Chat_Macro_OnSaveMacroText");
static_assert(offsetof(MM_Popup_Chat_Macro_OnSaveMacroText, SlotIndex) == 0x000000, "Member 'MM_Popup_Chat_Macro_OnSaveMacroText::SlotIndex' has a wrong offset!");
static_assert(offsetof(MM_Popup_Chat_Macro_OnSaveMacroText, MacroText) == 0x000008, "Member 'MM_Popup_Chat_Macro_OnSaveMacroText::MacroText' has a wrong offset!");

// Function MirMobile.MM_Popup_Chat_Macro.OnSendMacroText
// 0x0018 (0x0018 - 0x0000)
struct MM_Popup_Chat_Macro_OnSendMacroText final
{
public:
	int32                                         SlotIndex;                                         // 0x0000(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_4[0x4];                                        // 0x0004(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class FString                                 MacroText;                                         // 0x0008(0x0010)(Parm, OutParm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(MM_Popup_Chat_Macro_OnSendMacroText) == 0x000008, "Wrong alignment on MM_Popup_Chat_Macro_OnSendMacroText");
static_assert(sizeof(MM_Popup_Chat_Macro_OnSendMacroText) == 0x000018, "Wrong size on MM_Popup_Chat_Macro_OnSendMacroText");
static_assert(offsetof(MM_Popup_Chat_Macro_OnSendMacroText, SlotIndex) == 0x000000, "Member 'MM_Popup_Chat_Macro_OnSendMacroText::SlotIndex' has a wrong offset!");
static_assert(offsetof(MM_Popup_Chat_Macro_OnSendMacroText, MacroText) == 0x000008, "Member 'MM_Popup_Chat_Macro_OnSendMacroText::MacroText' has a wrong offset!");

// Function MirMobile.MM_Customizing_Palette.CreatePaletteItem
// 0x0018 (0x0018 - 0x0000)
struct MM_Customizing_Palette_CreatePaletteItem final
{
public:
	int32                                         Count;                                             // 0x0000(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_4[0x4];                                        // 0x0004(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<class UMM_Customizing_PaletteItem*>    ReturnValue;                                       // 0x0008(0x0010)(ExportObject, Parm, OutParm, ZeroConstructor, ReturnParm, ContainsInstancedReference, NativeAccessSpecifierPublic)
};
static_assert(alignof(MM_Customizing_Palette_CreatePaletteItem) == 0x000008, "Wrong alignment on MM_Customizing_Palette_CreatePaletteItem");
static_assert(sizeof(MM_Customizing_Palette_CreatePaletteItem) == 0x000018, "Wrong size on MM_Customizing_Palette_CreatePaletteItem");
static_assert(offsetof(MM_Customizing_Palette_CreatePaletteItem, Count) == 0x000000, "Member 'MM_Customizing_Palette_CreatePaletteItem::Count' has a wrong offset!");
static_assert(offsetof(MM_Customizing_Palette_CreatePaletteItem, ReturnValue) == 0x000008, "Member 'MM_Customizing_Palette_CreatePaletteItem::ReturnValue' has a wrong offset!");

// Function MirMobile.MM_Customizing_Palette.OnClickComponentEvent
// 0x0004 (0x0004 - 0x0000)
struct MM_Customizing_Palette_OnClickComponentEvent final
{
public:
	int32                                         ComponentID;                                       // 0x0000(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(MM_Customizing_Palette_OnClickComponentEvent) == 0x000004, "Wrong alignment on MM_Customizing_Palette_OnClickComponentEvent");
static_assert(sizeof(MM_Customizing_Palette_OnClickComponentEvent) == 0x000004, "Wrong size on MM_Customizing_Palette_OnClickComponentEvent");
static_assert(offsetof(MM_Customizing_Palette_OnClickComponentEvent, ComponentID) == 0x000000, "Member 'MM_Customizing_Palette_OnClickComponentEvent::ComponentID' has a wrong offset!");

// Function MirMobile.MM_Customizing_Palette.OnClickPaletteItemEvent
// 0x0004 (0x0004 - 0x0000)
struct MM_Customizing_Palette_OnClickPaletteItemEvent final
{
public:
	int32                                         PaletteIndex;                                      // 0x0000(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(MM_Customizing_Palette_OnClickPaletteItemEvent) == 0x000004, "Wrong alignment on MM_Customizing_Palette_OnClickPaletteItemEvent");
static_assert(sizeof(MM_Customizing_Palette_OnClickPaletteItemEvent) == 0x000004, "Wrong size on MM_Customizing_Palette_OnClickPaletteItemEvent");
static_assert(offsetof(MM_Customizing_Palette_OnClickPaletteItemEvent, PaletteIndex) == 0x000000, "Member 'MM_Customizing_Palette_OnClickPaletteItemEvent::PaletteIndex' has a wrong offset!");

// Function MirMobile.MM_Customizing_Palette.OnClickSubCategoryEvent
// 0x0004 (0x0004 - 0x0000)
struct MM_Customizing_Palette_OnClickSubCategoryEvent final
{
public:
	int32                                         SubCategoryIndex;                                  // 0x0000(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(MM_Customizing_Palette_OnClickSubCategoryEvent) == 0x000004, "Wrong alignment on MM_Customizing_Palette_OnClickSubCategoryEvent");
static_assert(sizeof(MM_Customizing_Palette_OnClickSubCategoryEvent) == 0x000004, "Wrong size on MM_Customizing_Palette_OnClickSubCategoryEvent");
static_assert(offsetof(MM_Customizing_Palette_OnClickSubCategoryEvent, SubCategoryIndex) == 0x000000, "Member 'MM_Customizing_Palette_OnClickSubCategoryEvent::SubCategoryIndex' has a wrong offset!");

// Function MirMobile.MM_Customizing_Palette.UpdateIconBrightness
// 0x0004 (0x0004 - 0x0000)
struct MM_Customizing_Palette_UpdateIconBrightness final
{
public:
	int32                                         _Value;                                            // 0x0000(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(MM_Customizing_Palette_UpdateIconBrightness) == 0x000004, "Wrong alignment on MM_Customizing_Palette_UpdateIconBrightness");
static_assert(sizeof(MM_Customizing_Palette_UpdateIconBrightness) == 0x000004, "Wrong size on MM_Customizing_Palette_UpdateIconBrightness");
static_assert(offsetof(MM_Customizing_Palette_UpdateIconBrightness, _Value) == 0x000000, "Member 'MM_Customizing_Palette_UpdateIconBrightness::_Value' has a wrong offset!");

// Function MirMobile.MM_Customizing_Palette.UpdatePaletteSelectData
// 0x0004 (0x0004 - 0x0000)
struct MM_Customizing_Palette_UpdatePaletteSelectData final
{
public:
	int32                                         PaletteIndex;                                      // 0x0000(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(MM_Customizing_Palette_UpdatePaletteSelectData) == 0x000004, "Wrong alignment on MM_Customizing_Palette_UpdatePaletteSelectData");
static_assert(sizeof(MM_Customizing_Palette_UpdatePaletteSelectData) == 0x000004, "Wrong size on MM_Customizing_Palette_UpdatePaletteSelectData");
static_assert(offsetof(MM_Customizing_Palette_UpdatePaletteSelectData, PaletteIndex) == 0x000000, "Member 'MM_Customizing_Palette_UpdatePaletteSelectData::PaletteIndex' has a wrong offset!");

// Function MirMobile.MM_Customizing_DoubleScroll.OnClickScrollSlot
// 0x0004 (0x0004 - 0x0000)
struct MM_Customizing_DoubleScroll_OnClickScrollSlot final
{
public:
	int32                                         NIndex;                                            // 0x0000(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(MM_Customizing_DoubleScroll_OnClickScrollSlot) == 0x000004, "Wrong alignment on MM_Customizing_DoubleScroll_OnClickScrollSlot");
static_assert(sizeof(MM_Customizing_DoubleScroll_OnClickScrollSlot) == 0x000004, "Wrong size on MM_Customizing_DoubleScroll_OnClickScrollSlot");
static_assert(offsetof(MM_Customizing_DoubleScroll_OnClickScrollSlot, NIndex) == 0x000000, "Member 'MM_Customizing_DoubleScroll_OnClickScrollSlot::NIndex' has a wrong offset!");

// Function MirMobile.MM_Customizing.MoveToCharacterSelectEvent
// 0x0001 (0x0001 - 0x0000)
struct MM_Customizing_MoveToCharacterSelectEvent final
{
public:
	bool                                          bPresetMode;                                       // 0x0000(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(MM_Customizing_MoveToCharacterSelectEvent) == 0x000001, "Wrong alignment on MM_Customizing_MoveToCharacterSelectEvent");
static_assert(sizeof(MM_Customizing_MoveToCharacterSelectEvent) == 0x000001, "Wrong size on MM_Customizing_MoveToCharacterSelectEvent");
static_assert(offsetof(MM_Customizing_MoveToCharacterSelectEvent, bPresetMode) == 0x000000, "Member 'MM_Customizing_MoveToCharacterSelectEvent::bPresetMode' has a wrong offset!");

// Function MirMobile.MM_Customizing.PlayDetailComponentShowAnimation
// 0x0001 (0x0001 - 0x0000)
struct MM_Customizing_PlayDetailComponentShowAnimation final
{
public:
	bool                                          bShow;                                             // 0x0000(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(MM_Customizing_PlayDetailComponentShowAnimation) == 0x000001, "Wrong alignment on MM_Customizing_PlayDetailComponentShowAnimation");
static_assert(sizeof(MM_Customizing_PlayDetailComponentShowAnimation) == 0x000001, "Wrong size on MM_Customizing_PlayDetailComponentShowAnimation");
static_assert(offsetof(MM_Customizing_PlayDetailComponentShowAnimation, bShow) == 0x000000, "Member 'MM_Customizing_PlayDetailComponentShowAnimation::bShow' has a wrong offset!");

// Function MirMobile.MM_Customizing.PlayPresetShowAnimation
// 0x0001 (0x0001 - 0x0000)
struct MM_Customizing_PlayPresetShowAnimation final
{
public:
	bool                                          bShow;                                             // 0x0000(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(MM_Customizing_PlayPresetShowAnimation) == 0x000001, "Wrong alignment on MM_Customizing_PlayPresetShowAnimation");
static_assert(sizeof(MM_Customizing_PlayPresetShowAnimation) == 0x000001, "Wrong size on MM_Customizing_PlayPresetShowAnimation");
static_assert(offsetof(MM_Customizing_PlayPresetShowAnimation, bShow) == 0x000000, "Member 'MM_Customizing_PlayPresetShowAnimation::bShow' has a wrong offset!");

// Function MirMobile.MM_Customizing.ShowComponentPalette
// 0x0001 (0x0001 - 0x0000)
struct MM_Customizing_ShowComponentPalette final
{
public:
	bool                                          bShow;                                             // 0x0000(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(MM_Customizing_ShowComponentPalette) == 0x000001, "Wrong alignment on MM_Customizing_ShowComponentPalette");
static_assert(sizeof(MM_Customizing_ShowComponentPalette) == 0x000001, "Wrong size on MM_Customizing_ShowComponentPalette");
static_assert(offsetof(MM_Customizing_ShowComponentPalette, bShow) == 0x000000, "Member 'MM_Customizing_ShowComponentPalette::bShow' has a wrong offset!");

// Function MirMobile.MM_Customizing.ShowFinishBtn
// 0x0001 (0x0001 - 0x0000)
struct MM_Customizing_ShowFinishBtn final
{
public:
	bool                                          bShow;                                             // 0x0000(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(MM_Customizing_ShowFinishBtn) == 0x000001, "Wrong alignment on MM_Customizing_ShowFinishBtn");
static_assert(sizeof(MM_Customizing_ShowFinishBtn) == 0x000001, "Wrong size on MM_Customizing_ShowFinishBtn");
static_assert(offsetof(MM_Customizing_ShowFinishBtn, bShow) == 0x000000, "Member 'MM_Customizing_ShowFinishBtn::bShow' has a wrong offset!");

// Function MirMobile.MM_Customizing.ShowSaveLoadComponent
// 0x0001 (0x0001 - 0x0000)
struct MM_Customizing_ShowSaveLoadComponent final
{
public:
	bool                                          bShow;                                             // 0x0000(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(MM_Customizing_ShowSaveLoadComponent) == 0x000001, "Wrong alignment on MM_Customizing_ShowSaveLoadComponent");
static_assert(sizeof(MM_Customizing_ShowSaveLoadComponent) == 0x000001, "Wrong size on MM_Customizing_ShowSaveLoadComponent");
static_assert(offsetof(MM_Customizing_ShowSaveLoadComponent, bShow) == 0x000000, "Member 'MM_Customizing_ShowSaveLoadComponent::bShow' has a wrong offset!");

// Function MirMobile.MM_Customizing_MainCategoryItem.OnSelectEffect
// 0x0004 (0x0004 - 0x0000)
struct MM_Customizing_MainCategoryItem_OnSelectEffect final
{
public:
	int32                                         CategoryIndex;                                     // 0x0000(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(MM_Customizing_MainCategoryItem_OnSelectEffect) == 0x000004, "Wrong alignment on MM_Customizing_MainCategoryItem_OnSelectEffect");
static_assert(sizeof(MM_Customizing_MainCategoryItem_OnSelectEffect) == 0x000004, "Wrong size on MM_Customizing_MainCategoryItem_OnSelectEffect");
static_assert(offsetof(MM_Customizing_MainCategoryItem_OnSelectEffect, CategoryIndex) == 0x000000, "Member 'MM_Customizing_MainCategoryItem_OnSelectEffect::CategoryIndex' has a wrong offset!");

// Function MirMobile.KakaoLoginSubSystem.OnKakaoLoginSuccess
// 0x0020 (0x0020 - 0x0000)
struct KakaoLoginSubSystem_OnKakaoLoginSuccess final
{
public:
	class FString                                 InPlayerID;                                        // 0x0000(0x0010)(Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 InAccessToken;                                     // 0x0010(0x0010)(Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(KakaoLoginSubSystem_OnKakaoLoginSuccess) == 0x000008, "Wrong alignment on KakaoLoginSubSystem_OnKakaoLoginSuccess");
static_assert(sizeof(KakaoLoginSubSystem_OnKakaoLoginSuccess) == 0x000020, "Wrong size on KakaoLoginSubSystem_OnKakaoLoginSuccess");
static_assert(offsetof(KakaoLoginSubSystem_OnKakaoLoginSuccess, InPlayerID) == 0x000000, "Member 'KakaoLoginSubSystem_OnKakaoLoginSuccess::InPlayerID' has a wrong offset!");
static_assert(offsetof(KakaoLoginSubSystem_OnKakaoLoginSuccess, InAccessToken) == 0x000010, "Member 'KakaoLoginSubSystem_OnKakaoLoginSuccess::InAccessToken' has a wrong offset!");

// Function MirMobile.MM_Customizing_SaveSlot.OnClickCheckBox
// 0x0001 (0x0001 - 0x0000)
struct MM_Customizing_SaveSlot_OnClickCheckBox final
{
public:
	bool                                          _Check;                                            // 0x0000(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(MM_Customizing_SaveSlot_OnClickCheckBox) == 0x000001, "Wrong alignment on MM_Customizing_SaveSlot_OnClickCheckBox");
static_assert(sizeof(MM_Customizing_SaveSlot_OnClickCheckBox) == 0x000001, "Wrong size on MM_Customizing_SaveSlot_OnClickCheckBox");
static_assert(offsetof(MM_Customizing_SaveSlot_OnClickCheckBox, _Check) == 0x000000, "Member 'MM_Customizing_SaveSlot_OnClickCheckBox::_Check' has a wrong offset!");

// Function MirMobile.MM_Customizing_SaveSlot.SetNewMemo
// 0x0010 (0x0010 - 0x0000)
struct MM_Customizing_SaveSlot_SetNewMemo final
{
public:
	class FString                                 NewMemo;                                           // 0x0000(0x0010)(Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(MM_Customizing_SaveSlot_SetNewMemo) == 0x000008, "Wrong alignment on MM_Customizing_SaveSlot_SetNewMemo");
static_assert(sizeof(MM_Customizing_SaveSlot_SetNewMemo) == 0x000010, "Wrong size on MM_Customizing_SaveSlot_SetNewMemo");
static_assert(offsetof(MM_Customizing_SaveSlot_SetNewMemo, NewMemo) == 0x000000, "Member 'MM_Customizing_SaveSlot_SetNewMemo::NewMemo' has a wrong offset!");

// Function MirMobile.LevelSequenceAirWalkActor.GetAirwalkMontage
// 0x0008 (0x0008 - 0x0000)
struct LevelSequenceAirWalkActor_GetAirwalkMontage final
{
public:
	class UAnimMontage*                           ReturnValue;                                       // 0x0000(0x0008)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(LevelSequenceAirWalkActor_GetAirwalkMontage) == 0x000008, "Wrong alignment on LevelSequenceAirWalkActor_GetAirwalkMontage");
static_assert(sizeof(LevelSequenceAirWalkActor_GetAirwalkMontage) == 0x000008, "Wrong size on LevelSequenceAirWalkActor_GetAirwalkMontage");
static_assert(offsetof(LevelSequenceAirWalkActor_GetAirwalkMontage, ReturnValue) == 0x000000, "Member 'LevelSequenceAirWalkActor_GetAirwalkMontage::ReturnValue' has a wrong offset!");

// Function MirMobile.MM_Customizing_PaletteThumbnail.OnClickThumbnail
// 0x0004 (0x0004 - 0x0000)
struct MM_Customizing_PaletteThumbnail_OnClickThumbnail final
{
public:
	int32                                         PaletteIndex;                                      // 0x0000(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(MM_Customizing_PaletteThumbnail_OnClickThumbnail) == 0x000004, "Wrong alignment on MM_Customizing_PaletteThumbnail_OnClickThumbnail");
static_assert(sizeof(MM_Customizing_PaletteThumbnail_OnClickThumbnail) == 0x000004, "Wrong size on MM_Customizing_PaletteThumbnail_OnClickThumbnail");
static_assert(offsetof(MM_Customizing_PaletteThumbnail_OnClickThumbnail, PaletteIndex) == 0x000000, "Member 'MM_Customizing_PaletteThumbnail_OnClickThumbnail::PaletteIndex' has a wrong offset!");

// Function MirMobile.MM_Customizing_PaletteThumbnail.UpdateThumbnailBrightness
// 0x0004 (0x0004 - 0x0000)
struct MM_Customizing_PaletteThumbnail_UpdateThumbnailBrightness final
{
public:
	int32                                         _Value;                                            // 0x0000(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(MM_Customizing_PaletteThumbnail_UpdateThumbnailBrightness) == 0x000004, "Wrong alignment on MM_Customizing_PaletteThumbnail_UpdateThumbnailBrightness");
static_assert(sizeof(MM_Customizing_PaletteThumbnail_UpdateThumbnailBrightness) == 0x000004, "Wrong size on MM_Customizing_PaletteThumbnail_UpdateThumbnailBrightness");
static_assert(offsetof(MM_Customizing_PaletteThumbnail_UpdateThumbnailBrightness, _Value) == 0x000000, "Member 'MM_Customizing_PaletteThumbnail_UpdateThumbnailBrightness::_Value' has a wrong offset!");

// Function MirMobile.MM_Customizing_PaletteThumbnail.UpdateThumbnailColorData
// 0x0004 (0x0004 - 0x0000)
struct MM_Customizing_PaletteThumbnail_UpdateThumbnailColorData final
{
public:
	int32                                         NCustomizingValue;                                 // 0x0000(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(MM_Customizing_PaletteThumbnail_UpdateThumbnailColorData) == 0x000004, "Wrong alignment on MM_Customizing_PaletteThumbnail_UpdateThumbnailColorData");
static_assert(sizeof(MM_Customizing_PaletteThumbnail_UpdateThumbnailColorData) == 0x000004, "Wrong size on MM_Customizing_PaletteThumbnail_UpdateThumbnailColorData");
static_assert(offsetof(MM_Customizing_PaletteThumbnail_UpdateThumbnailColorData, NCustomizingValue) == 0x000000, "Member 'MM_Customizing_PaletteThumbnail_UpdateThumbnailColorData::NCustomizingValue' has a wrong offset!");

// Function MirMobile.LevelSequenceSubtitle.CreateFadeWidget
// 0x0008 (0x0008 - 0x0000)
struct LevelSequenceSubtitle_CreateFadeWidget final
{
public:
	class UFadeWidget*                            ReturnValue;                                       // 0x0000(0x0008)(ExportObject, Parm, OutParm, ZeroConstructor, ReturnParm, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(LevelSequenceSubtitle_CreateFadeWidget) == 0x000008, "Wrong alignment on LevelSequenceSubtitle_CreateFadeWidget");
static_assert(sizeof(LevelSequenceSubtitle_CreateFadeWidget) == 0x000008, "Wrong size on LevelSequenceSubtitle_CreateFadeWidget");
static_assert(offsetof(LevelSequenceSubtitle_CreateFadeWidget, ReturnValue) == 0x000000, "Member 'LevelSequenceSubtitle_CreateFadeWidget::ReturnValue' has a wrong offset!");

// Function MirMobile.LevelSequenceSubtitle.SetSubtitle
// 0x0018 (0x0018 - 0x0000)
struct LevelSequenceSubtitle_SetSubtitle final
{
public:
	class FString                                 Subtitle;                                          // 0x0000(0x0010)(Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EDialoguePostion                              SubtitleType;                                      // 0x0010(0x0001)(ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_11[0x7];                                       // 0x0011(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(LevelSequenceSubtitle_SetSubtitle) == 0x000008, "Wrong alignment on LevelSequenceSubtitle_SetSubtitle");
static_assert(sizeof(LevelSequenceSubtitle_SetSubtitle) == 0x000018, "Wrong size on LevelSequenceSubtitle_SetSubtitle");
static_assert(offsetof(LevelSequenceSubtitle_SetSubtitle, Subtitle) == 0x000000, "Member 'LevelSequenceSubtitle_SetSubtitle::Subtitle' has a wrong offset!");
static_assert(offsetof(LevelSequenceSubtitle_SetSubtitle, SubtitleType) == 0x000010, "Member 'LevelSequenceSubtitle_SetSubtitle::SubtitleType' has a wrong offset!");

// Function MirMobile.MM_PageIndicator.CreatePageIndicator
// 0x0004 (0x0004 - 0x0000)
struct MM_PageIndicator_CreatePageIndicator final
{
public:
	int32                                         IndicatorLength;                                   // 0x0000(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(MM_PageIndicator_CreatePageIndicator) == 0x000004, "Wrong alignment on MM_PageIndicator_CreatePageIndicator");
static_assert(sizeof(MM_PageIndicator_CreatePageIndicator) == 0x000004, "Wrong size on MM_PageIndicator_CreatePageIndicator");
static_assert(offsetof(MM_PageIndicator_CreatePageIndicator, IndicatorLength) == 0x000000, "Member 'MM_PageIndicator_CreatePageIndicator::IndicatorLength' has a wrong offset!");

// Function MirMobile.MM_PageIndicator.OnClickIndicator
// 0x0008 (0x0008 - 0x0000)
struct MM_PageIndicator_OnClickIndicator final
{
public:
	int32                                         PageIndex;                                         // 0x0000(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          ReturnValue;                                       // 0x0004(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_5[0x3];                                        // 0x0005(0x0003)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(MM_PageIndicator_OnClickIndicator) == 0x000004, "Wrong alignment on MM_PageIndicator_OnClickIndicator");
static_assert(sizeof(MM_PageIndicator_OnClickIndicator) == 0x000008, "Wrong size on MM_PageIndicator_OnClickIndicator");
static_assert(offsetof(MM_PageIndicator_OnClickIndicator, PageIndex) == 0x000000, "Member 'MM_PageIndicator_OnClickIndicator::PageIndex' has a wrong offset!");
static_assert(offsetof(MM_PageIndicator_OnClickIndicator, ReturnValue) == 0x000004, "Member 'MM_PageIndicator_OnClickIndicator::ReturnValue' has a wrong offset!");

// Function MirMobile.MM_PageIndicator.OnIndicator
// 0x0004 (0x0004 - 0x0000)
struct MM_PageIndicator_OnIndicator final
{
public:
	int32                                         IndicatorIndex;                                    // 0x0000(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(MM_PageIndicator_OnIndicator) == 0x000004, "Wrong alignment on MM_PageIndicator_OnIndicator");
static_assert(sizeof(MM_PageIndicator_OnIndicator) == 0x000004, "Wrong size on MM_PageIndicator_OnIndicator");
static_assert(offsetof(MM_PageIndicator_OnIndicator, IndicatorIndex) == 0x000000, "Member 'MM_PageIndicator_OnIndicator::IndicatorIndex' has a wrong offset!");

// Function MirMobile.MM_Customizing_List.CreateListItem
// 0x0018 (0x0018 - 0x0000)
struct MM_Customizing_List_CreateListItem final
{
public:
	int32                                         Count;                                             // 0x0000(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_4[0x4];                                        // 0x0004(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<class UMM_Customizing_ListItem*>       ReturnValue;                                       // 0x0008(0x0010)(ExportObject, Parm, OutParm, ZeroConstructor, ReturnParm, ContainsInstancedReference, NativeAccessSpecifierPublic)
};
static_assert(alignof(MM_Customizing_List_CreateListItem) == 0x000008, "Wrong alignment on MM_Customizing_List_CreateListItem");
static_assert(sizeof(MM_Customizing_List_CreateListItem) == 0x000018, "Wrong size on MM_Customizing_List_CreateListItem");
static_assert(offsetof(MM_Customizing_List_CreateListItem, Count) == 0x000000, "Member 'MM_Customizing_List_CreateListItem::Count' has a wrong offset!");
static_assert(offsetof(MM_Customizing_List_CreateListItem, ReturnValue) == 0x000008, "Member 'MM_Customizing_List_CreateListItem::ReturnValue' has a wrong offset!");

// Function MirMobile.MM_Customizing_List.OnClickListItemEvent
// 0x0004 (0x0004 - 0x0000)
struct MM_Customizing_List_OnClickListItemEvent final
{
public:
	int32                                         ListIndex;                                         // 0x0000(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(MM_Customizing_List_OnClickListItemEvent) == 0x000004, "Wrong alignment on MM_Customizing_List_OnClickListItemEvent");
static_assert(sizeof(MM_Customizing_List_OnClickListItemEvent) == 0x000004, "Wrong size on MM_Customizing_List_OnClickListItemEvent");
static_assert(offsetof(MM_Customizing_List_OnClickListItemEvent, ListIndex) == 0x000000, "Member 'MM_Customizing_List_OnClickListItemEvent::ListIndex' has a wrong offset!");

// Function MirMobile.MM_Customizing_List.OnClickSubCategoryEvent
// 0x0004 (0x0004 - 0x0000)
struct MM_Customizing_List_OnClickSubCategoryEvent final
{
public:
	int32                                         SubCategoryIndex;                                  // 0x0000(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(MM_Customizing_List_OnClickSubCategoryEvent) == 0x000004, "Wrong alignment on MM_Customizing_List_OnClickSubCategoryEvent");
static_assert(sizeof(MM_Customizing_List_OnClickSubCategoryEvent) == 0x000004, "Wrong size on MM_Customizing_List_OnClickSubCategoryEvent");
static_assert(offsetof(MM_Customizing_List_OnClickSubCategoryEvent, SubCategoryIndex) == 0x000000, "Member 'MM_Customizing_List_OnClickSubCategoryEvent::SubCategoryIndex' has a wrong offset!");

// Function MirMobile.MM_Customizing_List.UpdateListSelectData
// 0x0004 (0x0004 - 0x0000)
struct MM_Customizing_List_UpdateListSelectData final
{
public:
	int32                                         ListIndex;                                         // 0x0000(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(MM_Customizing_List_UpdateListSelectData) == 0x000004, "Wrong alignment on MM_Customizing_List_UpdateListSelectData");
static_assert(sizeof(MM_Customizing_List_UpdateListSelectData) == 0x000004, "Wrong size on MM_Customizing_List_UpdateListSelectData");
static_assert(offsetof(MM_Customizing_List_UpdateListSelectData, ListIndex) == 0x000000, "Member 'MM_Customizing_List_UpdateListSelectData::ListIndex' has a wrong offset!");

// Function MirMobile.LimitTimerWidget.ConfirmCharge
// 0x0004 (0x0004 - 0x0000)
struct LimitTimerWidget_ConfirmCharge final
{
public:
	int32                                         TicketID;                                          // 0x0000(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(LimitTimerWidget_ConfirmCharge) == 0x000004, "Wrong alignment on LimitTimerWidget_ConfirmCharge");
static_assert(sizeof(LimitTimerWidget_ConfirmCharge) == 0x000004, "Wrong size on LimitTimerWidget_ConfirmCharge");
static_assert(offsetof(LimitTimerWidget_ConfirmCharge, TicketID) == 0x000000, "Member 'LimitTimerWidget_ConfirmCharge::TicketID' has a wrong offset!");

// Function MirMobile.LimitTimerWidget.ConfirmChargeByItem
// 0x0004 (0x0004 - 0x0000)
struct LimitTimerWidget_ConfirmChargeByItem final
{
public:
	int32                                         PayTicketID;                                       // 0x0000(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(LimitTimerWidget_ConfirmChargeByItem) == 0x000004, "Wrong alignment on LimitTimerWidget_ConfirmChargeByItem");
static_assert(sizeof(LimitTimerWidget_ConfirmChargeByItem) == 0x000004, "Wrong size on LimitTimerWidget_ConfirmChargeByItem");
static_assert(offsetof(LimitTimerWidget_ConfirmChargeByItem, PayTicketID) == 0x000000, "Member 'LimitTimerWidget_ConfirmChargeByItem::PayTicketID' has a wrong offset!");

// Function MirMobile.MM_Popup_GuildDonation.OnChangeCount
// 0x0008 (0x0008 - 0x0000)
struct MM_Popup_GuildDonation_OnChangeCount final
{
public:
	int64                                         Count_;                                            // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(MM_Popup_GuildDonation_OnChangeCount) == 0x000008, "Wrong alignment on MM_Popup_GuildDonation_OnChangeCount");
static_assert(sizeof(MM_Popup_GuildDonation_OnChangeCount) == 0x000008, "Wrong size on MM_Popup_GuildDonation_OnChangeCount");
static_assert(offsetof(MM_Popup_GuildDonation_OnChangeCount, Count_) == 0x000000, "Member 'MM_Popup_GuildDonation_OnChangeCount::Count_' has a wrong offset!");

// Function MirMobile.MiniGame_BackgroundActor.ReadyBackgroundRemove_BP
// 0x0008 (0x0008 - 0x0000)
struct MiniGame_BackgroundActor_ReadyBackgroundRemove_BP final
{
public:
	int32                                         MaxRight;                                          // 0x0000(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         ReturnValue;                                       // 0x0004(0x0004)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(MiniGame_BackgroundActor_ReadyBackgroundRemove_BP) == 0x000004, "Wrong alignment on MiniGame_BackgroundActor_ReadyBackgroundRemove_BP");
static_assert(sizeof(MiniGame_BackgroundActor_ReadyBackgroundRemove_BP) == 0x000008, "Wrong size on MiniGame_BackgroundActor_ReadyBackgroundRemove_BP");
static_assert(offsetof(MiniGame_BackgroundActor_ReadyBackgroundRemove_BP, MaxRight) == 0x000000, "Member 'MiniGame_BackgroundActor_ReadyBackgroundRemove_BP::MaxRight' has a wrong offset!");
static_assert(offsetof(MiniGame_BackgroundActor_ReadyBackgroundRemove_BP, ReturnValue) == 0x000004, "Member 'MiniGame_BackgroundActor_ReadyBackgroundRemove_BP::ReturnValue' has a wrong offset!");

// Function MirMobile.MM_Customizing_Slider_ControlBar.OnClickSlider
// 0x0004 (0x0004 - 0x0000)
struct MM_Customizing_Slider_ControlBar_OnClickSlider final
{
public:
	float                                         PosX;                                              // 0x0000(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(MM_Customizing_Slider_ControlBar_OnClickSlider) == 0x000004, "Wrong alignment on MM_Customizing_Slider_ControlBar_OnClickSlider");
static_assert(sizeof(MM_Customizing_Slider_ControlBar_OnClickSlider) == 0x000004, "Wrong size on MM_Customizing_Slider_ControlBar_OnClickSlider");
static_assert(offsetof(MM_Customizing_Slider_ControlBar_OnClickSlider, PosX) == 0x000000, "Member 'MM_Customizing_Slider_ControlBar_OnClickSlider::PosX' has a wrong offset!");

// Function MirMobile.MM_Customizing_Slider_ControlBar.OnDragControlButton
// 0x0008 (0x0008 - 0x0000)
struct MM_Customizing_Slider_ControlBar_OnDragControlButton final
{
public:
	struct FVector2D                              DragX;                                             // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(MM_Customizing_Slider_ControlBar_OnDragControlButton) == 0x000004, "Wrong alignment on MM_Customizing_Slider_ControlBar_OnDragControlButton");
static_assert(sizeof(MM_Customizing_Slider_ControlBar_OnDragControlButton) == 0x000008, "Wrong size on MM_Customizing_Slider_ControlBar_OnDragControlButton");
static_assert(offsetof(MM_Customizing_Slider_ControlBar_OnDragControlButton, DragX) == 0x000000, "Member 'MM_Customizing_Slider_ControlBar_OnDragControlButton::DragX' has a wrong offset!");

// Function MirMobile.MM_Customizing_Slider_ControlBar.OnReleasedControlButton
// 0x0008 (0x0008 - 0x0000)
struct MM_Customizing_Slider_ControlBar_OnReleasedControlButton final
{
public:
	struct FVector2D                              DragLoc;                                           // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(MM_Customizing_Slider_ControlBar_OnReleasedControlButton) == 0x000004, "Wrong alignment on MM_Customizing_Slider_ControlBar_OnReleasedControlButton");
static_assert(sizeof(MM_Customizing_Slider_ControlBar_OnReleasedControlButton) == 0x000008, "Wrong size on MM_Customizing_Slider_ControlBar_OnReleasedControlButton");
static_assert(offsetof(MM_Customizing_Slider_ControlBar_OnReleasedControlButton, DragLoc) == 0x000000, "Member 'MM_Customizing_Slider_ControlBar_OnReleasedControlButton::DragLoc' has a wrong offset!");

// Function MirMobile.MM_Customizing_Slider_ControlBar.SetControlSlider
// 0x0004 (0x0004 - 0x0000)
struct MM_Customizing_Slider_ControlBar_SetControlSlider final
{
public:
	float                                         PosX;                                              // 0x0000(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(MM_Customizing_Slider_ControlBar_SetControlSlider) == 0x000004, "Wrong alignment on MM_Customizing_Slider_ControlBar_SetControlSlider");
static_assert(sizeof(MM_Customizing_Slider_ControlBar_SetControlSlider) == 0x000004, "Wrong size on MM_Customizing_Slider_ControlBar_SetControlSlider");
static_assert(offsetof(MM_Customizing_Slider_ControlBar_SetControlSlider, PosX) == 0x000000, "Member 'MM_Customizing_Slider_ControlBar_SetControlSlider::PosX' has a wrong offset!");

// Function MirMobile.MM_Customizing_Slider_ControlBar.UpdateSliderValue
// 0x0004 (0x0004 - 0x0000)
struct MM_Customizing_Slider_ControlBar_UpdateSliderValue final
{
public:
	int32                                         SliderValue;                                       // 0x0000(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(MM_Customizing_Slider_ControlBar_UpdateSliderValue) == 0x000004, "Wrong alignment on MM_Customizing_Slider_ControlBar_UpdateSliderValue");
static_assert(sizeof(MM_Customizing_Slider_ControlBar_UpdateSliderValue) == 0x000004, "Wrong size on MM_Customizing_Slider_ControlBar_UpdateSliderValue");
static_assert(offsetof(MM_Customizing_Slider_ControlBar_UpdateSliderValue, SliderValue) == 0x000000, "Member 'MM_Customizing_Slider_ControlBar_UpdateSliderValue::SliderValue' has a wrong offset!");

// Function MirMobile.MiniGame_ManagerActor.PlayMiniGameSound
// 0x0001 (0x0001 - 0x0000)
struct MiniGame_ManagerActor_PlayMiniGameSound final
{
public:
	EMiniGameSoundType                            ESoundType;                                        // 0x0000(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(MiniGame_ManagerActor_PlayMiniGameSound) == 0x000001, "Wrong alignment on MiniGame_ManagerActor_PlayMiniGameSound");
static_assert(sizeof(MiniGame_ManagerActor_PlayMiniGameSound) == 0x000001, "Wrong size on MiniGame_ManagerActor_PlayMiniGameSound");
static_assert(offsetof(MiniGame_ManagerActor_PlayMiniGameSound, ESoundType) == 0x000000, "Member 'MiniGame_ManagerActor_PlayMiniGameSound::ESoundType' has a wrong offset!");

// Function MirMobile.MiniGame_ManagerActor.PlayMiniGameSound_BP
// 0x0001 (0x0001 - 0x0000)
struct MiniGame_ManagerActor_PlayMiniGameSound_BP final
{
public:
	EMiniGameSoundType                            ESoundType;                                        // 0x0000(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(MiniGame_ManagerActor_PlayMiniGameSound_BP) == 0x000001, "Wrong alignment on MiniGame_ManagerActor_PlayMiniGameSound_BP");
static_assert(sizeof(MiniGame_ManagerActor_PlayMiniGameSound_BP) == 0x000001, "Wrong size on MiniGame_ManagerActor_PlayMiniGameSound_BP");
static_assert(offsetof(MiniGame_ManagerActor_PlayMiniGameSound_BP, ESoundType) == 0x000000, "Member 'MiniGame_ManagerActor_PlayMiniGameSound_BP::ESoundType' has a wrong offset!");

// Function MirMobile.MiniGame_ManagerActor.ResetGameMapLocation_BP
// 0x0004 (0x0004 - 0x0000)
struct MiniGame_ManagerActor_ResetGameMapLocation_BP final
{
public:
	float                                         FGapValue;                                         // 0x0000(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(MiniGame_ManagerActor_ResetGameMapLocation_BP) == 0x000004, "Wrong alignment on MiniGame_ManagerActor_ResetGameMapLocation_BP");
static_assert(sizeof(MiniGame_ManagerActor_ResetGameMapLocation_BP) == 0x000004, "Wrong size on MiniGame_ManagerActor_ResetGameMapLocation_BP");
static_assert(offsetof(MiniGame_ManagerActor_ResetGameMapLocation_BP, FGapValue) == 0x000000, "Member 'MiniGame_ManagerActor_ResetGameMapLocation_BP::FGapValue' has a wrong offset!");

// Function MirMobile.MiniGame_ManagerActor.SpawnBackground_BP
// 0x0010 (0x0010 - 0x0000)
struct MiniGame_ManagerActor_SpawnBackground_BP final
{
public:
	float                                         SpawnPos;                                          // 0x0000(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_4[0x4];                                        // 0x0004(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class AMiniGame_BackgroundActor*              ReturnValue;                                       // 0x0008(0x0008)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(MiniGame_ManagerActor_SpawnBackground_BP) == 0x000008, "Wrong alignment on MiniGame_ManagerActor_SpawnBackground_BP");
static_assert(sizeof(MiniGame_ManagerActor_SpawnBackground_BP) == 0x000010, "Wrong size on MiniGame_ManagerActor_SpawnBackground_BP");
static_assert(offsetof(MiniGame_ManagerActor_SpawnBackground_BP, SpawnPos) == 0x000000, "Member 'MiniGame_ManagerActor_SpawnBackground_BP::SpawnPos' has a wrong offset!");
static_assert(offsetof(MiniGame_ManagerActor_SpawnBackground_BP, ReturnValue) == 0x000008, "Member 'MiniGame_ManagerActor_SpawnBackground_BP::ReturnValue' has a wrong offset!");

// Function MirMobile.MiniGame_ManagerActor.SpawnMonster
// 0x0010 (0x0010 - 0x0000)
struct MiniGame_ManagerActor_SpawnMonster final
{
public:
	float                                         SpawnPos;                                          // 0x0000(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_4[0x4];                                        // 0x0004(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class AMiniGame_MonsterActor*                 ReturnValue;                                       // 0x0008(0x0008)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(MiniGame_ManagerActor_SpawnMonster) == 0x000008, "Wrong alignment on MiniGame_ManagerActor_SpawnMonster");
static_assert(sizeof(MiniGame_ManagerActor_SpawnMonster) == 0x000010, "Wrong size on MiniGame_ManagerActor_SpawnMonster");
static_assert(offsetof(MiniGame_ManagerActor_SpawnMonster, SpawnPos) == 0x000000, "Member 'MiniGame_ManagerActor_SpawnMonster::SpawnPos' has a wrong offset!");
static_assert(offsetof(MiniGame_ManagerActor_SpawnMonster, ReturnValue) == 0x000008, "Member 'MiniGame_ManagerActor_SpawnMonster::ReturnValue' has a wrong offset!");

// Function MirMobile.MiniGame_PlayerActor.ChangeFlipbook_BP
// 0x0002 (0x0002 - 0x0000)
struct MiniGame_PlayerActor_ChangeFlipbook_BP final
{
public:
	EMiniGamePlayerState                          EState;                                            // 0x0000(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EMiniGamePlayerMoveDirection                  EDirection;                                        // 0x0001(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(MiniGame_PlayerActor_ChangeFlipbook_BP) == 0x000001, "Wrong alignment on MiniGame_PlayerActor_ChangeFlipbook_BP");
static_assert(sizeof(MiniGame_PlayerActor_ChangeFlipbook_BP) == 0x000002, "Wrong size on MiniGame_PlayerActor_ChangeFlipbook_BP");
static_assert(offsetof(MiniGame_PlayerActor_ChangeFlipbook_BP, EState) == 0x000000, "Member 'MiniGame_PlayerActor_ChangeFlipbook_BP::EState' has a wrong offset!");
static_assert(offsetof(MiniGame_PlayerActor_ChangeFlipbook_BP, EDirection) == 0x000001, "Member 'MiniGame_PlayerActor_ChangeFlipbook_BP::EDirection' has a wrong offset!");

// Function MirMobile.MiniGame_PlayerActor.GetMiniGameActor
// 0x0008 (0x0008 - 0x0000)
struct MiniGame_PlayerActor_GetMiniGameActor final
{
public:
	class AMiniGame_ManagerActor*                 ReturnValue;                                       // 0x0000(0x0008)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(MiniGame_PlayerActor_GetMiniGameActor) == 0x000008, "Wrong alignment on MiniGame_PlayerActor_GetMiniGameActor");
static_assert(sizeof(MiniGame_PlayerActor_GetMiniGameActor) == 0x000008, "Wrong size on MiniGame_PlayerActor_GetMiniGameActor");
static_assert(offsetof(MiniGame_PlayerActor_GetMiniGameActor, ReturnValue) == 0x000000, "Member 'MiniGame_PlayerActor_GetMiniGameActor::ReturnValue' has a wrong offset!");

// Function MirMobile.MiniGame_PlayerActor.PauseFilpbook_BP
// 0x0001 (0x0001 - 0x0000)
struct MiniGame_PlayerActor_PauseFilpbook_BP final
{
public:
	bool                                          bPause;                                            // 0x0000(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(MiniGame_PlayerActor_PauseFilpbook_BP) == 0x000001, "Wrong alignment on MiniGame_PlayerActor_PauseFilpbook_BP");
static_assert(sizeof(MiniGame_PlayerActor_PauseFilpbook_BP) == 0x000001, "Wrong size on MiniGame_PlayerActor_PauseFilpbook_BP");
static_assert(offsetof(MiniGame_PlayerActor_PauseFilpbook_BP, bPause) == 0x000000, "Member 'MiniGame_PlayerActor_PauseFilpbook_BP::bPause' has a wrong offset!");

// Function MirMobile.MiniGame_PlayerActor.ShowAttackEffectFilpbook_BP
// 0x0020 (0x0020 - 0x0000)
struct MiniGame_PlayerActor_ShowAttackEffectFilpbook_BP final
{
public:
	EMiniGamePlayerState                          EState;                                            // 0x0000(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1[0x3];                                        // 0x0001(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	struct FVector                                VScale;                                            // 0x0004(0x000C)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                VLoc;                                              // 0x0010(0x000C)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         FDelay;                                            // 0x001C(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(MiniGame_PlayerActor_ShowAttackEffectFilpbook_BP) == 0x000004, "Wrong alignment on MiniGame_PlayerActor_ShowAttackEffectFilpbook_BP");
static_assert(sizeof(MiniGame_PlayerActor_ShowAttackEffectFilpbook_BP) == 0x000020, "Wrong size on MiniGame_PlayerActor_ShowAttackEffectFilpbook_BP");
static_assert(offsetof(MiniGame_PlayerActor_ShowAttackEffectFilpbook_BP, EState) == 0x000000, "Member 'MiniGame_PlayerActor_ShowAttackEffectFilpbook_BP::EState' has a wrong offset!");
static_assert(offsetof(MiniGame_PlayerActor_ShowAttackEffectFilpbook_BP, VScale) == 0x000004, "Member 'MiniGame_PlayerActor_ShowAttackEffectFilpbook_BP::VScale' has a wrong offset!");
static_assert(offsetof(MiniGame_PlayerActor_ShowAttackEffectFilpbook_BP, VLoc) == 0x000010, "Member 'MiniGame_PlayerActor_ShowAttackEffectFilpbook_BP::VLoc' has a wrong offset!");
static_assert(offsetof(MiniGame_PlayerActor_ShowAttackEffectFilpbook_BP, FDelay) == 0x00001C, "Member 'MiniGame_PlayerActor_ShowAttackEffectFilpbook_BP::FDelay' has a wrong offset!");

// Function MirMobile.MiniGame_PlayerActor.ShowHitEffectFilpbook_BP
// 0x001C (0x001C - 0x0000)
struct MiniGame_PlayerActor_ShowHitEffectFilpbook_BP final
{
public:
	struct FVector                                VScale;                                            // 0x0000(0x000C)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                VLoc;                                              // 0x000C(0x000C)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         FDelay;                                            // 0x0018(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(MiniGame_PlayerActor_ShowHitEffectFilpbook_BP) == 0x000004, "Wrong alignment on MiniGame_PlayerActor_ShowHitEffectFilpbook_BP");
static_assert(sizeof(MiniGame_PlayerActor_ShowHitEffectFilpbook_BP) == 0x00001C, "Wrong size on MiniGame_PlayerActor_ShowHitEffectFilpbook_BP");
static_assert(offsetof(MiniGame_PlayerActor_ShowHitEffectFilpbook_BP, VScale) == 0x000000, "Member 'MiniGame_PlayerActor_ShowHitEffectFilpbook_BP::VScale' has a wrong offset!");
static_assert(offsetof(MiniGame_PlayerActor_ShowHitEffectFilpbook_BP, VLoc) == 0x00000C, "Member 'MiniGame_PlayerActor_ShowHitEffectFilpbook_BP::VLoc' has a wrong offset!");
static_assert(offsetof(MiniGame_PlayerActor_ShowHitEffectFilpbook_BP, FDelay) == 0x000018, "Member 'MiniGame_PlayerActor_ShowHitEffectFilpbook_BP::FDelay' has a wrong offset!");

// Function MirMobile.MM_CustomizingDataActor.DuplicateSkeletalMesh
// 0x0010 (0x0010 - 0x0000)
struct MM_CustomizingDataActor_DuplicateSkeletalMesh final
{
public:
	class USkeletalMesh*                          SkeletalMesh;                                      // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class USkeletalMesh*                          ReturnValue;                                       // 0x0008(0x0008)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(MM_CustomizingDataActor_DuplicateSkeletalMesh) == 0x000008, "Wrong alignment on MM_CustomizingDataActor_DuplicateSkeletalMesh");
static_assert(sizeof(MM_CustomizingDataActor_DuplicateSkeletalMesh) == 0x000010, "Wrong size on MM_CustomizingDataActor_DuplicateSkeletalMesh");
static_assert(offsetof(MM_CustomizingDataActor_DuplicateSkeletalMesh, SkeletalMesh) == 0x000000, "Member 'MM_CustomizingDataActor_DuplicateSkeletalMesh::SkeletalMesh' has a wrong offset!");
static_assert(offsetof(MM_CustomizingDataActor_DuplicateSkeletalMesh, ReturnValue) == 0x000008, "Member 'MM_CustomizingDataActor_DuplicateSkeletalMesh::ReturnValue' has a wrong offset!");

// Function MirMobile.MM_CustomizingDataActor.GetCameraData
// 0x0020 (0x0020 - 0x0000)
struct MM_CustomizingDataActor_GetCameraData final
{
public:
	TArray<struct FTransform>                     CameraTransform;                                   // 0x0000(0x0010)(Parm, OutParm, ZeroConstructor, NativeAccessSpecifierPublic)
	TArray<float>                                 CameraFov;                                         // 0x0010(0x0010)(Parm, OutParm, ZeroConstructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(MM_CustomizingDataActor_GetCameraData) == 0x000008, "Wrong alignment on MM_CustomizingDataActor_GetCameraData");
static_assert(sizeof(MM_CustomizingDataActor_GetCameraData) == 0x000020, "Wrong size on MM_CustomizingDataActor_GetCameraData");
static_assert(offsetof(MM_CustomizingDataActor_GetCameraData, CameraTransform) == 0x000000, "Member 'MM_CustomizingDataActor_GetCameraData::CameraTransform' has a wrong offset!");
static_assert(offsetof(MM_CustomizingDataActor_GetCameraData, CameraFov) == 0x000010, "Member 'MM_CustomizingDataActor_GetCameraData::CameraFov' has a wrong offset!");

// Function MirMobile.MM_CustomizingDataActor.GetLimitValue
// 0x000C (0x000C - 0x0000)
struct MM_CustomizingDataActor_GetLimitValue final
{
public:
	float                                         HeadLimitYaw;                                      // 0x0000(0x0004)(Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         EyeLimitYaw;                                       // 0x0004(0x0004)(Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         EyeLimitPitch;                                     // 0x0008(0x0004)(Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(MM_CustomizingDataActor_GetLimitValue) == 0x000004, "Wrong alignment on MM_CustomizingDataActor_GetLimitValue");
static_assert(sizeof(MM_CustomizingDataActor_GetLimitValue) == 0x00000C, "Wrong size on MM_CustomizingDataActor_GetLimitValue");
static_assert(offsetof(MM_CustomizingDataActor_GetLimitValue, HeadLimitYaw) == 0x000000, "Member 'MM_CustomizingDataActor_GetLimitValue::HeadLimitYaw' has a wrong offset!");
static_assert(offsetof(MM_CustomizingDataActor_GetLimitValue, EyeLimitYaw) == 0x000004, "Member 'MM_CustomizingDataActor_GetLimitValue::EyeLimitYaw' has a wrong offset!");
static_assert(offsetof(MM_CustomizingDataActor_GetLimitValue, EyeLimitPitch) == 0x000008, "Member 'MM_CustomizingDataActor_GetLimitValue::EyeLimitPitch' has a wrong offset!");

// Function MirMobile.MM_CustomizingDataActor.GetSpringControlValue
// 0x0020 (0x0020 - 0x0000)
struct MM_CustomizingDataActor_GetSpringControlValue final
{
public:
	TArray<float>                                 StiffnessArray;                                    // 0x0000(0x0010)(Parm, OutParm, ZeroConstructor, NativeAccessSpecifierPublic)
	TArray<float>                                 Damping;                                           // 0x0010(0x0010)(Parm, OutParm, ZeroConstructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(MM_CustomizingDataActor_GetSpringControlValue) == 0x000008, "Wrong alignment on MM_CustomizingDataActor_GetSpringControlValue");
static_assert(sizeof(MM_CustomizingDataActor_GetSpringControlValue) == 0x000020, "Wrong size on MM_CustomizingDataActor_GetSpringControlValue");
static_assert(offsetof(MM_CustomizingDataActor_GetSpringControlValue, StiffnessArray) == 0x000000, "Member 'MM_CustomizingDataActor_GetSpringControlValue::StiffnessArray' has a wrong offset!");
static_assert(offsetof(MM_CustomizingDataActor_GetSpringControlValue, Damping) == 0x000010, "Member 'MM_CustomizingDataActor_GetSpringControlValue::Damping' has a wrong offset!");

// Function MirMobile.MM_CustomizingDataActor.GetTotalBoneOffset
// 0x0010 (0x0010 - 0x0000)
struct MM_CustomizingDataActor_GetTotalBoneOffset final
{
public:
	TArray<struct FFinalBoneOffset>               ReturnValue;                                       // 0x0000(0x0010)(Parm, OutParm, ZeroConstructor, ReturnParm, NativeAccessSpecifierPublic)
};
static_assert(alignof(MM_CustomizingDataActor_GetTotalBoneOffset) == 0x000008, "Wrong alignment on MM_CustomizingDataActor_GetTotalBoneOffset");
static_assert(sizeof(MM_CustomizingDataActor_GetTotalBoneOffset) == 0x000010, "Wrong size on MM_CustomizingDataActor_GetTotalBoneOffset");
static_assert(offsetof(MM_CustomizingDataActor_GetTotalBoneOffset, ReturnValue) == 0x000000, "Member 'MM_CustomizingDataActor_GetTotalBoneOffset::ReturnValue' has a wrong offset!");

// Function MirMobile.MM_CustomizingDataActor.SetControlData
// 0x0018 (0x0018 - 0x0000)
struct MM_CustomizingDataActor_SetControlData final
{
public:
	class FString                                 StrKey;                                            // 0x0000(0x0010)(Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         SlideValue;                                        // 0x0010(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_14[0x4];                                       // 0x0014(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(MM_CustomizingDataActor_SetControlData) == 0x000008, "Wrong alignment on MM_CustomizingDataActor_SetControlData");
static_assert(sizeof(MM_CustomizingDataActor_SetControlData) == 0x000018, "Wrong size on MM_CustomizingDataActor_SetControlData");
static_assert(offsetof(MM_CustomizingDataActor_SetControlData, StrKey) == 0x000000, "Member 'MM_CustomizingDataActor_SetControlData::StrKey' has a wrong offset!");
static_assert(offsetof(MM_CustomizingDataActor_SetControlData, SlideValue) == 0x000010, "Member 'MM_CustomizingDataActor_SetControlData::SlideValue' has a wrong offset!");

// Function MirMobile.MiniMapNaviDataExporter.ExportJsonData
// 0x0028 (0x0028 - 0x0000)
struct MiniMapNaviDataExporter_ExportJsonData final
{
public:
	struct FVector                                StartPoint;                                        // 0x0000(0x000C)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         TileSize;                                          // 0x000C(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         TileLineCount;                                     // 0x0010(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_14[0x4];                                       // 0x0014(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<bool>                                  NaviTileArray;                                     // 0x0018(0x0010)(Parm, ZeroConstructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(MiniMapNaviDataExporter_ExportJsonData) == 0x000008, "Wrong alignment on MiniMapNaviDataExporter_ExportJsonData");
static_assert(sizeof(MiniMapNaviDataExporter_ExportJsonData) == 0x000028, "Wrong size on MiniMapNaviDataExporter_ExportJsonData");
static_assert(offsetof(MiniMapNaviDataExporter_ExportJsonData, StartPoint) == 0x000000, "Member 'MiniMapNaviDataExporter_ExportJsonData::StartPoint' has a wrong offset!");
static_assert(offsetof(MiniMapNaviDataExporter_ExportJsonData, TileSize) == 0x00000C, "Member 'MiniMapNaviDataExporter_ExportJsonData::TileSize' has a wrong offset!");
static_assert(offsetof(MiniMapNaviDataExporter_ExportJsonData, TileLineCount) == 0x000010, "Member 'MiniMapNaviDataExporter_ExportJsonData::TileLineCount' has a wrong offset!");
static_assert(offsetof(MiniMapNaviDataExporter_ExportJsonData, NaviTileArray) == 0x000018, "Member 'MiniMapNaviDataExporter_ExportJsonData::NaviTileArray' has a wrong offset!");

// Function MirMobile.MiniMapNaviDataExporter.GetLevelName
// 0x0010 (0x0010 - 0x0000)
struct MiniMapNaviDataExporter_GetLevelName final
{
public:
	class FString                                 ReturnValue;                                       // 0x0000(0x0010)(Parm, OutParm, ZeroConstructor, ReturnParm, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(MiniMapNaviDataExporter_GetLevelName) == 0x000008, "Wrong alignment on MiniMapNaviDataExporter_GetLevelName");
static_assert(sizeof(MiniMapNaviDataExporter_GetLevelName) == 0x000010, "Wrong size on MiniMapNaviDataExporter_GetLevelName");
static_assert(offsetof(MiniMapNaviDataExporter_GetLevelName, ReturnValue) == 0x000000, "Member 'MiniMapNaviDataExporter_GetLevelName::ReturnValue' has a wrong offset!");

// Function MirMobile.MirEditableText.OnEditableTxtTitleCommitted
// 0x0020 (0x0020 - 0x0000)
struct MirEditableText_OnEditableTxtTitleCommitted final
{
public:
	class FText                                   Text_;                                             // 0x0000(0x0018)(ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
	ETextCommit                                   Commit_method_;                                    // 0x0018(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_19[0x7];                                       // 0x0019(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(MirEditableText_OnEditableTxtTitleCommitted) == 0x000008, "Wrong alignment on MirEditableText_OnEditableTxtTitleCommitted");
static_assert(sizeof(MirEditableText_OnEditableTxtTitleCommitted) == 0x000020, "Wrong size on MirEditableText_OnEditableTxtTitleCommitted");
static_assert(offsetof(MirEditableText_OnEditableTxtTitleCommitted, Text_) == 0x000000, "Member 'MirEditableText_OnEditableTxtTitleCommitted::Text_' has a wrong offset!");
static_assert(offsetof(MirEditableText_OnEditableTxtTitleCommitted, Commit_method_) == 0x000018, "Member 'MirEditableText_OnEditableTxtTitleCommitted::Commit_method_' has a wrong offset!");

// Function MirMobile.MirEditorBlueprintLibrary.ExportSpriteInfo
// 0x0050 (0x0050 - 0x0000)
struct MirEditorBlueprintLibrary_ExportSpriteInfo final
{
public:
	TMap<int32, class FString>                    IconIDAndPath;                                     // 0x0000(0x0050)(ConstParm, Parm, ZeroConstructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(MirEditorBlueprintLibrary_ExportSpriteInfo) == 0x000008, "Wrong alignment on MirEditorBlueprintLibrary_ExportSpriteInfo");
static_assert(sizeof(MirEditorBlueprintLibrary_ExportSpriteInfo) == 0x000050, "Wrong size on MirEditorBlueprintLibrary_ExportSpriteInfo");
static_assert(offsetof(MirEditorBlueprintLibrary_ExportSpriteInfo, IconIDAndPath) == 0x000000, "Member 'MirEditorBlueprintLibrary_ExportSpriteInfo::IconIDAndPath' has a wrong offset!");

// Function MirMobile.MM_CustomTitleSwitching.OnClickTitleBase
// 0x0001 (0x0001 - 0x0000)
struct MM_CustomTitleSwitching_OnClickTitleBase final
{
public:
	bool                                          bState;                                            // 0x0000(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(MM_CustomTitleSwitching_OnClickTitleBase) == 0x000001, "Wrong alignment on MM_CustomTitleSwitching_OnClickTitleBase");
static_assert(sizeof(MM_CustomTitleSwitching_OnClickTitleBase) == 0x000001, "Wrong size on MM_CustomTitleSwitching_OnClickTitleBase");
static_assert(offsetof(MM_CustomTitleSwitching_OnClickTitleBase, bState) == 0x000000, "Member 'MM_CustomTitleSwitching_OnClickTitleBase::bState' has a wrong offset!");

// Function MirMobile.MM_CustomTitleSwitching.OnClickTitleUse
// 0x0001 (0x0001 - 0x0000)
struct MM_CustomTitleSwitching_OnClickTitleUse final
{
public:
	bool                                          bState;                                            // 0x0000(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(MM_CustomTitleSwitching_OnClickTitleUse) == 0x000001, "Wrong alignment on MM_CustomTitleSwitching_OnClickTitleUse");
static_assert(sizeof(MM_CustomTitleSwitching_OnClickTitleUse) == 0x000001, "Wrong size on MM_CustomTitleSwitching_OnClickTitleUse");
static_assert(offsetof(MM_CustomTitleSwitching_OnClickTitleUse, bState) == 0x000000, "Member 'MM_CustomTitleSwitching_OnClickTitleUse::bState' has a wrong offset!");

// Function MirMobile.MM_UserEvent_Siege.OnUseItemCount
// 0x0008 (0x0008 - 0x0000)
struct MM_UserEvent_Siege_OnUseItemCount final
{
public:
	int64                                         INum;                                              // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(MM_UserEvent_Siege_OnUseItemCount) == 0x000008, "Wrong alignment on MM_UserEvent_Siege_OnUseItemCount");
static_assert(sizeof(MM_UserEvent_Siege_OnUseItemCount) == 0x000008, "Wrong size on MM_UserEvent_Siege_OnUseItemCount");
static_assert(offsetof(MM_UserEvent_Siege_OnUseItemCount, INum) == 0x000000, "Member 'MM_UserEvent_Siege_OnUseItemCount::INum' has a wrong offset!");

// Function MirMobile.MirListView.ChangeEntryWidget
// 0x0008 (0x0008 - 0x0000)
struct MirListView_ChangeEntryWidget final
{
public:
	int32                                         IIndex;                                            // 0x0000(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          ReturnValue;                                       // 0x0004(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_5[0x3];                                        // 0x0005(0x0003)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(MirListView_ChangeEntryWidget) == 0x000004, "Wrong alignment on MirListView_ChangeEntryWidget");
static_assert(sizeof(MirListView_ChangeEntryWidget) == 0x000008, "Wrong size on MirListView_ChangeEntryWidget");
static_assert(offsetof(MirListView_ChangeEntryWidget, IIndex) == 0x000000, "Member 'MirListView_ChangeEntryWidget::IIndex' has a wrong offset!");
static_assert(offsetof(MirListView_ChangeEntryWidget, ReturnValue) == 0x000004, "Member 'MirListView_ChangeEntryWidget::ReturnValue' has a wrong offset!");

// Function MirMobile.MM_RelationQuestList.OnClickCategory
// 0x0008 (0x0008 - 0x0000)
struct MM_RelationQuestList_OnClickCategory final
{
public:
	int32                                         SlotIndex;                                         // 0x0000(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bLocked;                                           // 0x0004(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_5[0x3];                                        // 0x0005(0x0003)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(MM_RelationQuestList_OnClickCategory) == 0x000004, "Wrong alignment on MM_RelationQuestList_OnClickCategory");
static_assert(sizeof(MM_RelationQuestList_OnClickCategory) == 0x000008, "Wrong size on MM_RelationQuestList_OnClickCategory");
static_assert(offsetof(MM_RelationQuestList_OnClickCategory, SlotIndex) == 0x000000, "Member 'MM_RelationQuestList_OnClickCategory::SlotIndex' has a wrong offset!");
static_assert(offsetof(MM_RelationQuestList_OnClickCategory, bLocked) == 0x000004, "Member 'MM_RelationQuestList_OnClickCategory::bLocked' has a wrong offset!");

// Function MirMobile.MM_RelationQuestList.OnClickGroup
// 0x0004 (0x0004 - 0x0000)
struct MM_RelationQuestList_OnClickGroup final
{
public:
	int32                                         GroupIndex;                                        // 0x0000(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(MM_RelationQuestList_OnClickGroup) == 0x000004, "Wrong alignment on MM_RelationQuestList_OnClickGroup");
static_assert(sizeof(MM_RelationQuestList_OnClickGroup) == 0x000004, "Wrong size on MM_RelationQuestList_OnClickGroup");
static_assert(offsetof(MM_RelationQuestList_OnClickGroup, GroupIndex) == 0x000000, "Member 'MM_RelationQuestList_OnClickGroup::GroupIndex' has a wrong offset!");

// Function MirMobile.MM_Customizing_Costume_Palette.CreatePaletteItem
// 0x0018 (0x0018 - 0x0000)
struct MM_Customizing_Costume_Palette_CreatePaletteItem final
{
public:
	int32                                         Count;                                             // 0x0000(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_4[0x4];                                        // 0x0004(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<class UMM_Customizing_PaletteItem*>    ReturnValue;                                       // 0x0008(0x0010)(ExportObject, Parm, OutParm, ZeroConstructor, ReturnParm, ContainsInstancedReference, NativeAccessSpecifierPublic)
};
static_assert(alignof(MM_Customizing_Costume_Palette_CreatePaletteItem) == 0x000008, "Wrong alignment on MM_Customizing_Costume_Palette_CreatePaletteItem");
static_assert(sizeof(MM_Customizing_Costume_Palette_CreatePaletteItem) == 0x000018, "Wrong size on MM_Customizing_Costume_Palette_CreatePaletteItem");
static_assert(offsetof(MM_Customizing_Costume_Palette_CreatePaletteItem, Count) == 0x000000, "Member 'MM_Customizing_Costume_Palette_CreatePaletteItem::Count' has a wrong offset!");
static_assert(offsetof(MM_Customizing_Costume_Palette_CreatePaletteItem, ReturnValue) == 0x000008, "Member 'MM_Customizing_Costume_Palette_CreatePaletteItem::ReturnValue' has a wrong offset!");

// Function MirMobile.MM_Customizing_Costume_Palette.OnClickDirectDye_Main
// 0x0004 (0x0004 - 0x0000)
struct MM_Customizing_Costume_Palette_OnClickDirectDye_Main final
{
public:
	int32                                         _None;                                             // 0x0000(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(MM_Customizing_Costume_Palette_OnClickDirectDye_Main) == 0x000004, "Wrong alignment on MM_Customizing_Costume_Palette_OnClickDirectDye_Main");
static_assert(sizeof(MM_Customizing_Costume_Palette_OnClickDirectDye_Main) == 0x000004, "Wrong size on MM_Customizing_Costume_Palette_OnClickDirectDye_Main");
static_assert(offsetof(MM_Customizing_Costume_Palette_OnClickDirectDye_Main, _None) == 0x000000, "Member 'MM_Customizing_Costume_Palette_OnClickDirectDye_Main::_None' has a wrong offset!");

// Function MirMobile.MM_Customizing_Costume_Palette.OnClickDirectDye_Sub
// 0x0004 (0x0004 - 0x0000)
struct MM_Customizing_Costume_Palette_OnClickDirectDye_Sub final
{
public:
	int32                                         _None;                                             // 0x0000(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(MM_Customizing_Costume_Palette_OnClickDirectDye_Sub) == 0x000004, "Wrong alignment on MM_Customizing_Costume_Palette_OnClickDirectDye_Sub");
static_assert(sizeof(MM_Customizing_Costume_Palette_OnClickDirectDye_Sub) == 0x000004, "Wrong size on MM_Customizing_Costume_Palette_OnClickDirectDye_Sub");
static_assert(offsetof(MM_Customizing_Costume_Palette_OnClickDirectDye_Sub, _None) == 0x000000, "Member 'MM_Customizing_Costume_Palette_OnClickDirectDye_Sub::_None' has a wrong offset!");

// Function MirMobile.MM_Customizing_Costume_Palette.OnClickPaletteItemEvent
// 0x0004 (0x0004 - 0x0000)
struct MM_Customizing_Costume_Palette_OnClickPaletteItemEvent final
{
public:
	int32                                         PaletteIndex;                                      // 0x0000(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(MM_Customizing_Costume_Palette_OnClickPaletteItemEvent) == 0x000004, "Wrong alignment on MM_Customizing_Costume_Palette_OnClickPaletteItemEvent");
static_assert(sizeof(MM_Customizing_Costume_Palette_OnClickPaletteItemEvent) == 0x000004, "Wrong size on MM_Customizing_Costume_Palette_OnClickPaletteItemEvent");
static_assert(offsetof(MM_Customizing_Costume_Palette_OnClickPaletteItemEvent, PaletteIndex) == 0x000000, "Member 'MM_Customizing_Costume_Palette_OnClickPaletteItemEvent::PaletteIndex' has a wrong offset!");

// Function MirMobile.MM_Customizing_Costume_Palette.UpdateThumbnailBrightness_Main
// 0x0004 (0x0004 - 0x0000)
struct MM_Customizing_Costume_Palette_UpdateThumbnailBrightness_Main final
{
public:
	int32                                         _Value;                                            // 0x0000(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(MM_Customizing_Costume_Palette_UpdateThumbnailBrightness_Main) == 0x000004, "Wrong alignment on MM_Customizing_Costume_Palette_UpdateThumbnailBrightness_Main");
static_assert(sizeof(MM_Customizing_Costume_Palette_UpdateThumbnailBrightness_Main) == 0x000004, "Wrong size on MM_Customizing_Costume_Palette_UpdateThumbnailBrightness_Main");
static_assert(offsetof(MM_Customizing_Costume_Palette_UpdateThumbnailBrightness_Main, _Value) == 0x000000, "Member 'MM_Customizing_Costume_Palette_UpdateThumbnailBrightness_Main::_Value' has a wrong offset!");

// Function MirMobile.MM_Customizing_Costume_Palette.UpdateThumbnailBrightness_Sub
// 0x0004 (0x0004 - 0x0000)
struct MM_Customizing_Costume_Palette_UpdateThumbnailBrightness_Sub final
{
public:
	int32                                         _Value;                                            // 0x0000(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(MM_Customizing_Costume_Palette_UpdateThumbnailBrightness_Sub) == 0x000004, "Wrong alignment on MM_Customizing_Costume_Palette_UpdateThumbnailBrightness_Sub");
static_assert(sizeof(MM_Customizing_Costume_Palette_UpdateThumbnailBrightness_Sub) == 0x000004, "Wrong size on MM_Customizing_Costume_Palette_UpdateThumbnailBrightness_Sub");
static_assert(offsetof(MM_Customizing_Costume_Palette_UpdateThumbnailBrightness_Sub, _Value) == 0x000000, "Member 'MM_Customizing_Costume_Palette_UpdateThumbnailBrightness_Sub::_Value' has a wrong offset!");

// Function MirMobile.MM_Customizing_Costume_Palette.UpdateThumbnailColorData_Main
// 0x0004 (0x0004 - 0x0000)
struct MM_Customizing_Costume_Palette_UpdateThumbnailColorData_Main final
{
public:
	int32                                         _Value;                                            // 0x0000(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(MM_Customizing_Costume_Palette_UpdateThumbnailColorData_Main) == 0x000004, "Wrong alignment on MM_Customizing_Costume_Palette_UpdateThumbnailColorData_Main");
static_assert(sizeof(MM_Customizing_Costume_Palette_UpdateThumbnailColorData_Main) == 0x000004, "Wrong size on MM_Customizing_Costume_Palette_UpdateThumbnailColorData_Main");
static_assert(offsetof(MM_Customizing_Costume_Palette_UpdateThumbnailColorData_Main, _Value) == 0x000000, "Member 'MM_Customizing_Costume_Palette_UpdateThumbnailColorData_Main::_Value' has a wrong offset!");

// Function MirMobile.MM_Customizing_Costume_Palette.UpdateThumbnailColorData_Sub
// 0x0004 (0x0004 - 0x0000)
struct MM_Customizing_Costume_Palette_UpdateThumbnailColorData_Sub final
{
public:
	int32                                         _Value;                                            // 0x0000(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(MM_Customizing_Costume_Palette_UpdateThumbnailColorData_Sub) == 0x000004, "Wrong alignment on MM_Customizing_Costume_Palette_UpdateThumbnailColorData_Sub");
static_assert(sizeof(MM_Customizing_Costume_Palette_UpdateThumbnailColorData_Sub) == 0x000004, "Wrong size on MM_Customizing_Costume_Palette_UpdateThumbnailColorData_Sub");
static_assert(offsetof(MM_Customizing_Costume_Palette_UpdateThumbnailColorData_Sub, _Value) == 0x000000, "Member 'MM_Customizing_Costume_Palette_UpdateThumbnailColorData_Sub::_Value' has a wrong offset!");

// Function MirMobile.MM_Popup_BuildingAcceleration.OnChangePoint
// 0x0008 (0x0008 - 0x0000)
struct MM_Popup_BuildingAcceleration_OnChangePoint final
{
public:
	int64                                         UsePoint;                                          // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(MM_Popup_BuildingAcceleration_OnChangePoint) == 0x000008, "Wrong alignment on MM_Popup_BuildingAcceleration_OnChangePoint");
static_assert(sizeof(MM_Popup_BuildingAcceleration_OnChangePoint) == 0x000008, "Wrong size on MM_Popup_BuildingAcceleration_OnChangePoint");
static_assert(offsetof(MM_Popup_BuildingAcceleration_OnChangePoint, UsePoint) == 0x000000, "Member 'MM_Popup_BuildingAcceleration_OnChangePoint::UsePoint' has a wrong offset!");

// Function MirMobile.MirWebBrowser.MirHandleOnBeforePopup
// 0x0028 (0x0028 - 0x0000)
struct MirWebBrowser_MirHandleOnBeforePopup final
{
public:
	class FString                                 URL;                                               // 0x0000(0x0010)(Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 Frame;                                             // 0x0010(0x0010)(Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          ReturnValue;                                       // 0x0020(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_21[0x7];                                       // 0x0021(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(MirWebBrowser_MirHandleOnBeforePopup) == 0x000008, "Wrong alignment on MirWebBrowser_MirHandleOnBeforePopup");
static_assert(sizeof(MirWebBrowser_MirHandleOnBeforePopup) == 0x000028, "Wrong size on MirWebBrowser_MirHandleOnBeforePopup");
static_assert(offsetof(MirWebBrowser_MirHandleOnBeforePopup, URL) == 0x000000, "Member 'MirWebBrowser_MirHandleOnBeforePopup::URL' has a wrong offset!");
static_assert(offsetof(MirWebBrowser_MirHandleOnBeforePopup, Frame) == 0x000010, "Member 'MirWebBrowser_MirHandleOnBeforePopup::Frame' has a wrong offset!");
static_assert(offsetof(MirWebBrowser_MirHandleOnBeforePopup, ReturnValue) == 0x000020, "Member 'MirWebBrowser_MirHandleOnBeforePopup::ReturnValue' has a wrong offset!");

// Function MirMobile.MirWebBrowser.MirHandleOnLoadUrl
// 0x0038 (0x0038 - 0x0000)
struct MirWebBrowser_MirHandleOnLoadUrl final
{
public:
	class FString                                 Method;                                            // 0x0000(0x0010)(Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 URL;                                               // 0x0010(0x0010)(Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 OutResponse;                                       // 0x0020(0x0010)(Parm, OutParm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          ReturnValue;                                       // 0x0030(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_31[0x7];                                       // 0x0031(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(MirWebBrowser_MirHandleOnLoadUrl) == 0x000008, "Wrong alignment on MirWebBrowser_MirHandleOnLoadUrl");
static_assert(sizeof(MirWebBrowser_MirHandleOnLoadUrl) == 0x000038, "Wrong size on MirWebBrowser_MirHandleOnLoadUrl");
static_assert(offsetof(MirWebBrowser_MirHandleOnLoadUrl, Method) == 0x000000, "Member 'MirWebBrowser_MirHandleOnLoadUrl::Method' has a wrong offset!");
static_assert(offsetof(MirWebBrowser_MirHandleOnLoadUrl, URL) == 0x000010, "Member 'MirWebBrowser_MirHandleOnLoadUrl::URL' has a wrong offset!");
static_assert(offsetof(MirWebBrowser_MirHandleOnLoadUrl, OutResponse) == 0x000020, "Member 'MirWebBrowser_MirHandleOnLoadUrl::OutResponse' has a wrong offset!");
static_assert(offsetof(MirWebBrowser_MirHandleOnLoadUrl, ReturnValue) == 0x000030, "Member 'MirWebBrowser_MirHandleOnLoadUrl::ReturnValue' has a wrong offset!");

// Function MirMobile.MirWebBrowser.MirHandleOnUrlChanged
// 0x0018 (0x0018 - 0x0000)
struct MirWebBrowser_MirHandleOnUrlChanged final
{
public:
	class FText                                   Text;                                              // 0x0000(0x0018)(ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
};
static_assert(alignof(MirWebBrowser_MirHandleOnUrlChanged) == 0x000008, "Wrong alignment on MirWebBrowser_MirHandleOnUrlChanged");
static_assert(sizeof(MirWebBrowser_MirHandleOnUrlChanged) == 0x000018, "Wrong size on MirWebBrowser_MirHandleOnUrlChanged");
static_assert(offsetof(MirWebBrowser_MirHandleOnUrlChanged, Text) == 0x000000, "Member 'MirWebBrowser_MirHandleOnUrlChanged::Text' has a wrong offset!");

// Function MirMobile.MirWrapScrollBox.OnScrollEvent
// 0x0004 (0x0004 - 0x0000)
struct MirWrapScrollBox_OnScrollEvent final
{
public:
	float                                         Offset;                                            // 0x0000(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(MirWrapScrollBox_OnScrollEvent) == 0x000004, "Wrong alignment on MirWrapScrollBox_OnScrollEvent");
static_assert(sizeof(MirWrapScrollBox_OnScrollEvent) == 0x000004, "Wrong size on MirWrapScrollBox_OnScrollEvent");
static_assert(offsetof(MirWrapScrollBox_OnScrollEvent, Offset) == 0x000000, "Member 'MirWrapScrollBox_OnScrollEvent::Offset' has a wrong offset!");

// Function MirMobile.MM_UIAction_BlackDragon.StopAutoMission
// 0x0001 (0x0001 - 0x0000)
struct MM_UIAction_BlackDragon_StopAutoMission final
{
public:
	bool                                          IsEnter;                                           // 0x0000(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(MM_UIAction_BlackDragon_StopAutoMission) == 0x000001, "Wrong alignment on MM_UIAction_BlackDragon_StopAutoMission");
static_assert(sizeof(MM_UIAction_BlackDragon_StopAutoMission) == 0x000001, "Wrong size on MM_UIAction_BlackDragon_StopAutoMission");
static_assert(offsetof(MM_UIAction_BlackDragon_StopAutoMission, IsEnter) == 0x000000, "Member 'MM_UIAction_BlackDragon_StopAutoMission::IsEnter' has a wrong offset!");

// Function MirMobile.MM_AchievementSlot.OnClickItemSlot
// 0x0010 (0x0010 - 0x0000)
struct MM_AchievementSlot_OnClickItemSlot final
{
public:
	int64                                         IItemUID;                                          // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         IItemTID;                                          // 0x0008(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         ISlotIndex;                                        // 0x000C(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(MM_AchievementSlot_OnClickItemSlot) == 0x000008, "Wrong alignment on MM_AchievementSlot_OnClickItemSlot");
static_assert(sizeof(MM_AchievementSlot_OnClickItemSlot) == 0x000010, "Wrong size on MM_AchievementSlot_OnClickItemSlot");
static_assert(offsetof(MM_AchievementSlot_OnClickItemSlot, IItemUID) == 0x000000, "Member 'MM_AchievementSlot_OnClickItemSlot::IItemUID' has a wrong offset!");
static_assert(offsetof(MM_AchievementSlot_OnClickItemSlot, IItemTID) == 0x000008, "Member 'MM_AchievementSlot_OnClickItemSlot::IItemTID' has a wrong offset!");
static_assert(offsetof(MM_AchievementSlot_OnClickItemSlot, ISlotIndex) == 0x00000C, "Member 'MM_AchievementSlot_OnClickItemSlot::ISlotIndex' has a wrong offset!");

// Function MirMobile.MM_ItemSmeltWidget.OnClickEmptySubMaterial
// 0x0010 (0x0010 - 0x0000)
struct MM_ItemSmeltWidget_OnClickEmptySubMaterial final
{
public:
	int64                                         ItemUID;                                           // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         ItemTID;                                           // 0x0008(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         EquipPos;                                          // 0x000C(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(MM_ItemSmeltWidget_OnClickEmptySubMaterial) == 0x000008, "Wrong alignment on MM_ItemSmeltWidget_OnClickEmptySubMaterial");
static_assert(sizeof(MM_ItemSmeltWidget_OnClickEmptySubMaterial) == 0x000010, "Wrong size on MM_ItemSmeltWidget_OnClickEmptySubMaterial");
static_assert(offsetof(MM_ItemSmeltWidget_OnClickEmptySubMaterial, ItemUID) == 0x000000, "Member 'MM_ItemSmeltWidget_OnClickEmptySubMaterial::ItemUID' has a wrong offset!");
static_assert(offsetof(MM_ItemSmeltWidget_OnClickEmptySubMaterial, ItemTID) == 0x000008, "Member 'MM_ItemSmeltWidget_OnClickEmptySubMaterial::ItemTID' has a wrong offset!");
static_assert(offsetof(MM_ItemSmeltWidget_OnClickEmptySubMaterial, EquipPos) == 0x00000C, "Member 'MM_ItemSmeltWidget_OnClickEmptySubMaterial::EquipPos' has a wrong offset!");

// Function MirMobile.MM_AdManager.OnConsentInfoError
// 0x0018 (0x0018 - 0x0000)
struct MM_AdManager_OnConsentInfoError final
{
public:
	int32                                         ErrorCode;                                         // 0x0000(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_4[0x4];                                        // 0x0004(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class FString                                 ErrorMessage;                                      // 0x0008(0x0010)(Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(MM_AdManager_OnConsentInfoError) == 0x000008, "Wrong alignment on MM_AdManager_OnConsentInfoError");
static_assert(sizeof(MM_AdManager_OnConsentInfoError) == 0x000018, "Wrong size on MM_AdManager_OnConsentInfoError");
static_assert(offsetof(MM_AdManager_OnConsentInfoError, ErrorCode) == 0x000000, "Member 'MM_AdManager_OnConsentInfoError::ErrorCode' has a wrong offset!");
static_assert(offsetof(MM_AdManager_OnConsentInfoError, ErrorMessage) == 0x000008, "Member 'MM_AdManager_OnConsentInfoError::ErrorMessage' has a wrong offset!");

// Function MirMobile.MM_AdManager.OnFormError
// 0x0018 (0x0018 - 0x0000)
struct MM_AdManager_OnFormError final
{
public:
	int32                                         ErrorCode;                                         // 0x0000(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_4[0x4];                                        // 0x0004(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class FString                                 ErrorMessage;                                      // 0x0008(0x0010)(Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(MM_AdManager_OnFormError) == 0x000008, "Wrong alignment on MM_AdManager_OnFormError");
static_assert(sizeof(MM_AdManager_OnFormError) == 0x000018, "Wrong size on MM_AdManager_OnFormError");
static_assert(offsetof(MM_AdManager_OnFormError, ErrorCode) == 0x000000, "Member 'MM_AdManager_OnFormError::ErrorCode' has a wrong offset!");
static_assert(offsetof(MM_AdManager_OnFormError, ErrorMessage) == 0x000008, "Member 'MM_AdManager_OnFormError::ErrorMessage' has a wrong offset!");

// Function MirMobile.MM_AdManager.OnRewardedAdFailedToLoad
// 0x0018 (0x0018 - 0x0000)
struct MM_AdManager_OnRewardedAdFailedToLoad final
{
public:
	int32                                         ErrorCode;                                         // 0x0000(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_4[0x4];                                        // 0x0004(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class FString                                 ErrorMessage;                                      // 0x0008(0x0010)(Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(MM_AdManager_OnRewardedAdFailedToLoad) == 0x000008, "Wrong alignment on MM_AdManager_OnRewardedAdFailedToLoad");
static_assert(sizeof(MM_AdManager_OnRewardedAdFailedToLoad) == 0x000018, "Wrong size on MM_AdManager_OnRewardedAdFailedToLoad");
static_assert(offsetof(MM_AdManager_OnRewardedAdFailedToLoad, ErrorCode) == 0x000000, "Member 'MM_AdManager_OnRewardedAdFailedToLoad::ErrorCode' has a wrong offset!");
static_assert(offsetof(MM_AdManager_OnRewardedAdFailedToLoad, ErrorMessage) == 0x000008, "Member 'MM_AdManager_OnRewardedAdFailedToLoad::ErrorMessage' has a wrong offset!");

// Function MirMobile.MM_AdManager.OnRewardedAdFailedToShow
// 0x0018 (0x0018 - 0x0000)
struct MM_AdManager_OnRewardedAdFailedToShow final
{
public:
	int32                                         ErrorCode;                                         // 0x0000(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_4[0x4];                                        // 0x0004(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class FString                                 ErrorMessage;                                      // 0x0008(0x0010)(Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(MM_AdManager_OnRewardedAdFailedToShow) == 0x000008, "Wrong alignment on MM_AdManager_OnRewardedAdFailedToShow");
static_assert(sizeof(MM_AdManager_OnRewardedAdFailedToShow) == 0x000018, "Wrong size on MM_AdManager_OnRewardedAdFailedToShow");
static_assert(offsetof(MM_AdManager_OnRewardedAdFailedToShow, ErrorCode) == 0x000000, "Member 'MM_AdManager_OnRewardedAdFailedToShow::ErrorCode' has a wrong offset!");
static_assert(offsetof(MM_AdManager_OnRewardedAdFailedToShow, ErrorMessage) == 0x000008, "Member 'MM_AdManager_OnRewardedAdFailedToShow::ErrorMessage' has a wrong offset!");

// Function MirMobile.MM_AdManager.OnRewardedAdUserEarhedReward
// 0x0018 (0x0018 - 0x0000)
struct MM_AdManager_OnRewardedAdUserEarhedReward final
{
public:
	class FString                                 RewardType;                                        // 0x0000(0x0010)(Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         Amount;                                            // 0x0010(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_14[0x4];                                       // 0x0014(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(MM_AdManager_OnRewardedAdUserEarhedReward) == 0x000008, "Wrong alignment on MM_AdManager_OnRewardedAdUserEarhedReward");
static_assert(sizeof(MM_AdManager_OnRewardedAdUserEarhedReward) == 0x000018, "Wrong size on MM_AdManager_OnRewardedAdUserEarhedReward");
static_assert(offsetof(MM_AdManager_OnRewardedAdUserEarhedReward, RewardType) == 0x000000, "Member 'MM_AdManager_OnRewardedAdUserEarhedReward::RewardType' has a wrong offset!");
static_assert(offsetof(MM_AdManager_OnRewardedAdUserEarhedReward, Amount) == 0x000010, "Member 'MM_AdManager_OnRewardedAdUserEarhedReward::Amount' has a wrong offset!");

// Function MirMobile.MM_AncientTreasureEquip_Tab.OnClickCheckBox_0
// 0x0001 (0x0001 - 0x0000)
struct MM_AncientTreasureEquip_Tab_OnClickCheckBox_0 final
{
public:
	bool                                          InCheck;                                           // 0x0000(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(MM_AncientTreasureEquip_Tab_OnClickCheckBox_0) == 0x000001, "Wrong alignment on MM_AncientTreasureEquip_Tab_OnClickCheckBox_0");
static_assert(sizeof(MM_AncientTreasureEquip_Tab_OnClickCheckBox_0) == 0x000001, "Wrong size on MM_AncientTreasureEquip_Tab_OnClickCheckBox_0");
static_assert(offsetof(MM_AncientTreasureEquip_Tab_OnClickCheckBox_0, InCheck) == 0x000000, "Member 'MM_AncientTreasureEquip_Tab_OnClickCheckBox_0::InCheck' has a wrong offset!");

// Function MirMobile.MM_AncientTreasureEquip_Tab.OnClickCheckBox_1
// 0x0001 (0x0001 - 0x0000)
struct MM_AncientTreasureEquip_Tab_OnClickCheckBox_1 final
{
public:
	bool                                          InCheck;                                           // 0x0000(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(MM_AncientTreasureEquip_Tab_OnClickCheckBox_1) == 0x000001, "Wrong alignment on MM_AncientTreasureEquip_Tab_OnClickCheckBox_1");
static_assert(sizeof(MM_AncientTreasureEquip_Tab_OnClickCheckBox_1) == 0x000001, "Wrong size on MM_AncientTreasureEquip_Tab_OnClickCheckBox_1");
static_assert(offsetof(MM_AncientTreasureEquip_Tab_OnClickCheckBox_1, InCheck) == 0x000000, "Member 'MM_AncientTreasureEquip_Tab_OnClickCheckBox_1::InCheck' has a wrong offset!");

// Function MirMobile.MM_SortListBtn.OnClickSortBtn
// 0x0004 (0x0004 - 0x0000)
struct MM_SortListBtn_OnClickSortBtn final
{
public:
	int32                                         IKey;                                              // 0x0000(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(MM_SortListBtn_OnClickSortBtn) == 0x000004, "Wrong alignment on MM_SortListBtn_OnClickSortBtn");
static_assert(sizeof(MM_SortListBtn_OnClickSortBtn) == 0x000004, "Wrong size on MM_SortListBtn_OnClickSortBtn");
static_assert(offsetof(MM_SortListBtn_OnClickSortBtn, IKey) == 0x000000, "Member 'MM_SortListBtn_OnClickSortBtn::IKey' has a wrong offset!");

// Function MirMobile.MM_AnimationTestGameMode.BeginTestGameMode
// 0x0004 (0x0004 - 0x0000)
struct MM_AnimationTestGameMode_BeginTestGameMode final
{
public:
	int32                                         ClassID;                                           // 0x0000(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(MM_AnimationTestGameMode_BeginTestGameMode) == 0x000004, "Wrong alignment on MM_AnimationTestGameMode_BeginTestGameMode");
static_assert(sizeof(MM_AnimationTestGameMode_BeginTestGameMode) == 0x000004, "Wrong size on MM_AnimationTestGameMode_BeginTestGameMode");
static_assert(offsetof(MM_AnimationTestGameMode_BeginTestGameMode, ClassID) == 0x000000, "Member 'MM_AnimationTestGameMode_BeginTestGameMode::ClassID' has a wrong offset!");

// Function MirMobile.MM_AnimationTestGameMode.ChangeBaseFSM
// 0x0010 (0x0010 - 0x0000)
struct MM_AnimationTestGameMode_ChangeBaseFSM final
{
public:
	class ACharacter*                             PCharacter;                                        // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EFSM_TYPE                                     FsmState;                                          // 0x0008(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_9[0x7];                                        // 0x0009(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(MM_AnimationTestGameMode_ChangeBaseFSM) == 0x000008, "Wrong alignment on MM_AnimationTestGameMode_ChangeBaseFSM");
static_assert(sizeof(MM_AnimationTestGameMode_ChangeBaseFSM) == 0x000010, "Wrong size on MM_AnimationTestGameMode_ChangeBaseFSM");
static_assert(offsetof(MM_AnimationTestGameMode_ChangeBaseFSM, PCharacter) == 0x000000, "Member 'MM_AnimationTestGameMode_ChangeBaseFSM::PCharacter' has a wrong offset!");
static_assert(offsetof(MM_AnimationTestGameMode_ChangeBaseFSM, FsmState) == 0x000008, "Member 'MM_AnimationTestGameMode_ChangeBaseFSM::FsmState' has a wrong offset!");

// Function MirMobile.MM_AnimationTestGameMode.ChangeCharacter
// 0x0004 (0x0004 - 0x0000)
struct MM_AnimationTestGameMode_ChangeCharacter final
{
public:
	int32                                         ClassID;                                           // 0x0000(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(MM_AnimationTestGameMode_ChangeCharacter) == 0x000004, "Wrong alignment on MM_AnimationTestGameMode_ChangeCharacter");
static_assert(sizeof(MM_AnimationTestGameMode_ChangeCharacter) == 0x000004, "Wrong size on MM_AnimationTestGameMode_ChangeCharacter");
static_assert(offsetof(MM_AnimationTestGameMode_ChangeCharacter, ClassID) == 0x000000, "Member 'MM_AnimationTestGameMode_ChangeCharacter::ClassID' has a wrong offset!");

// Function MirMobile.MM_AnimationTestGameMode.ChangeTestMode
// 0x0001 (0x0001 - 0x0000)
struct MM_AnimationTestGameMode_ChangeTestMode final
{
public:
	bool                                          bPC;                                               // 0x0000(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(MM_AnimationTestGameMode_ChangeTestMode) == 0x000001, "Wrong alignment on MM_AnimationTestGameMode_ChangeTestMode");
static_assert(sizeof(MM_AnimationTestGameMode_ChangeTestMode) == 0x000001, "Wrong size on MM_AnimationTestGameMode_ChangeTestMode");
static_assert(offsetof(MM_AnimationTestGameMode_ChangeTestMode, bPC) == 0x000000, "Member 'MM_AnimationTestGameMode_ChangeTestMode::bPC' has a wrong offset!");

// Function MirMobile.MM_AnimationTestGameMode.GetFSMState
// 0x0010 (0x0010 - 0x0000)
struct MM_AnimationTestGameMode_GetFSMState final
{
public:
	class ACharacter*                             PCharacter;                                        // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EFSM_TYPE                                     ReturnValue;                                       // 0x0008(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_9[0x7];                                        // 0x0009(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(MM_AnimationTestGameMode_GetFSMState) == 0x000008, "Wrong alignment on MM_AnimationTestGameMode_GetFSMState");
static_assert(sizeof(MM_AnimationTestGameMode_GetFSMState) == 0x000010, "Wrong size on MM_AnimationTestGameMode_GetFSMState");
static_assert(offsetof(MM_AnimationTestGameMode_GetFSMState, PCharacter) == 0x000000, "Member 'MM_AnimationTestGameMode_GetFSMState::PCharacter' has a wrong offset!");
static_assert(offsetof(MM_AnimationTestGameMode_GetFSMState, ReturnValue) == 0x000008, "Member 'MM_AnimationTestGameMode_GetFSMState::ReturnValue' has a wrong offset!");

// Function MirMobile.MM_AnimationTestGameMode.SetAniIndex
// 0x0010 (0x0010 - 0x0000)
struct MM_AnimationTestGameMode_SetAniIndex final
{
public:
	class ACharacter*                             PCharacter;                                        // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         AnimID;                                            // 0x0008(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_C[0x4];                                        // 0x000C(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(MM_AnimationTestGameMode_SetAniIndex) == 0x000008, "Wrong alignment on MM_AnimationTestGameMode_SetAniIndex");
static_assert(sizeof(MM_AnimationTestGameMode_SetAniIndex) == 0x000010, "Wrong size on MM_AnimationTestGameMode_SetAniIndex");
static_assert(offsetof(MM_AnimationTestGameMode_SetAniIndex, PCharacter) == 0x000000, "Member 'MM_AnimationTestGameMode_SetAniIndex::PCharacter' has a wrong offset!");
static_assert(offsetof(MM_AnimationTestGameMode_SetAniIndex, AnimID) == 0x000008, "Member 'MM_AnimationTestGameMode_SetAniIndex::AnimID' has a wrong offset!");

// Function MirMobile.MM_AnimationTestGameMode.SetCCStance
// 0x0010 (0x0010 - 0x0000)
struct MM_AnimationTestGameMode_SetCCStance final
{
public:
	class ACharacter*                             PCharacter;                                        // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         CCSTANCE;                                          // 0x0008(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_C[0x4];                                        // 0x000C(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(MM_AnimationTestGameMode_SetCCStance) == 0x000008, "Wrong alignment on MM_AnimationTestGameMode_SetCCStance");
static_assert(sizeof(MM_AnimationTestGameMode_SetCCStance) == 0x000010, "Wrong size on MM_AnimationTestGameMode_SetCCStance");
static_assert(offsetof(MM_AnimationTestGameMode_SetCCStance, PCharacter) == 0x000000, "Member 'MM_AnimationTestGameMode_SetCCStance::PCharacter' has a wrong offset!");
static_assert(offsetof(MM_AnimationTestGameMode_SetCCStance, CCSTANCE) == 0x000008, "Member 'MM_AnimationTestGameMode_SetCCStance::CCSTANCE' has a wrong offset!");

// Function MirMobile.MM_AnimationTestGameMode.SetVehicleInfo
// 0x0008 (0x0008 - 0x0000)
struct MM_AnimationTestGameMode_SetVehicleInfo final
{
public:
	int32                                         VehicleId;                                         // 0x0000(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         VehicleType;                                       // 0x0004(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(MM_AnimationTestGameMode_SetVehicleInfo) == 0x000004, "Wrong alignment on MM_AnimationTestGameMode_SetVehicleInfo");
static_assert(sizeof(MM_AnimationTestGameMode_SetVehicleInfo) == 0x000008, "Wrong size on MM_AnimationTestGameMode_SetVehicleInfo");
static_assert(offsetof(MM_AnimationTestGameMode_SetVehicleInfo, VehicleId) == 0x000000, "Member 'MM_AnimationTestGameMode_SetVehicleInfo::VehicleId' has a wrong offset!");
static_assert(offsetof(MM_AnimationTestGameMode_SetVehicleInfo, VehicleType) == 0x000004, "Member 'MM_AnimationTestGameMode_SetVehicleInfo::VehicleType' has a wrong offset!");

// Function MirMobile.MM_Auction_ComboList.OnSelectChildSlot
// 0x0008 (0x0008 - 0x0000)
struct MM_Auction_ComboList_OnSelectChildSlot final
{
public:
	int32                                         ISelectID;                                         // 0x0000(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bSlotUpdate;                                       // 0x0004(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_5[0x3];                                        // 0x0005(0x0003)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(MM_Auction_ComboList_OnSelectChildSlot) == 0x000004, "Wrong alignment on MM_Auction_ComboList_OnSelectChildSlot");
static_assert(sizeof(MM_Auction_ComboList_OnSelectChildSlot) == 0x000008, "Wrong size on MM_Auction_ComboList_OnSelectChildSlot");
static_assert(offsetof(MM_Auction_ComboList_OnSelectChildSlot, ISelectID) == 0x000000, "Member 'MM_Auction_ComboList_OnSelectChildSlot::ISelectID' has a wrong offset!");
static_assert(offsetof(MM_Auction_ComboList_OnSelectChildSlot, bSlotUpdate) == 0x000004, "Member 'MM_Auction_ComboList_OnSelectChildSlot::bSlotUpdate' has a wrong offset!");

// Function MirMobile.MM_Auction_Slot_Material.OnClickItemSlot
// 0x0010 (0x0010 - 0x0000)
struct MM_Auction_Slot_Material_OnClickItemSlot final
{
public:
	int64                                         IUID;                                              // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         ITID;                                              // 0x0008(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         IEquipPos;                                         // 0x000C(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(MM_Auction_Slot_Material_OnClickItemSlot) == 0x000008, "Wrong alignment on MM_Auction_Slot_Material_OnClickItemSlot");
static_assert(sizeof(MM_Auction_Slot_Material_OnClickItemSlot) == 0x000010, "Wrong size on MM_Auction_Slot_Material_OnClickItemSlot");
static_assert(offsetof(MM_Auction_Slot_Material_OnClickItemSlot, IUID) == 0x000000, "Member 'MM_Auction_Slot_Material_OnClickItemSlot::IUID' has a wrong offset!");
static_assert(offsetof(MM_Auction_Slot_Material_OnClickItemSlot, ITID) == 0x000008, "Member 'MM_Auction_Slot_Material_OnClickItemSlot::ITID' has a wrong offset!");
static_assert(offsetof(MM_Auction_Slot_Material_OnClickItemSlot, IEquipPos) == 0x00000C, "Member 'MM_Auction_Slot_Material_OnClickItemSlot::IEquipPos' has a wrong offset!");

// Function MirMobile.MM_Auction_Tab_Search_TabGroup.OnChangeSearch
// 0x0018 (0x0018 - 0x0000)
struct MM_Auction_Tab_Search_TabGroup_OnChangeSearch final
{
public:
	class FText                                   Text;                                              // 0x0000(0x0018)(ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
};
static_assert(alignof(MM_Auction_Tab_Search_TabGroup_OnChangeSearch) == 0x000008, "Wrong alignment on MM_Auction_Tab_Search_TabGroup_OnChangeSearch");
static_assert(sizeof(MM_Auction_Tab_Search_TabGroup_OnChangeSearch) == 0x000018, "Wrong size on MM_Auction_Tab_Search_TabGroup_OnChangeSearch");
static_assert(offsetof(MM_Auction_Tab_Search_TabGroup_OnChangeSearch, Text) == 0x000000, "Member 'MM_Auction_Tab_Search_TabGroup_OnChangeSearch::Text' has a wrong offset!");

// Function MirMobile.MM_Auction_Tab_Search_TabGroup.OnChangeSlot
// 0x0004 (0x0004 - 0x0000)
struct MM_Auction_Tab_Search_TabGroup_OnChangeSlot final
{
public:
	int32                                         ISlotID;                                           // 0x0000(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(MM_Auction_Tab_Search_TabGroup_OnChangeSlot) == 0x000004, "Wrong alignment on MM_Auction_Tab_Search_TabGroup_OnChangeSlot");
static_assert(sizeof(MM_Auction_Tab_Search_TabGroup_OnChangeSlot) == 0x000004, "Wrong size on MM_Auction_Tab_Search_TabGroup_OnChangeSlot");
static_assert(offsetof(MM_Auction_Tab_Search_TabGroup_OnChangeSlot, ISlotID) == 0x000000, "Member 'MM_Auction_Tab_Search_TabGroup_OnChangeSlot::ISlotID' has a wrong offset!");

// Function MirMobile.MM_Auction_Tab_Search_TabGroup.OnClickTab
// 0x0004 (0x0004 - 0x0000)
struct MM_Auction_Tab_Search_TabGroup_OnClickTab final
{
public:
	int32                                         IGroupSlotID;                                      // 0x0000(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(MM_Auction_Tab_Search_TabGroup_OnClickTab) == 0x000004, "Wrong alignment on MM_Auction_Tab_Search_TabGroup_OnClickTab");
static_assert(sizeof(MM_Auction_Tab_Search_TabGroup_OnClickTab) == 0x000004, "Wrong size on MM_Auction_Tab_Search_TabGroup_OnClickTab");
static_assert(offsetof(MM_Auction_Tab_Search_TabGroup_OnClickTab, IGroupSlotID) == 0x000000, "Member 'MM_Auction_Tab_Search_TabGroup_OnClickTab::IGroupSlotID' has a wrong offset!");

// Function MirMobile.MM_Auction_Tab_Search_TabGroup.OnCommitSearch
// 0x0020 (0x0020 - 0x0000)
struct MM_Auction_Tab_Search_TabGroup_OnCommitSearch final
{
public:
	class FText                                   Text;                                              // 0x0000(0x0018)(ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
	ETextCommit                                   CommitMethod;                                      // 0x0018(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_19[0x7];                                       // 0x0019(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(MM_Auction_Tab_Search_TabGroup_OnCommitSearch) == 0x000008, "Wrong alignment on MM_Auction_Tab_Search_TabGroup_OnCommitSearch");
static_assert(sizeof(MM_Auction_Tab_Search_TabGroup_OnCommitSearch) == 0x000020, "Wrong size on MM_Auction_Tab_Search_TabGroup_OnCommitSearch");
static_assert(offsetof(MM_Auction_Tab_Search_TabGroup_OnCommitSearch, Text) == 0x000000, "Member 'MM_Auction_Tab_Search_TabGroup_OnCommitSearch::Text' has a wrong offset!");
static_assert(offsetof(MM_Auction_Tab_Search_TabGroup_OnCommitSearch, CommitMethod) == 0x000018, "Member 'MM_Auction_Tab_Search_TabGroup_OnCommitSearch::CommitMethod' has a wrong offset!");

// Function MirMobile.MM_Auction_Tab_Search_TabGroup.OnSearch
// 0x0002 (0x0002 - 0x0000)
struct MM_Auction_Tab_Search_TabGroup_OnSearch final
{
public:
	bool                                          bIsSearchDelay;                                    // 0x0000(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bRefreshSearchList;                                // 0x0001(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(MM_Auction_Tab_Search_TabGroup_OnSearch) == 0x000001, "Wrong alignment on MM_Auction_Tab_Search_TabGroup_OnSearch");
static_assert(sizeof(MM_Auction_Tab_Search_TabGroup_OnSearch) == 0x000002, "Wrong size on MM_Auction_Tab_Search_TabGroup_OnSearch");
static_assert(offsetof(MM_Auction_Tab_Search_TabGroup_OnSearch, bIsSearchDelay) == 0x000000, "Member 'MM_Auction_Tab_Search_TabGroup_OnSearch::bIsSearchDelay' has a wrong offset!");
static_assert(offsetof(MM_Auction_Tab_Search_TabGroup_OnSearch, bRefreshSearchList) == 0x000001, "Member 'MM_Auction_Tab_Search_TabGroup_OnSearch::bRefreshSearchList' has a wrong offset!");

// Function MirMobile.MM_B_AncientTreasureEquip.OnClickEquipSlot
// 0x0010 (0x0010 - 0x0000)
struct MM_B_AncientTreasureEquip_OnClickEquipSlot final
{
public:
	int64                                         IUID;                                              // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         ITID;                                              // 0x0008(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         IEquipPosition;                                    // 0x000C(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(MM_B_AncientTreasureEquip_OnClickEquipSlot) == 0x000008, "Wrong alignment on MM_B_AncientTreasureEquip_OnClickEquipSlot");
static_assert(sizeof(MM_B_AncientTreasureEquip_OnClickEquipSlot) == 0x000010, "Wrong size on MM_B_AncientTreasureEquip_OnClickEquipSlot");
static_assert(offsetof(MM_B_AncientTreasureEquip_OnClickEquipSlot, IUID) == 0x000000, "Member 'MM_B_AncientTreasureEquip_OnClickEquipSlot::IUID' has a wrong offset!");
static_assert(offsetof(MM_B_AncientTreasureEquip_OnClickEquipSlot, ITID) == 0x000008, "Member 'MM_B_AncientTreasureEquip_OnClickEquipSlot::ITID' has a wrong offset!");
static_assert(offsetof(MM_B_AncientTreasureEquip_OnClickEquipSlot, IEquipPosition) == 0x00000C, "Member 'MM_B_AncientTreasureEquip_OnClickEquipSlot::IEquipPosition' has a wrong offset!");

// Function MirMobile.MM_PopupGuildCostExchange.OnChangeCount
// 0x0008 (0x0008 - 0x0000)
struct MM_PopupGuildCostExchange_OnChangeCount final
{
public:
	int64                                         Count_;                                            // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(MM_PopupGuildCostExchange_OnChangeCount) == 0x000008, "Wrong alignment on MM_PopupGuildCostExchange_OnChangeCount");
static_assert(sizeof(MM_PopupGuildCostExchange_OnChangeCount) == 0x000008, "Wrong size on MM_PopupGuildCostExchange_OnChangeCount");
static_assert(offsetof(MM_PopupGuildCostExchange_OnChangeCount, Count_) == 0x000000, "Member 'MM_PopupGuildCostExchange_OnChangeCount::Count_' has a wrong offset!");

// Function MirMobile.MM_B_ClassPhase.OnClickSlot
// 0x0008 (0x0008 - 0x0000)
struct MM_B_ClassPhase_OnClickSlot final
{
public:
	int32                                         ISlotID;                                           // 0x0000(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         IClassID;                                          // 0x0004(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(MM_B_ClassPhase_OnClickSlot) == 0x000004, "Wrong alignment on MM_B_ClassPhase_OnClickSlot");
static_assert(sizeof(MM_B_ClassPhase_OnClickSlot) == 0x000008, "Wrong size on MM_B_ClassPhase_OnClickSlot");
static_assert(offsetof(MM_B_ClassPhase_OnClickSlot, ISlotID) == 0x000000, "Member 'MM_B_ClassPhase_OnClickSlot::ISlotID' has a wrong offset!");
static_assert(offsetof(MM_B_ClassPhase_OnClickSlot, IClassID) == 0x000004, "Member 'MM_B_ClassPhase_OnClickSlot::IClassID' has a wrong offset!");

// Function MirMobile.MM_B_ClosedTraining.OnClick_Tab
// 0x0004 (0x0004 - 0x0000)
struct MM_B_ClosedTraining_OnClick_Tab final
{
public:
	int32                                         TabIndex;                                          // 0x0000(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(MM_B_ClosedTraining_OnClick_Tab) == 0x000004, "Wrong alignment on MM_B_ClosedTraining_OnClick_Tab");
static_assert(sizeof(MM_B_ClosedTraining_OnClick_Tab) == 0x000004, "Wrong size on MM_B_ClosedTraining_OnClick_Tab");
static_assert(offsetof(MM_B_ClosedTraining_OnClick_Tab, TabIndex) == 0x000000, "Member 'MM_B_ClosedTraining_OnClick_Tab::TabIndex' has a wrong offset!");

// Function MirMobile.MM_Popup_OptionChange.OnClickItemInfo
// 0x0008 (0x0008 - 0x0000)
struct MM_Popup_OptionChange_OnClickItemInfo final
{
public:
	class UMM_Slot_Base*                          _Slot;                                             // 0x0000(0x0008)(Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(MM_Popup_OptionChange_OnClickItemInfo) == 0x000008, "Wrong alignment on MM_Popup_OptionChange_OnClickItemInfo");
static_assert(sizeof(MM_Popup_OptionChange_OnClickItemInfo) == 0x000008, "Wrong size on MM_Popup_OptionChange_OnClickItemInfo");
static_assert(offsetof(MM_Popup_OptionChange_OnClickItemInfo, _Slot) == 0x000000, "Member 'MM_Popup_OptionChange_OnClickItemInfo::_Slot' has a wrong offset!");

// Function MirMobile.MM_Popup_OptionChange.PlayCloseAni
// 0x0004 (0x0004 - 0x0000)
struct MM_Popup_OptionChange_PlayCloseAni final
{
public:
	float                                         ReturnValue;                                       // 0x0000(0x0004)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(MM_Popup_OptionChange_PlayCloseAni) == 0x000004, "Wrong alignment on MM_Popup_OptionChange_PlayCloseAni");
static_assert(sizeof(MM_Popup_OptionChange_PlayCloseAni) == 0x000004, "Wrong size on MM_Popup_OptionChange_PlayCloseAni");
static_assert(offsetof(MM_Popup_OptionChange_PlayCloseAni, ReturnValue) == 0x000000, "Member 'MM_Popup_OptionChange_PlayCloseAni::ReturnValue' has a wrong offset!");

// Function MirMobile.MM_B_CollectionBook_Codex.OnCommitEdit
// 0x0020 (0x0020 - 0x0000)
struct MM_B_CollectionBook_Codex_OnCommitEdit final
{
public:
	class FText                                   Text;                                              // 0x0000(0x0018)(ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
	ETextCommit                                   CommitMethod;                                      // 0x0018(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_19[0x7];                                       // 0x0019(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(MM_B_CollectionBook_Codex_OnCommitEdit) == 0x000008, "Wrong alignment on MM_B_CollectionBook_Codex_OnCommitEdit");
static_assert(sizeof(MM_B_CollectionBook_Codex_OnCommitEdit) == 0x000020, "Wrong size on MM_B_CollectionBook_Codex_OnCommitEdit");
static_assert(offsetof(MM_B_CollectionBook_Codex_OnCommitEdit, Text) == 0x000000, "Member 'MM_B_CollectionBook_Codex_OnCommitEdit::Text' has a wrong offset!");
static_assert(offsetof(MM_B_CollectionBook_Codex_OnCommitEdit, CommitMethod) == 0x000018, "Member 'MM_B_CollectionBook_Codex_OnCommitEdit::CommitMethod' has a wrong offset!");

// Function MirMobile.MM_B_CollectionBook_Codex.OnStatusFilterChanged
// 0x0010 (0x0010 - 0x0000)
struct MM_B_CollectionBook_Codex_OnStatusFilterChanged final
{
public:
	class FString                                 StatusName;                                        // 0x0000(0x0010)(Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(MM_B_CollectionBook_Codex_OnStatusFilterChanged) == 0x000008, "Wrong alignment on MM_B_CollectionBook_Codex_OnStatusFilterChanged");
static_assert(sizeof(MM_B_CollectionBook_Codex_OnStatusFilterChanged) == 0x000010, "Wrong size on MM_B_CollectionBook_Codex_OnStatusFilterChanged");
static_assert(offsetof(MM_B_CollectionBook_Codex_OnStatusFilterChanged, StatusName) == 0x000000, "Member 'MM_B_CollectionBook_Codex_OnStatusFilterChanged::StatusName' has a wrong offset!");

// Function MirMobile.MM_MagicOrbCollection.OnClickedCollectionSlot
// 0x0010 (0x0010 - 0x0000)
struct MM_MagicOrbCollection_OnClickedCollectionSlot final
{
public:
	int64                                         Uid_;                                              // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         Tid_;                                              // 0x0008(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         Pos_;                                              // 0x000C(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(MM_MagicOrbCollection_OnClickedCollectionSlot) == 0x000008, "Wrong alignment on MM_MagicOrbCollection_OnClickedCollectionSlot");
static_assert(sizeof(MM_MagicOrbCollection_OnClickedCollectionSlot) == 0x000010, "Wrong size on MM_MagicOrbCollection_OnClickedCollectionSlot");
static_assert(offsetof(MM_MagicOrbCollection_OnClickedCollectionSlot, Uid_) == 0x000000, "Member 'MM_MagicOrbCollection_OnClickedCollectionSlot::Uid_' has a wrong offset!");
static_assert(offsetof(MM_MagicOrbCollection_OnClickedCollectionSlot, Tid_) == 0x000008, "Member 'MM_MagicOrbCollection_OnClickedCollectionSlot::Tid_' has a wrong offset!");
static_assert(offsetof(MM_MagicOrbCollection_OnClickedCollectionSlot, Pos_) == 0x00000C, "Member 'MM_MagicOrbCollection_OnClickedCollectionSlot::Pos_' has a wrong offset!");

// Function MirMobile.MM_B_CollectionBook_CollectList.OnClickCollectItemSlot
// 0x0010 (0x0010 - 0x0000)
struct MM_B_CollectionBook_CollectList_OnClickCollectItemSlot final
{
public:
	int64                                         Uid;                                               // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         TID;                                               // 0x0008(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         EquipPosition;                                     // 0x000C(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(MM_B_CollectionBook_CollectList_OnClickCollectItemSlot) == 0x000008, "Wrong alignment on MM_B_CollectionBook_CollectList_OnClickCollectItemSlot");
static_assert(sizeof(MM_B_CollectionBook_CollectList_OnClickCollectItemSlot) == 0x000010, "Wrong size on MM_B_CollectionBook_CollectList_OnClickCollectItemSlot");
static_assert(offsetof(MM_B_CollectionBook_CollectList_OnClickCollectItemSlot, Uid) == 0x000000, "Member 'MM_B_CollectionBook_CollectList_OnClickCollectItemSlot::Uid' has a wrong offset!");
static_assert(offsetof(MM_B_CollectionBook_CollectList_OnClickCollectItemSlot, TID) == 0x000008, "Member 'MM_B_CollectionBook_CollectList_OnClickCollectItemSlot::TID' has a wrong offset!");
static_assert(offsetof(MM_B_CollectionBook_CollectList_OnClickCollectItemSlot, EquipPosition) == 0x00000C, "Member 'MM_B_CollectionBook_CollectList_OnClickCollectItemSlot::EquipPosition' has a wrong offset!");

// Function MirMobile.MM_B_Costume.OnClickSubWeaponDisalbeSetting
// 0x0001 (0x0001 - 0x0000)
struct MM_B_Costume_OnClickSubWeaponDisalbeSetting final
{
public:
	bool                                          Checked;                                           // 0x0000(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(MM_B_Costume_OnClickSubWeaponDisalbeSetting) == 0x000001, "Wrong alignment on MM_B_Costume_OnClickSubWeaponDisalbeSetting");
static_assert(sizeof(MM_B_Costume_OnClickSubWeaponDisalbeSetting) == 0x000001, "Wrong size on MM_B_Costume_OnClickSubWeaponDisalbeSetting");
static_assert(offsetof(MM_B_Costume_OnClickSubWeaponDisalbeSetting, Checked) == 0x000000, "Member 'MM_B_Costume_OnClickSubWeaponDisalbeSetting::Checked' has a wrong offset!");

// Function MirMobile.MM_PopupGuildGivePersonal.OnClickAllSelectMembers
// 0x0001 (0x0001 - 0x0000)
struct MM_PopupGuildGivePersonal_OnClickAllSelectMembers final
{
public:
	bool                                          Checked_;                                          // 0x0000(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(MM_PopupGuildGivePersonal_OnClickAllSelectMembers) == 0x000001, "Wrong alignment on MM_PopupGuildGivePersonal_OnClickAllSelectMembers");
static_assert(sizeof(MM_PopupGuildGivePersonal_OnClickAllSelectMembers) == 0x000001, "Wrong size on MM_PopupGuildGivePersonal_OnClickAllSelectMembers");
static_assert(offsetof(MM_PopupGuildGivePersonal_OnClickAllSelectMembers, Checked_) == 0x000000, "Member 'MM_PopupGuildGivePersonal_OnClickAllSelectMembers::Checked_' has a wrong offset!");

// Function MirMobile.MM_PopupGuildGivePersonal.OnClickAllSelectOthers
// 0x0001 (0x0001 - 0x0000)
struct MM_PopupGuildGivePersonal_OnClickAllSelectOthers final
{
public:
	bool                                          Checked_;                                          // 0x0000(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(MM_PopupGuildGivePersonal_OnClickAllSelectOthers) == 0x000001, "Wrong alignment on MM_PopupGuildGivePersonal_OnClickAllSelectOthers");
static_assert(sizeof(MM_PopupGuildGivePersonal_OnClickAllSelectOthers) == 0x000001, "Wrong size on MM_PopupGuildGivePersonal_OnClickAllSelectOthers");
static_assert(offsetof(MM_PopupGuildGivePersonal_OnClickAllSelectOthers, Checked_) == 0x000000, "Member 'MM_PopupGuildGivePersonal_OnClickAllSelectOthers::Checked_' has a wrong offset!");

// Function MirMobile.MM_PopupGuildGivePersonal.OnClickSortCheckBox
// 0x0001 (0x0001 - 0x0000)
struct MM_PopupGuildGivePersonal_OnClickSortCheckBox final
{
public:
	bool                                          Checked_;                                          // 0x0000(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(MM_PopupGuildGivePersonal_OnClickSortCheckBox) == 0x000001, "Wrong alignment on MM_PopupGuildGivePersonal_OnClickSortCheckBox");
static_assert(sizeof(MM_PopupGuildGivePersonal_OnClickSortCheckBox) == 0x000001, "Wrong size on MM_PopupGuildGivePersonal_OnClickSortCheckBox");
static_assert(offsetof(MM_PopupGuildGivePersonal_OnClickSortCheckBox, Checked_) == 0x000000, "Member 'MM_PopupGuildGivePersonal_OnClickSortCheckBox::Checked_' has a wrong offset!");

// Function MirMobile.MM_PopupGuildGivePersonal.OnClickTabMembers
// 0x0001 (0x0001 - 0x0000)
struct MM_PopupGuildGivePersonal_OnClickTabMembers final
{
public:
	bool                                          Checked_;                                          // 0x0000(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(MM_PopupGuildGivePersonal_OnClickTabMembers) == 0x000001, "Wrong alignment on MM_PopupGuildGivePersonal_OnClickTabMembers");
static_assert(sizeof(MM_PopupGuildGivePersonal_OnClickTabMembers) == 0x000001, "Wrong size on MM_PopupGuildGivePersonal_OnClickTabMembers");
static_assert(offsetof(MM_PopupGuildGivePersonal_OnClickTabMembers, Checked_) == 0x000000, "Member 'MM_PopupGuildGivePersonal_OnClickTabMembers::Checked_' has a wrong offset!");

// Function MirMobile.MM_PopupGuildGivePersonal.OnClickTabOthers
// 0x0001 (0x0001 - 0x0000)
struct MM_PopupGuildGivePersonal_OnClickTabOthers final
{
public:
	bool                                          Checked_;                                          // 0x0000(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(MM_PopupGuildGivePersonal_OnClickTabOthers) == 0x000001, "Wrong alignment on MM_PopupGuildGivePersonal_OnClickTabOthers");
static_assert(sizeof(MM_PopupGuildGivePersonal_OnClickTabOthers) == 0x000001, "Wrong size on MM_PopupGuildGivePersonal_OnClickTabOthers");
static_assert(offsetof(MM_PopupGuildGivePersonal_OnClickTabOthers, Checked_) == 0x000000, "Member 'MM_PopupGuildGivePersonal_OnClickTabOthers::Checked_' has a wrong offset!");

// Function MirMobile.MM_PopUp_Quest_Delivery.PlayCloseAni
// 0x0004 (0x0004 - 0x0000)
struct MM_PopUp_Quest_Delivery_PlayCloseAni final
{
public:
	float                                         ReturnValue;                                       // 0x0000(0x0004)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(MM_PopUp_Quest_Delivery_PlayCloseAni) == 0x000004, "Wrong alignment on MM_PopUp_Quest_Delivery_PlayCloseAni");
static_assert(sizeof(MM_PopUp_Quest_Delivery_PlayCloseAni) == 0x000004, "Wrong size on MM_PopUp_Quest_Delivery_PlayCloseAni");
static_assert(offsetof(MM_PopUp_Quest_Delivery_PlayCloseAni, ReturnValue) == 0x000000, "Member 'MM_PopUp_Quest_Delivery_PlayCloseAni::ReturnValue' has a wrong offset!");

// Function MirMobile.MM_B_Dominion.OnClickMainTab
// 0x0008 (0x0008 - 0x0000)
struct MM_B_Dominion_OnClickMainTab final
{
public:
	int32                                         ITabIndex;                                         // 0x0000(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bLocked;                                           // 0x0004(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_5[0x3];                                        // 0x0005(0x0003)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(MM_B_Dominion_OnClickMainTab) == 0x000004, "Wrong alignment on MM_B_Dominion_OnClickMainTab");
static_assert(sizeof(MM_B_Dominion_OnClickMainTab) == 0x000008, "Wrong size on MM_B_Dominion_OnClickMainTab");
static_assert(offsetof(MM_B_Dominion_OnClickMainTab, ITabIndex) == 0x000000, "Member 'MM_B_Dominion_OnClickMainTab::ITabIndex' has a wrong offset!");
static_assert(offsetof(MM_B_Dominion_OnClickMainTab, bLocked) == 0x000004, "Member 'MM_B_Dominion_OnClickMainTab::bLocked' has a wrong offset!");

// Function MirMobile.MM_PopupGuildGiveMemberSlot.OnClickCheckBox
// 0x0001 (0x0001 - 0x0000)
struct MM_PopupGuildGiveMemberSlot_OnClickCheckBox final
{
public:
	bool                                          Check_;                                            // 0x0000(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(MM_PopupGuildGiveMemberSlot_OnClickCheckBox) == 0x000001, "Wrong alignment on MM_PopupGuildGiveMemberSlot_OnClickCheckBox");
static_assert(sizeof(MM_PopupGuildGiveMemberSlot_OnClickCheckBox) == 0x000001, "Wrong size on MM_PopupGuildGiveMemberSlot_OnClickCheckBox");
static_assert(offsetof(MM_PopupGuildGiveMemberSlot_OnClickCheckBox, Check_) == 0x000000, "Member 'MM_PopupGuildGiveMemberSlot_OnClickCheckBox::Check_' has a wrong offset!");

// Function MirMobile.MM_B_DominionWanted.OnClickVrtTab
// 0x0008 (0x0008 - 0x0000)
struct MM_B_DominionWanted_OnClickVrtTab final
{
public:
	int32                                         IIndex;                                            // 0x0000(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bLocked;                                           // 0x0004(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_5[0x3];                                        // 0x0005(0x0003)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(MM_B_DominionWanted_OnClickVrtTab) == 0x000004, "Wrong alignment on MM_B_DominionWanted_OnClickVrtTab");
static_assert(sizeof(MM_B_DominionWanted_OnClickVrtTab) == 0x000008, "Wrong size on MM_B_DominionWanted_OnClickVrtTab");
static_assert(offsetof(MM_B_DominionWanted_OnClickVrtTab, IIndex) == 0x000000, "Member 'MM_B_DominionWanted_OnClickVrtTab::IIndex' has a wrong offset!");
static_assert(offsetof(MM_B_DominionWanted_OnClickVrtTab, bLocked) == 0x000004, "Member 'MM_B_DominionWanted_OnClickVrtTab::bLocked' has a wrong offset!");

// Function MirMobile.MM_B_DragonGearTransfer.OnClickMainMenu
// 0x0008 (0x0008 - 0x0000)
struct MM_B_DragonGearTransfer_OnClickMainMenu final
{
public:
	int32                                         InIndex;                                           // 0x0000(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          InIsLock;                                          // 0x0004(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_5[0x3];                                        // 0x0005(0x0003)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(MM_B_DragonGearTransfer_OnClickMainMenu) == 0x000004, "Wrong alignment on MM_B_DragonGearTransfer_OnClickMainMenu");
static_assert(sizeof(MM_B_DragonGearTransfer_OnClickMainMenu) == 0x000008, "Wrong size on MM_B_DragonGearTransfer_OnClickMainMenu");
static_assert(offsetof(MM_B_DragonGearTransfer_OnClickMainMenu, InIndex) == 0x000000, "Member 'MM_B_DragonGearTransfer_OnClickMainMenu::InIndex' has a wrong offset!");
static_assert(offsetof(MM_B_DragonGearTransfer_OnClickMainMenu, InIsLock) == 0x000004, "Member 'MM_B_DragonGearTransfer_OnClickMainMenu::InIsLock' has a wrong offset!");

// Function MirMobile.MM_B_DragonGearTransfer.OnClickSubMenu
// 0x0008 (0x0008 - 0x0000)
struct MM_B_DragonGearTransfer_OnClickSubMenu final
{
public:
	int32                                         InIndex;                                           // 0x0000(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          InIsLock;                                          // 0x0004(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_5[0x3];                                        // 0x0005(0x0003)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(MM_B_DragonGearTransfer_OnClickSubMenu) == 0x000004, "Wrong alignment on MM_B_DragonGearTransfer_OnClickSubMenu");
static_assert(sizeof(MM_B_DragonGearTransfer_OnClickSubMenu) == 0x000008, "Wrong size on MM_B_DragonGearTransfer_OnClickSubMenu");
static_assert(offsetof(MM_B_DragonGearTransfer_OnClickSubMenu, InIndex) == 0x000000, "Member 'MM_B_DragonGearTransfer_OnClickSubMenu::InIndex' has a wrong offset!");
static_assert(offsetof(MM_B_DragonGearTransfer_OnClickSubMenu, InIsLock) == 0x000004, "Member 'MM_B_DragonGearTransfer_OnClickSubMenu::InIsLock' has a wrong offset!");

// Function MirMobile.MM_B_DragonicGear.OnClickMainMenu
// 0x0008 (0x0008 - 0x0000)
struct MM_B_DragonicGear_OnClickMainMenu final
{
public:
	int32                                         Idx;                                               // 0x0000(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bLocked;                                           // 0x0004(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_5[0x3];                                        // 0x0005(0x0003)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(MM_B_DragonicGear_OnClickMainMenu) == 0x000004, "Wrong alignment on MM_B_DragonicGear_OnClickMainMenu");
static_assert(sizeof(MM_B_DragonicGear_OnClickMainMenu) == 0x000008, "Wrong size on MM_B_DragonicGear_OnClickMainMenu");
static_assert(offsetof(MM_B_DragonicGear_OnClickMainMenu, Idx) == 0x000000, "Member 'MM_B_DragonicGear_OnClickMainMenu::Idx' has a wrong offset!");
static_assert(offsetof(MM_B_DragonicGear_OnClickMainMenu, bLocked) == 0x000004, "Member 'MM_B_DragonicGear_OnClickMainMenu::bLocked' has a wrong offset!");

// Function MirMobile.MM_MiniGameWidget.EnableAvoid
// 0x0001 (0x0001 - 0x0000)
struct MM_MiniGameWidget_EnableAvoid final
{
public:
	bool                                          bEnable;                                           // 0x0000(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(MM_MiniGameWidget_EnableAvoid) == 0x000001, "Wrong alignment on MM_MiniGameWidget_EnableAvoid");
static_assert(sizeof(MM_MiniGameWidget_EnableAvoid) == 0x000001, "Wrong size on MM_MiniGameWidget_EnableAvoid");
static_assert(offsetof(MM_MiniGameWidget_EnableAvoid, bEnable) == 0x000000, "Member 'MM_MiniGameWidget_EnableAvoid::bEnable' has a wrong offset!");

// Function MirMobile.MM_MiniGameWidget.UpdateHP
// 0x0004 (0x0004 - 0x0000)
struct MM_MiniGameWidget_UpdateHP final
{
public:
	float                                         _Value;                                            // 0x0000(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(MM_MiniGameWidget_UpdateHP) == 0x000004, "Wrong alignment on MM_MiniGameWidget_UpdateHP");
static_assert(sizeof(MM_MiniGameWidget_UpdateHP) == 0x000004, "Wrong size on MM_MiniGameWidget_UpdateHP");
static_assert(offsetof(MM_MiniGameWidget_UpdateHP, _Value) == 0x000000, "Member 'MM_MiniGameWidget_UpdateHP::_Value' has a wrong offset!");

// Function MirMobile.MM_MiniGameWidget.UpdateScore
// 0x0004 (0x0004 - 0x0000)
struct MM_MiniGameWidget_UpdateScore final
{
public:
	int32                                         _Value;                                            // 0x0000(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(MM_MiniGameWidget_UpdateScore) == 0x000004, "Wrong alignment on MM_MiniGameWidget_UpdateScore");
static_assert(sizeof(MM_MiniGameWidget_UpdateScore) == 0x000004, "Wrong size on MM_MiniGameWidget_UpdateScore");
static_assert(offsetof(MM_MiniGameWidget_UpdateScore, _Value) == 0x000000, "Member 'MM_MiniGameWidget_UpdateScore::_Value' has a wrong offset!");

// Function MirMobile.MM_MagicStoneEquip.OnClickSlot
// 0x0004 (0x0004 - 0x0000)
struct MM_MagicStoneEquip_OnClickSlot final
{
public:
	int32                                         Slot_index_;                                       // 0x0000(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(MM_MagicStoneEquip_OnClickSlot) == 0x000004, "Wrong alignment on MM_MagicStoneEquip_OnClickSlot");
static_assert(sizeof(MM_MagicStoneEquip_OnClickSlot) == 0x000004, "Wrong size on MM_MagicStoneEquip_OnClickSlot");
static_assert(offsetof(MM_MagicStoneEquip_OnClickSlot, Slot_index_) == 0x000000, "Member 'MM_MagicStoneEquip_OnClickSlot::Slot_index_' has a wrong offset!");

// Function MirMobile.MM_MagicStoneEquip.OnClickUnmountSlot
// 0x0004 (0x0004 - 0x0000)
struct MM_MagicStoneEquip_OnClickUnmountSlot final
{
public:
	int32                                         Slot_index_;                                       // 0x0000(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(MM_MagicStoneEquip_OnClickUnmountSlot) == 0x000004, "Wrong alignment on MM_MagicStoneEquip_OnClickUnmountSlot");
static_assert(sizeof(MM_MagicStoneEquip_OnClickUnmountSlot) == 0x000004, "Wrong size on MM_MagicStoneEquip_OnClickUnmountSlot");
static_assert(offsetof(MM_MagicStoneEquip_OnClickUnmountSlot, Slot_index_) == 0x000000, "Member 'MM_MagicStoneEquip_OnClickUnmountSlot::Slot_index_' has a wrong offset!");

// Function MirMobile.MM_B_Friend.OnChangeTab
// 0x0008 (0x0008 - 0x0000)
struct MM_B_Friend_OnChangeTab final
{
public:
	int32                                         IIndex;                                            // 0x0000(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bLocked;                                           // 0x0004(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_5[0x3];                                        // 0x0005(0x0003)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(MM_B_Friend_OnChangeTab) == 0x000004, "Wrong alignment on MM_B_Friend_OnChangeTab");
static_assert(sizeof(MM_B_Friend_OnChangeTab) == 0x000008, "Wrong size on MM_B_Friend_OnChangeTab");
static_assert(offsetof(MM_B_Friend_OnChangeTab, IIndex) == 0x000000, "Member 'MM_B_Friend_OnChangeTab::IIndex' has a wrong offset!");
static_assert(offsetof(MM_B_Friend_OnChangeTab, bLocked) == 0x000004, "Member 'MM_B_Friend_OnChangeTab::bLocked' has a wrong offset!");

// Function MirMobile.MM_B_Friend.OnChangeTextSearchUser
// 0x0018 (0x0018 - 0x0000)
struct MM_B_Friend_OnChangeTextSearchUser final
{
public:
	class FText                                   Text;                                              // 0x0000(0x0018)(ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
};
static_assert(alignof(MM_B_Friend_OnChangeTextSearchUser) == 0x000008, "Wrong alignment on MM_B_Friend_OnChangeTextSearchUser");
static_assert(sizeof(MM_B_Friend_OnChangeTextSearchUser) == 0x000018, "Wrong size on MM_B_Friend_OnChangeTextSearchUser");
static_assert(offsetof(MM_B_Friend_OnChangeTextSearchUser, Text) == 0x000000, "Member 'MM_B_Friend_OnChangeTextSearchUser::Text' has a wrong offset!");

// Function MirMobile.MM_B_Friend.OnTextSearchUserCommitted
// 0x0020 (0x0020 - 0x0000)
struct MM_B_Friend_OnTextSearchUserCommitted final
{
public:
	class FText                                   Text;                                              // 0x0000(0x0018)(ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
	ETextCommit                                   CommitMethod;                                      // 0x0018(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_19[0x7];                                       // 0x0019(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(MM_B_Friend_OnTextSearchUserCommitted) == 0x000008, "Wrong alignment on MM_B_Friend_OnTextSearchUserCommitted");
static_assert(sizeof(MM_B_Friend_OnTextSearchUserCommitted) == 0x000020, "Wrong size on MM_B_Friend_OnTextSearchUserCommitted");
static_assert(offsetof(MM_B_Friend_OnTextSearchUserCommitted, Text) == 0x000000, "Member 'MM_B_Friend_OnTextSearchUserCommitted::Text' has a wrong offset!");
static_assert(offsetof(MM_B_Friend_OnTextSearchUserCommitted, CommitMethod) == 0x000018, "Member 'MM_B_Friend_OnTextSearchUserCommitted::CommitMethod' has a wrong offset!");

// Function MirMobile.MM_B_Goods.OnClickCostSubBtn
// 0x0008 (0x0008 - 0x0000)
struct MM_B_Goods_OnClickCostSubBtn final
{
public:
	int32                                         ICostMain;                                         // 0x0000(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         ICostSub;                                          // 0x0004(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(MM_B_Goods_OnClickCostSubBtn) == 0x000004, "Wrong alignment on MM_B_Goods_OnClickCostSubBtn");
static_assert(sizeof(MM_B_Goods_OnClickCostSubBtn) == 0x000008, "Wrong size on MM_B_Goods_OnClickCostSubBtn");
static_assert(offsetof(MM_B_Goods_OnClickCostSubBtn, ICostMain) == 0x000000, "Member 'MM_B_Goods_OnClickCostSubBtn::ICostMain' has a wrong offset!");
static_assert(offsetof(MM_B_Goods_OnClickCostSubBtn, ICostSub) == 0x000004, "Member 'MM_B_Goods_OnClickCostSubBtn::ICostSub' has a wrong offset!");

// Function MirMobile.MM_B_Guild_Creation.OnChangeGuildName
// 0x0018 (0x0018 - 0x0000)
struct MM_B_Guild_Creation_OnChangeGuildName final
{
public:
	class FText                                   Text;                                              // 0x0000(0x0018)(ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
};
static_assert(alignof(MM_B_Guild_Creation_OnChangeGuildName) == 0x000008, "Wrong alignment on MM_B_Guild_Creation_OnChangeGuildName");
static_assert(sizeof(MM_B_Guild_Creation_OnChangeGuildName) == 0x000018, "Wrong size on MM_B_Guild_Creation_OnChangeGuildName");
static_assert(offsetof(MM_B_Guild_Creation_OnChangeGuildName, Text) == 0x000000, "Member 'MM_B_Guild_Creation_OnChangeGuildName::Text' has a wrong offset!");

// Function MirMobile.MM_B_Guild_Creation.PlayEndAnimation
// 0x0004 (0x0004 - 0x0000)
struct MM_B_Guild_Creation_PlayEndAnimation final
{
public:
	float                                         ReturnValue;                                       // 0x0000(0x0004)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(MM_B_Guild_Creation_PlayEndAnimation) == 0x000004, "Wrong alignment on MM_B_Guild_Creation_PlayEndAnimation");
static_assert(sizeof(MM_B_Guild_Creation_PlayEndAnimation) == 0x000004, "Wrong size on MM_B_Guild_Creation_PlayEndAnimation");
static_assert(offsetof(MM_B_Guild_Creation_PlayEndAnimation, ReturnValue) == 0x000000, "Member 'MM_B_Guild_Creation_PlayEndAnimation::ReturnValue' has a wrong offset!");

// Function MirMobile.MM_MyCharinfo.OnClickEquipSlot
// 0x0010 (0x0010 - 0x0000)
struct MM_MyCharinfo_OnClickEquipSlot final
{
public:
	int64                                         IUID;                                              // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         ITID;                                              // 0x0008(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         IEquipPosition;                                    // 0x000C(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(MM_MyCharinfo_OnClickEquipSlot) == 0x000008, "Wrong alignment on MM_MyCharinfo_OnClickEquipSlot");
static_assert(sizeof(MM_MyCharinfo_OnClickEquipSlot) == 0x000010, "Wrong size on MM_MyCharinfo_OnClickEquipSlot");
static_assert(offsetof(MM_MyCharinfo_OnClickEquipSlot, IUID) == 0x000000, "Member 'MM_MyCharinfo_OnClickEquipSlot::IUID' has a wrong offset!");
static_assert(offsetof(MM_MyCharinfo_OnClickEquipSlot, ITID) == 0x000008, "Member 'MM_MyCharinfo_OnClickEquipSlot::ITID' has a wrong offset!");
static_assert(offsetof(MM_MyCharinfo_OnClickEquipSlot, IEquipPosition) == 0x00000C, "Member 'MM_MyCharinfo_OnClickEquipSlot::IEquipPosition' has a wrong offset!");

// Function MirMobile.MM_EntityBase.ChangeCurrentFSM
// 0x0001 (0x0001 - 0x0000)
struct MM_EntityBase_ChangeCurrentFSM final
{
public:
	EFSM_TYPE                                     NewFSM;                                            // 0x0000(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(MM_EntityBase_ChangeCurrentFSM) == 0x000001, "Wrong alignment on MM_EntityBase_ChangeCurrentFSM");
static_assert(sizeof(MM_EntityBase_ChangeCurrentFSM) == 0x000001, "Wrong size on MM_EntityBase_ChangeCurrentFSM");
static_assert(offsetof(MM_EntityBase_ChangeCurrentFSM, NewFSM) == 0x000000, "Member 'MM_EntityBase_ChangeCurrentFSM::NewFSM' has a wrong offset!");

// Function MirMobile.MM_EntityBase.ChangeSubState
// 0x0004 (0x0004 - 0x0000)
struct MM_EntityBase_ChangeSubState final
{
public:
	int32                                         NewSubState;                                       // 0x0000(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(MM_EntityBase_ChangeSubState) == 0x000004, "Wrong alignment on MM_EntityBase_ChangeSubState");
static_assert(sizeof(MM_EntityBase_ChangeSubState) == 0x000004, "Wrong size on MM_EntityBase_ChangeSubState");
static_assert(offsetof(MM_EntityBase_ChangeSubState, NewSubState) == 0x000000, "Member 'MM_EntityBase_ChangeSubState::NewSubState' has a wrong offset!");

// Function MirMobile.MM_EntityBase.GetAnimInstance
// 0x0008 (0x0008 - 0x0000)
struct MM_EntityBase_GetAnimInstance final
{
public:
	class UMM_AnimInstance*                       ReturnValue;                                       // 0x0000(0x0008)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(MM_EntityBase_GetAnimInstance) == 0x000008, "Wrong alignment on MM_EntityBase_GetAnimInstance");
static_assert(sizeof(MM_EntityBase_GetAnimInstance) == 0x000008, "Wrong size on MM_EntityBase_GetAnimInstance");
static_assert(offsetof(MM_EntityBase_GetAnimInstance, ReturnValue) == 0x000000, "Member 'MM_EntityBase_GetAnimInstance::ReturnValue' has a wrong offset!");

// Function MirMobile.MM_EntityBase.GetCurrentFSM
// 0x0001 (0x0001 - 0x0000)
struct MM_EntityBase_GetCurrentFSM final
{
public:
	EFSM_TYPE                                     ReturnValue;                                       // 0x0000(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(MM_EntityBase_GetCurrentFSM) == 0x000001, "Wrong alignment on MM_EntityBase_GetCurrentFSM");
static_assert(sizeof(MM_EntityBase_GetCurrentFSM) == 0x000001, "Wrong size on MM_EntityBase_GetCurrentFSM");
static_assert(offsetof(MM_EntityBase_GetCurrentFSM, ReturnValue) == 0x000000, "Member 'MM_EntityBase_GetCurrentFSM::ReturnValue' has a wrong offset!");

// Function MirMobile.MM_EntityBase.GetMesh
// 0x0008 (0x0008 - 0x0000)
struct MM_EntityBase_GetMesh final
{
public:
	class USkeletalMeshComponent*                 ReturnValue;                                       // 0x0000(0x0008)(ExportObject, Parm, OutParm, ZeroConstructor, ReturnParm, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(MM_EntityBase_GetMesh) == 0x000008, "Wrong alignment on MM_EntityBase_GetMesh");
static_assert(sizeof(MM_EntityBase_GetMesh) == 0x000008, "Wrong size on MM_EntityBase_GetMesh");
static_assert(offsetof(MM_EntityBase_GetMesh, ReturnValue) == 0x000000, "Member 'MM_EntityBase_GetMesh::ReturnValue' has a wrong offset!");

// Function MirMobile.MM_EntityBase.GetPreFSM
// 0x0001 (0x0001 - 0x0000)
struct MM_EntityBase_GetPreFSM final
{
public:
	EFSM_TYPE                                     ReturnValue;                                       // 0x0000(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(MM_EntityBase_GetPreFSM) == 0x000001, "Wrong alignment on MM_EntityBase_GetPreFSM");
static_assert(sizeof(MM_EntityBase_GetPreFSM) == 0x000001, "Wrong size on MM_EntityBase_GetPreFSM");
static_assert(offsetof(MM_EntityBase_GetPreFSM, ReturnValue) == 0x000000, "Member 'MM_EntityBase_GetPreFSM::ReturnValue' has a wrong offset!");

// Function MirMobile.MM_EntityBase.GetSubState
// 0x0004 (0x0004 - 0x0000)
struct MM_EntityBase_GetSubState final
{
public:
	int32                                         ReturnValue;                                       // 0x0000(0x0004)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(MM_EntityBase_GetSubState) == 0x000004, "Wrong alignment on MM_EntityBase_GetSubState");
static_assert(sizeof(MM_EntityBase_GetSubState) == 0x000004, "Wrong size on MM_EntityBase_GetSubState");
static_assert(offsetof(MM_EntityBase_GetSubState, ReturnValue) == 0x000000, "Member 'MM_EntityBase_GetSubState::ReturnValue' has a wrong offset!");

// Function MirMobile.MM_CharacterPawnBase.GetFSMComponent
// 0x0008 (0x0008 - 0x0000)
struct MM_CharacterPawnBase_GetFSMComponent final
{
public:
	class UMM_FSMComponent*                       ReturnValue;                                       // 0x0000(0x0008)(ExportObject, Parm, OutParm, ZeroConstructor, ReturnParm, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(MM_CharacterPawnBase_GetFSMComponent) == 0x000008, "Wrong alignment on MM_CharacterPawnBase_GetFSMComponent");
static_assert(sizeof(MM_CharacterPawnBase_GetFSMComponent) == 0x000008, "Wrong size on MM_CharacterPawnBase_GetFSMComponent");
static_assert(offsetof(MM_CharacterPawnBase_GetFSMComponent, ReturnValue) == 0x000000, "Member 'MM_CharacterPawnBase_GetFSMComponent::ReturnValue' has a wrong offset!");

// Function MirMobile.MM_CharacterPawnBase.K2_GetPercent_HP
// 0x0004 (0x0004 - 0x0000)
struct MM_CharacterPawnBase_K2_GetPercent_HP final
{
public:
	float                                         ReturnValue;                                       // 0x0000(0x0004)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(MM_CharacterPawnBase_K2_GetPercent_HP) == 0x000004, "Wrong alignment on MM_CharacterPawnBase_K2_GetPercent_HP");
static_assert(sizeof(MM_CharacterPawnBase_K2_GetPercent_HP) == 0x000004, "Wrong size on MM_CharacterPawnBase_K2_GetPercent_HP");
static_assert(offsetof(MM_CharacterPawnBase_K2_GetPercent_HP, ReturnValue) == 0x000000, "Member 'MM_CharacterPawnBase_K2_GetPercent_HP::ReturnValue' has a wrong offset!");

// Function MirMobile.MM_CharacterPawnBase.OnFinishedBeam
// 0x0008 (0x0008 - 0x0000)
struct MM_CharacterPawnBase_OnFinishedBeam final
{
public:
	class UParticleSystemComponent*               FinishedComponent;                                 // 0x0000(0x0008)(Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(MM_CharacterPawnBase_OnFinishedBeam) == 0x000008, "Wrong alignment on MM_CharacterPawnBase_OnFinishedBeam");
static_assert(sizeof(MM_CharacterPawnBase_OnFinishedBeam) == 0x000008, "Wrong size on MM_CharacterPawnBase_OnFinishedBeam");
static_assert(offsetof(MM_CharacterPawnBase_OnFinishedBeam, FinishedComponent) == 0x000000, "Member 'MM_CharacterPawnBase_OnFinishedBeam::FinishedComponent' has a wrong offset!");

// Function MirMobile.MM_CharacterPawnBase.SetCharPointLight
// 0x0008 (0x0008 - 0x0000)
struct MM_CharacterPawnBase_SetCharPointLight final
{
public:
	class UPointLightComponent*                   PointLightComp;                                    // 0x0000(0x0008)(Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(MM_CharacterPawnBase_SetCharPointLight) == 0x000008, "Wrong alignment on MM_CharacterPawnBase_SetCharPointLight");
static_assert(sizeof(MM_CharacterPawnBase_SetCharPointLight) == 0x000008, "Wrong size on MM_CharacterPawnBase_SetCharPointLight");
static_assert(offsetof(MM_CharacterPawnBase_SetCharPointLight, PointLightComp) == 0x000000, "Member 'MM_CharacterPawnBase_SetCharPointLight::PointLightComp' has a wrong offset!");

// Function MirMobile.MM_B_GuildTournament.OnClickMainTab
// 0x0008 (0x0008 - 0x0000)
struct MM_B_GuildTournament_OnClickMainTab final
{
public:
	int32                                         Tab_index_;                                        // 0x0000(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          Locked_;                                           // 0x0004(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_5[0x3];                                        // 0x0005(0x0003)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(MM_B_GuildTournament_OnClickMainTab) == 0x000004, "Wrong alignment on MM_B_GuildTournament_OnClickMainTab");
static_assert(sizeof(MM_B_GuildTournament_OnClickMainTab) == 0x000008, "Wrong size on MM_B_GuildTournament_OnClickMainTab");
static_assert(offsetof(MM_B_GuildTournament_OnClickMainTab, Tab_index_) == 0x000000, "Member 'MM_B_GuildTournament_OnClickMainTab::Tab_index_' has a wrong offset!");
static_assert(offsetof(MM_B_GuildTournament_OnClickMainTab, Locked_) == 0x000004, "Member 'MM_B_GuildTournament_OnClickMainTab::Locked_' has a wrong offset!");

// Function MirMobile.MM_CharacterCustomizingActor.BlueprintEvent_SetActorHiddenInGame
// 0x0001 (0x0001 - 0x0000)
struct MM_CharacterCustomizingActor_BlueprintEvent_SetActorHiddenInGame final
{
public:
	bool                                          bNewHidden;                                        // 0x0000(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(MM_CharacterCustomizingActor_BlueprintEvent_SetActorHiddenInGame) == 0x000001, "Wrong alignment on MM_CharacterCustomizingActor_BlueprintEvent_SetActorHiddenInGame");
static_assert(sizeof(MM_CharacterCustomizingActor_BlueprintEvent_SetActorHiddenInGame) == 0x000001, "Wrong size on MM_CharacterCustomizingActor_BlueprintEvent_SetActorHiddenInGame");
static_assert(offsetof(MM_CharacterCustomizingActor_BlueprintEvent_SetActorHiddenInGame, bNewHidden) == 0x000000, "Member 'MM_CharacterCustomizingActor_BlueprintEvent_SetActorHiddenInGame::bNewHidden' has a wrong offset!");

// Function MirMobile.MM_B_HudFoldMain.OnClickQuickTabSymbol
// 0x0004 (0x0004 - 0x0000)
struct MM_B_HudFoldMain_OnClickQuickTabSymbol final
{
public:
	int32                                         Index_0;                                           // 0x0000(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(MM_B_HudFoldMain_OnClickQuickTabSymbol) == 0x000004, "Wrong alignment on MM_B_HudFoldMain_OnClickQuickTabSymbol");
static_assert(sizeof(MM_B_HudFoldMain_OnClickQuickTabSymbol) == 0x000004, "Wrong size on MM_B_HudFoldMain_OnClickQuickTabSymbol");
static_assert(offsetof(MM_B_HudFoldMain_OnClickQuickTabSymbol, Index_0) == 0x000000, "Member 'MM_B_HudFoldMain_OnClickQuickTabSymbol::Index_0' has a wrong offset!");

// Function MirMobile.MM_CharacterBaseAnimInstance.IsChangeState_AttackToIdle
// 0x0001 (0x0001 - 0x0000)
struct MM_CharacterBaseAnimInstance_IsChangeState_AttackToIdle final
{
public:
	bool                                          ReturnValue;                                       // 0x0000(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(MM_CharacterBaseAnimInstance_IsChangeState_AttackToIdle) == 0x000001, "Wrong alignment on MM_CharacterBaseAnimInstance_IsChangeState_AttackToIdle");
static_assert(sizeof(MM_CharacterBaseAnimInstance_IsChangeState_AttackToIdle) == 0x000001, "Wrong size on MM_CharacterBaseAnimInstance_IsChangeState_AttackToIdle");
static_assert(offsetof(MM_CharacterBaseAnimInstance_IsChangeState_AttackToIdle, ReturnValue) == 0x000000, "Member 'MM_CharacterBaseAnimInstance_IsChangeState_AttackToIdle::ReturnValue' has a wrong offset!");

// Function MirMobile.MM_CharacterBaseAnimInstance.IsChangeState_IdleToAttack
// 0x0001 (0x0001 - 0x0000)
struct MM_CharacterBaseAnimInstance_IsChangeState_IdleToAttack final
{
public:
	bool                                          ReturnValue;                                       // 0x0000(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(MM_CharacterBaseAnimInstance_IsChangeState_IdleToAttack) == 0x000001, "Wrong alignment on MM_CharacterBaseAnimInstance_IsChangeState_IdleToAttack");
static_assert(sizeof(MM_CharacterBaseAnimInstance_IsChangeState_IdleToAttack) == 0x000001, "Wrong size on MM_CharacterBaseAnimInstance_IsChangeState_IdleToAttack");
static_assert(offsetof(MM_CharacterBaseAnimInstance_IsChangeState_IdleToAttack, ReturnValue) == 0x000000, "Member 'MM_CharacterBaseAnimInstance_IsChangeState_IdleToAttack::ReturnValue' has a wrong offset!");

// Function MirMobile.MM_B_Item_make.OnClickListSlot
// 0x0008 (0x0008 - 0x0000)
struct MM_B_Item_make_OnClickListSlot final
{
public:
	class UMM_Item_Make_List_Slot*                _Slot;                                             // 0x0000(0x0008)(Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(MM_B_Item_make_OnClickListSlot) == 0x000008, "Wrong alignment on MM_B_Item_make_OnClickListSlot");
static_assert(sizeof(MM_B_Item_make_OnClickListSlot) == 0x000008, "Wrong size on MM_B_Item_make_OnClickListSlot");
static_assert(offsetof(MM_B_Item_make_OnClickListSlot, _Slot) == 0x000000, "Member 'MM_B_Item_make_OnClickListSlot::_Slot' has a wrong offset!");

// Function MirMobile.MM_B_Item_make.OnClickMainMenu
// 0x0008 (0x0008 - 0x0000)
struct MM_B_Item_make_OnClickMainMenu final
{
public:
	int32                                         Idx;                                               // 0x0000(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bLocked;                                           // 0x0004(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_5[0x3];                                        // 0x0005(0x0003)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(MM_B_Item_make_OnClickMainMenu) == 0x000004, "Wrong alignment on MM_B_Item_make_OnClickMainMenu");
static_assert(sizeof(MM_B_Item_make_OnClickMainMenu) == 0x000008, "Wrong size on MM_B_Item_make_OnClickMainMenu");
static_assert(offsetof(MM_B_Item_make_OnClickMainMenu, Idx) == 0x000000, "Member 'MM_B_Item_make_OnClickMainMenu::Idx' has a wrong offset!");
static_assert(offsetof(MM_B_Item_make_OnClickMainMenu, bLocked) == 0x000004, "Member 'MM_B_Item_make_OnClickMainMenu::bLocked' has a wrong offset!");

// Function MirMobile.MM_B_Item_make.OnClickSubMenu
// 0x0008 (0x0008 - 0x0000)
struct MM_B_Item_make_OnClickSubMenu final
{
public:
	int32                                         Idx;                                               // 0x0000(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bLocked;                                           // 0x0004(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_5[0x3];                                        // 0x0005(0x0003)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(MM_B_Item_make_OnClickSubMenu) == 0x000004, "Wrong alignment on MM_B_Item_make_OnClickSubMenu");
static_assert(sizeof(MM_B_Item_make_OnClickSubMenu) == 0x000008, "Wrong size on MM_B_Item_make_OnClickSubMenu");
static_assert(offsetof(MM_B_Item_make_OnClickSubMenu, Idx) == 0x000000, "Member 'MM_B_Item_make_OnClickSubMenu::Idx' has a wrong offset!");
static_assert(offsetof(MM_B_Item_make_OnClickSubMenu, bLocked) == 0x000004, "Member 'MM_B_Item_make_OnClickSubMenu::bLocked' has a wrong offset!");

// Function MirMobile.MM_B_Item_make.ToggleMakeFilter
// 0x0001 (0x0001 - 0x0000)
struct MM_B_Item_make_ToggleMakeFilter final
{
public:
	bool                                          IsChecked;                                         // 0x0000(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(MM_B_Item_make_ToggleMakeFilter) == 0x000001, "Wrong alignment on MM_B_Item_make_ToggleMakeFilter");
static_assert(sizeof(MM_B_Item_make_ToggleMakeFilter) == 0x000001, "Wrong size on MM_B_Item_make_ToggleMakeFilter");
static_assert(offsetof(MM_B_Item_make_ToggleMakeFilter, IsChecked) == 0x000000, "Member 'MM_B_Item_make_ToggleMakeFilter::IsChecked' has a wrong offset!");

// Function MirMobile.MM_PortraitCaptureActor.CapturePortraitEvent
// 0x0008 (0x0008 - 0x0000)
struct MM_PortraitCaptureActor_CapturePortraitEvent final
{
public:
	int32                                         SizeX;                                             // 0x0000(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         SizeY;                                             // 0x0004(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(MM_PortraitCaptureActor_CapturePortraitEvent) == 0x000004, "Wrong alignment on MM_PortraitCaptureActor_CapturePortraitEvent");
static_assert(sizeof(MM_PortraitCaptureActor_CapturePortraitEvent) == 0x000008, "Wrong size on MM_PortraitCaptureActor_CapturePortraitEvent");
static_assert(offsetof(MM_PortraitCaptureActor_CapturePortraitEvent, SizeX) == 0x000000, "Member 'MM_PortraitCaptureActor_CapturePortraitEvent::SizeX' has a wrong offset!");
static_assert(offsetof(MM_PortraitCaptureActor_CapturePortraitEvent, SizeY) == 0x000004, "Member 'MM_PortraitCaptureActor_CapturePortraitEvent::SizeY' has a wrong offset!");

// Function MirMobile.MM_PortraitCaptureActor.CreatePortraitTextureByRenderTarget
// 0x0010 (0x0010 - 0x0000)
struct MM_PortraitCaptureActor_CreatePortraitTextureByRenderTarget final
{
public:
	class UTextureRenderTarget2D*                 RenderTarget;                                      // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UTexture2D*                             ReturnValue;                                       // 0x0008(0x0008)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(MM_PortraitCaptureActor_CreatePortraitTextureByRenderTarget) == 0x000008, "Wrong alignment on MM_PortraitCaptureActor_CreatePortraitTextureByRenderTarget");
static_assert(sizeof(MM_PortraitCaptureActor_CreatePortraitTextureByRenderTarget) == 0x000010, "Wrong size on MM_PortraitCaptureActor_CreatePortraitTextureByRenderTarget");
static_assert(offsetof(MM_PortraitCaptureActor_CreatePortraitTextureByRenderTarget, RenderTarget) == 0x000000, "Member 'MM_PortraitCaptureActor_CreatePortraitTextureByRenderTarget::RenderTarget' has a wrong offset!");
static_assert(offsetof(MM_PortraitCaptureActor_CreatePortraitTextureByRenderTarget, ReturnValue) == 0x000008, "Member 'MM_PortraitCaptureActor_CreatePortraitTextureByRenderTarget::ReturnValue' has a wrong offset!");

// Function MirMobile.MM_PortraitCaptureActor.SetCaptureCameraDataEvent
// 0x0001 (0x0001 - 0x0000)
struct MM_PortraitCaptureActor_SetCaptureCameraDataEvent final
{
public:
	EPlayerClassID                                ClassType;                                         // 0x0000(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(MM_PortraitCaptureActor_SetCaptureCameraDataEvent) == 0x000001, "Wrong alignment on MM_PortraitCaptureActor_SetCaptureCameraDataEvent");
static_assert(sizeof(MM_PortraitCaptureActor_SetCaptureCameraDataEvent) == 0x000001, "Wrong size on MM_PortraitCaptureActor_SetCaptureCameraDataEvent");
static_assert(offsetof(MM_PortraitCaptureActor_SetCaptureCameraDataEvent, ClassType) == 0x000000, "Member 'MM_PortraitCaptureActor_SetCaptureCameraDataEvent::ClassType' has a wrong offset!");

// Function MirMobile.MM_PortraitCaptureActor.SetPortraitRenderTarget
// 0x0008 (0x0008 - 0x0000)
struct MM_PortraitCaptureActor_SetPortraitRenderTarget final
{
public:
	class UTextureRenderTarget2D*                 RenderTarget;                                      // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(MM_PortraitCaptureActor_SetPortraitRenderTarget) == 0x000008, "Wrong alignment on MM_PortraitCaptureActor_SetPortraitRenderTarget");
static_assert(sizeof(MM_PortraitCaptureActor_SetPortraitRenderTarget) == 0x000008, "Wrong size on MM_PortraitCaptureActor_SetPortraitRenderTarget");
static_assert(offsetof(MM_PortraitCaptureActor_SetPortraitRenderTarget, RenderTarget) == 0x000000, "Member 'MM_PortraitCaptureActor_SetPortraitRenderTarget::RenderTarget' has a wrong offset!");

// Function MirMobile.MM_PortraitCaptureActor.SetPortraitWidget
// 0x0008 (0x0008 - 0x0000)
struct MM_PortraitCaptureActor_SetPortraitWidget final
{
public:
	class UTexture2D*                             PTexture2D;                                        // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(MM_PortraitCaptureActor_SetPortraitWidget) == 0x000008, "Wrong alignment on MM_PortraitCaptureActor_SetPortraitWidget");
static_assert(sizeof(MM_PortraitCaptureActor_SetPortraitWidget) == 0x000008, "Wrong size on MM_PortraitCaptureActor_SetPortraitWidget");
static_assert(offsetof(MM_PortraitCaptureActor_SetPortraitWidget, PTexture2D) == 0x000000, "Member 'MM_PortraitCaptureActor_SetPortraitWidget::PTexture2D' has a wrong offset!");

// Function MirMobile.MM_PortraitCaptureActor.TEST_CaptureTest1
// 0x0008 (0x0008 - 0x0000)
struct MM_PortraitCaptureActor_TEST_CaptureTest1 final
{
public:
	class UTexture2D*                             ReturnValue;                                       // 0x0000(0x0008)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(MM_PortraitCaptureActor_TEST_CaptureTest1) == 0x000008, "Wrong alignment on MM_PortraitCaptureActor_TEST_CaptureTest1");
static_assert(sizeof(MM_PortraitCaptureActor_TEST_CaptureTest1) == 0x000008, "Wrong size on MM_PortraitCaptureActor_TEST_CaptureTest1");
static_assert(offsetof(MM_PortraitCaptureActor_TEST_CaptureTest1, ReturnValue) == 0x000000, "Member 'MM_PortraitCaptureActor_TEST_CaptureTest1::ReturnValue' has a wrong offset!");

// Function MirMobile.MM_PortraitCaptureActor.TEST_SetRenderTargetUI
// 0x0008 (0x0008 - 0x0000)
struct MM_PortraitCaptureActor_TEST_SetRenderTargetUI final
{
public:
	class UImage*                                 PImage;                                            // 0x0000(0x0008)(Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(MM_PortraitCaptureActor_TEST_SetRenderTargetUI) == 0x000008, "Wrong alignment on MM_PortraitCaptureActor_TEST_SetRenderTargetUI");
static_assert(sizeof(MM_PortraitCaptureActor_TEST_SetRenderTargetUI) == 0x000008, "Wrong size on MM_PortraitCaptureActor_TEST_SetRenderTargetUI");
static_assert(offsetof(MM_PortraitCaptureActor_TEST_SetRenderTargetUI, PImage) == 0x000000, "Member 'MM_PortraitCaptureActor_TEST_SetRenderTargetUI::PImage' has a wrong offset!");

// Function MirMobile.MM_B_ItemCollection.OnChangeSlot
// 0x0004 (0x0004 - 0x0000)
struct MM_B_ItemCollection_OnChangeSlot final
{
public:
	int32                                         ISlotID;                                           // 0x0000(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(MM_B_ItemCollection_OnChangeSlot) == 0x000004, "Wrong alignment on MM_B_ItemCollection_OnChangeSlot");
static_assert(sizeof(MM_B_ItemCollection_OnChangeSlot) == 0x000004, "Wrong size on MM_B_ItemCollection_OnChangeSlot");
static_assert(offsetof(MM_B_ItemCollection_OnChangeSlot, ISlotID) == 0x000000, "Member 'MM_B_ItemCollection_OnChangeSlot::ISlotID' has a wrong offset!");

// Function MirMobile.MM_B_ItemCollection.OnClickCollectGroup
// 0x0008 (0x0008 - 0x0000)
struct MM_B_ItemCollection_OnClickCollectGroup final
{
public:
	int32                                         SlotIndex;                                         // 0x0000(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          IsLocked;                                          // 0x0004(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_5[0x3];                                        // 0x0005(0x0003)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(MM_B_ItemCollection_OnClickCollectGroup) == 0x000004, "Wrong alignment on MM_B_ItemCollection_OnClickCollectGroup");
static_assert(sizeof(MM_B_ItemCollection_OnClickCollectGroup) == 0x000008, "Wrong size on MM_B_ItemCollection_OnClickCollectGroup");
static_assert(offsetof(MM_B_ItemCollection_OnClickCollectGroup, SlotIndex) == 0x000000, "Member 'MM_B_ItemCollection_OnClickCollectGroup::SlotIndex' has a wrong offset!");
static_assert(offsetof(MM_B_ItemCollection_OnClickCollectGroup, IsLocked) == 0x000004, "Member 'MM_B_ItemCollection_OnClickCollectGroup::IsLocked' has a wrong offset!");

// Function MirMobile.MM_B_ItemCollection.OnClickCollectType
// 0x0008 (0x0008 - 0x0000)
struct MM_B_ItemCollection_OnClickCollectType final
{
public:
	int32                                         SlotIndex;                                         // 0x0000(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          IsLocked;                                          // 0x0004(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_5[0x3];                                        // 0x0005(0x0003)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(MM_B_ItemCollection_OnClickCollectType) == 0x000004, "Wrong alignment on MM_B_ItemCollection_OnClickCollectType");
static_assert(sizeof(MM_B_ItemCollection_OnClickCollectType) == 0x000008, "Wrong size on MM_B_ItemCollection_OnClickCollectType");
static_assert(offsetof(MM_B_ItemCollection_OnClickCollectType, SlotIndex) == 0x000000, "Member 'MM_B_ItemCollection_OnClickCollectType::SlotIndex' has a wrong offset!");
static_assert(offsetof(MM_B_ItemCollection_OnClickCollectType, IsLocked) == 0x000004, "Member 'MM_B_ItemCollection_OnClickCollectType::IsLocked' has a wrong offset!");

// Function MirMobile.MM_B_ItemCollection.OnClickTab
// 0x0004 (0x0004 - 0x0000)
struct MM_B_ItemCollection_OnClickTab final
{
public:
	int32                                         IGroupSlotID;                                      // 0x0000(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(MM_B_ItemCollection_OnClickTab) == 0x000004, "Wrong alignment on MM_B_ItemCollection_OnClickTab");
static_assert(sizeof(MM_B_ItemCollection_OnClickTab) == 0x000004, "Wrong size on MM_B_ItemCollection_OnClickTab");
static_assert(offsetof(MM_B_ItemCollection_OnClickTab, IGroupSlotID) == 0x000000, "Member 'MM_B_ItemCollection_OnClickTab::IGroupSlotID' has a wrong offset!");

// Function MirMobile.MM_B_ItemCollection.OnClickTierSlot
// 0x0008 (0x0008 - 0x0000)
struct MM_B_ItemCollection_OnClickTierSlot final
{
public:
	int32                                         IIndex;                                            // 0x0000(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bSlotUpdate;                                       // 0x0004(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_5[0x3];                                        // 0x0005(0x0003)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(MM_B_ItemCollection_OnClickTierSlot) == 0x000004, "Wrong alignment on MM_B_ItemCollection_OnClickTierSlot");
static_assert(sizeof(MM_B_ItemCollection_OnClickTierSlot) == 0x000008, "Wrong size on MM_B_ItemCollection_OnClickTierSlot");
static_assert(offsetof(MM_B_ItemCollection_OnClickTierSlot, IIndex) == 0x000000, "Member 'MM_B_ItemCollection_OnClickTierSlot::IIndex' has a wrong offset!");
static_assert(offsetof(MM_B_ItemCollection_OnClickTierSlot, bSlotUpdate) == 0x000004, "Member 'MM_B_ItemCollection_OnClickTierSlot::bSlotUpdate' has a wrong offset!");

// Function MirMobile.MM_B_ItemCollection.OnComboBoxChanged
// 0x0010 (0x0010 - 0x0000)
struct MM_B_ItemCollection_OnComboBoxChanged final
{
public:
	class FString                                 StrSelectItem;                                     // 0x0000(0x0010)(Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(MM_B_ItemCollection_OnComboBoxChanged) == 0x000008, "Wrong alignment on MM_B_ItemCollection_OnComboBoxChanged");
static_assert(sizeof(MM_B_ItemCollection_OnComboBoxChanged) == 0x000010, "Wrong size on MM_B_ItemCollection_OnComboBoxChanged");
static_assert(offsetof(MM_B_ItemCollection_OnComboBoxChanged, StrSelectItem) == 0x000000, "Member 'MM_B_ItemCollection_OnComboBoxChanged::StrSelectItem' has a wrong offset!");

// Function MirMobile.MM_B_ItemCollection.OnCommitEdit
// 0x0020 (0x0020 - 0x0000)
struct MM_B_ItemCollection_OnCommitEdit final
{
public:
	class FText                                   Text;                                              // 0x0000(0x0018)(ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
	ETextCommit                                   CommitMethod;                                      // 0x0018(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_19[0x7];                                       // 0x0019(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(MM_B_ItemCollection_OnCommitEdit) == 0x000008, "Wrong alignment on MM_B_ItemCollection_OnCommitEdit");
static_assert(sizeof(MM_B_ItemCollection_OnCommitEdit) == 0x000020, "Wrong size on MM_B_ItemCollection_OnCommitEdit");
static_assert(offsetof(MM_B_ItemCollection_OnCommitEdit, Text) == 0x000000, "Member 'MM_B_ItemCollection_OnCommitEdit::Text' has a wrong offset!");
static_assert(offsetof(MM_B_ItemCollection_OnCommitEdit, CommitMethod) == 0x000018, "Member 'MM_B_ItemCollection_OnCommitEdit::CommitMethod' has a wrong offset!");

// Function MirMobile.MM_B_ItemCollection.IsCollectAble
// 0x0008 (0x0008 - 0x0000)
struct MM_B_ItemCollection_IsCollectAble final
{
public:
	int32                                         CollectionId;                                      // 0x0000(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          ReturnValue;                                       // 0x0004(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_5[0x3];                                        // 0x0005(0x0003)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(MM_B_ItemCollection_IsCollectAble) == 0x000004, "Wrong alignment on MM_B_ItemCollection_IsCollectAble");
static_assert(sizeof(MM_B_ItemCollection_IsCollectAble) == 0x000008, "Wrong size on MM_B_ItemCollection_IsCollectAble");
static_assert(offsetof(MM_B_ItemCollection_IsCollectAble, CollectionId) == 0x000000, "Member 'MM_B_ItemCollection_IsCollectAble::CollectionId' has a wrong offset!");
static_assert(offsetof(MM_B_ItemCollection_IsCollectAble, ReturnValue) == 0x000004, "Member 'MM_B_ItemCollection_IsCollectAble::ReturnValue' has a wrong offset!");

// Function MirMobile.MM_B_ItemExchange.OnClickHorizonTab
// 0x0008 (0x0008 - 0x0000)
struct MM_B_ItemExchange_OnClickHorizonTab final
{
public:
	int32                                         ITabIndex;                                         // 0x0000(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bLocked;                                           // 0x0004(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_5[0x3];                                        // 0x0005(0x0003)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(MM_B_ItemExchange_OnClickHorizonTab) == 0x000004, "Wrong alignment on MM_B_ItemExchange_OnClickHorizonTab");
static_assert(sizeof(MM_B_ItemExchange_OnClickHorizonTab) == 0x000008, "Wrong size on MM_B_ItemExchange_OnClickHorizonTab");
static_assert(offsetof(MM_B_ItemExchange_OnClickHorizonTab, ITabIndex) == 0x000000, "Member 'MM_B_ItemExchange_OnClickHorizonTab::ITabIndex' has a wrong offset!");
static_assert(offsetof(MM_B_ItemExchange_OnClickHorizonTab, bLocked) == 0x000004, "Member 'MM_B_ItemExchange_OnClickHorizonTab::bLocked' has a wrong offset!");

// Function MirMobile.MM_B_ItemExchange.OnClickInvenSlot
// 0x0010 (0x0010 - 0x0000)
struct MM_B_ItemExchange_OnClickInvenSlot final
{
public:
	int64                                         _UID;                                              // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         _TID;                                              // 0x0008(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         _EquipPos;                                         // 0x000C(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(MM_B_ItemExchange_OnClickInvenSlot) == 0x000008, "Wrong alignment on MM_B_ItemExchange_OnClickInvenSlot");
static_assert(sizeof(MM_B_ItemExchange_OnClickInvenSlot) == 0x000010, "Wrong size on MM_B_ItemExchange_OnClickInvenSlot");
static_assert(offsetof(MM_B_ItemExchange_OnClickInvenSlot, _UID) == 0x000000, "Member 'MM_B_ItemExchange_OnClickInvenSlot::_UID' has a wrong offset!");
static_assert(offsetof(MM_B_ItemExchange_OnClickInvenSlot, _TID) == 0x000008, "Member 'MM_B_ItemExchange_OnClickInvenSlot::_TID' has a wrong offset!");
static_assert(offsetof(MM_B_ItemExchange_OnClickInvenSlot, _EquipPos) == 0x00000C, "Member 'MM_B_ItemExchange_OnClickInvenSlot::_EquipPos' has a wrong offset!");

// Function MirMobile.MM_B_ItemExchange.OnClickVerticalTab
// 0x0008 (0x0008 - 0x0000)
struct MM_B_ItemExchange_OnClickVerticalTab final
{
public:
	int32                                         ITabIndex;                                         // 0x0000(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bLocked;                                           // 0x0004(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_5[0x3];                                        // 0x0005(0x0003)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(MM_B_ItemExchange_OnClickVerticalTab) == 0x000004, "Wrong alignment on MM_B_ItemExchange_OnClickVerticalTab");
static_assert(sizeof(MM_B_ItemExchange_OnClickVerticalTab) == 0x000008, "Wrong size on MM_B_ItemExchange_OnClickVerticalTab");
static_assert(offsetof(MM_B_ItemExchange_OnClickVerticalTab, ITabIndex) == 0x000000, "Member 'MM_B_ItemExchange_OnClickVerticalTab::ITabIndex' has a wrong offset!");
static_assert(offsetof(MM_B_ItemExchange_OnClickVerticalTab, bLocked) == 0x000004, "Member 'MM_B_ItemExchange_OnClickVerticalTab::bLocked' has a wrong offset!");

// Function MirMobile.MM_PetMain.ShowPetQuickTab
// 0x0001 (0x0001 - 0x0000)
struct MM_PetMain_ShowPetQuickTab final
{
public:
	bool                                          bShow;                                             // 0x0000(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(MM_PetMain_ShowPetQuickTab) == 0x000001, "Wrong alignment on MM_PetMain_ShowPetQuickTab");
static_assert(sizeof(MM_PetMain_ShowPetQuickTab) == 0x000001, "Wrong size on MM_PetMain_ShowPetQuickTab");
static_assert(offsetof(MM_PetMain_ShowPetQuickTab, bShow) == 0x000000, "Member 'MM_PetMain_ShowPetQuickTab::bShow' has a wrong offset!");

// Function MirMobile.MM_B_Login.SetAble_ScreenBtn
// 0x0001 (0x0001 - 0x0000)
struct MM_B_Login_SetAble_ScreenBtn final
{
public:
	bool                                          bAble;                                             // 0x0000(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(MM_B_Login_SetAble_ScreenBtn) == 0x000001, "Wrong alignment on MM_B_Login_SetAble_ScreenBtn");
static_assert(sizeof(MM_B_Login_SetAble_ScreenBtn) == 0x000001, "Wrong size on MM_B_Login_SetAble_ScreenBtn");
static_assert(offsetof(MM_B_Login_SetAble_ScreenBtn, bAble) == 0x000000, "Member 'MM_B_Login_SetAble_ScreenBtn::bAble' has a wrong offset!");

// Function MirMobile.MM_B_MagicOrbGrow.OnClickMaterialSlot
// 0x0008 (0x0008 - 0x0000)
struct MM_B_MagicOrbGrow_OnClickMaterialSlot final
{
public:
	class UMM_Slot_Base*                          Clicked_slot_;                                     // 0x0000(0x0008)(Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(MM_B_MagicOrbGrow_OnClickMaterialSlot) == 0x000008, "Wrong alignment on MM_B_MagicOrbGrow_OnClickMaterialSlot");
static_assert(sizeof(MM_B_MagicOrbGrow_OnClickMaterialSlot) == 0x000008, "Wrong size on MM_B_MagicOrbGrow_OnClickMaterialSlot");
static_assert(offsetof(MM_B_MagicOrbGrow_OnClickMaterialSlot, Clicked_slot_) == 0x000000, "Member 'MM_B_MagicOrbGrow_OnClickMaterialSlot::Clicked_slot_' has a wrong offset!");

// Function MirMobile.MM_B_Mail.OnClickedVerticalTabBtn
// 0x0008 (0x0008 - 0x0000)
struct MM_B_Mail_OnClickedVerticalTabBtn final
{
public:
	int32                                         Idx;                                               // 0x0000(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bLocked;                                           // 0x0004(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_5[0x3];                                        // 0x0005(0x0003)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(MM_B_Mail_OnClickedVerticalTabBtn) == 0x000004, "Wrong alignment on MM_B_Mail_OnClickedVerticalTabBtn");
static_assert(sizeof(MM_B_Mail_OnClickedVerticalTabBtn) == 0x000008, "Wrong size on MM_B_Mail_OnClickedVerticalTabBtn");
static_assert(offsetof(MM_B_Mail_OnClickedVerticalTabBtn, Idx) == 0x000000, "Member 'MM_B_Mail_OnClickedVerticalTabBtn::Idx' has a wrong offset!");
static_assert(offsetof(MM_B_Mail_OnClickedVerticalTabBtn, bLocked) == 0x000004, "Member 'MM_B_Mail_OnClickedVerticalTabBtn::bLocked' has a wrong offset!");

// Function MirMobile.MM_CheatWidget.CheatMakeItem
// 0x0008 (0x0008 - 0x0000)
struct MM_CheatWidget_CheatMakeItem final
{
public:
	int32                                         ItemId;                                            // 0x0000(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         ItemCount;                                         // 0x0004(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(MM_CheatWidget_CheatMakeItem) == 0x000004, "Wrong alignment on MM_CheatWidget_CheatMakeItem");
static_assert(sizeof(MM_CheatWidget_CheatMakeItem) == 0x000008, "Wrong size on MM_CheatWidget_CheatMakeItem");
static_assert(offsetof(MM_CheatWidget_CheatMakeItem, ItemId) == 0x000000, "Member 'MM_CheatWidget_CheatMakeItem::ItemId' has a wrong offset!");
static_assert(offsetof(MM_CheatWidget_CheatMakeItem, ItemCount) == 0x000004, "Member 'MM_CheatWidget_CheatMakeItem::ItemCount' has a wrong offset!");

// Function MirMobile.MM_CheatWidget.GetCombineQuestMission
// 0x0028 (0x0028 - 0x0000)
struct MM_CheatWidget_GetCombineQuestMission final
{
public:
	class FString                                 MissionStr;                                        // 0x0000(0x0010)(Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         StepNo;                                            // 0x0010(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_14[0x4];                                       // 0x0014(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class FString                                 ReturnValue;                                       // 0x0018(0x0010)(Parm, OutParm, ZeroConstructor, ReturnParm, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(MM_CheatWidget_GetCombineQuestMission) == 0x000008, "Wrong alignment on MM_CheatWidget_GetCombineQuestMission");
static_assert(sizeof(MM_CheatWidget_GetCombineQuestMission) == 0x000028, "Wrong size on MM_CheatWidget_GetCombineQuestMission");
static_assert(offsetof(MM_CheatWidget_GetCombineQuestMission, MissionStr) == 0x000000, "Member 'MM_CheatWidget_GetCombineQuestMission::MissionStr' has a wrong offset!");
static_assert(offsetof(MM_CheatWidget_GetCombineQuestMission, StepNo) == 0x000010, "Member 'MM_CheatWidget_GetCombineQuestMission::StepNo' has a wrong offset!");
static_assert(offsetof(MM_CheatWidget_GetCombineQuestMission, ReturnValue) == 0x000018, "Member 'MM_CheatWidget_GetCombineQuestMission::ReturnValue' has a wrong offset!");

// Function MirMobile.MM_CheatWidget.GetMainPCStatValue
// 0x0008 (0x0008 - 0x0000)
struct MM_CheatWidget_GetMainPCStatValue final
{
public:
	int32                                         StatID;                                            // 0x0000(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         ReturnValue;                                       // 0x0004(0x0004)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(MM_CheatWidget_GetMainPCStatValue) == 0x000004, "Wrong alignment on MM_CheatWidget_GetMainPCStatValue");
static_assert(sizeof(MM_CheatWidget_GetMainPCStatValue) == 0x000008, "Wrong size on MM_CheatWidget_GetMainPCStatValue");
static_assert(offsetof(MM_CheatWidget_GetMainPCStatValue, StatID) == 0x000000, "Member 'MM_CheatWidget_GetMainPCStatValue::StatID' has a wrong offset!");
static_assert(offsetof(MM_CheatWidget_GetMainPCStatValue, ReturnValue) == 0x000004, "Member 'MM_CheatWidget_GetMainPCStatValue::ReturnValue' has a wrong offset!");

// Function MirMobile.MM_CheatWidget.GetMirCurrentTime
// 0x0010 (0x0010 - 0x0000)
struct MM_CheatWidget_GetMirCurrentTime final
{
public:
	int32                                         CurrentWeek;                                       // 0x0000(0x0004)(Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         CurrentHour;                                       // 0x0004(0x0004)(Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         CurrentMin;                                        // 0x0008(0x0004)(Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         CurrentSec;                                        // 0x000C(0x0004)(Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(MM_CheatWidget_GetMirCurrentTime) == 0x000004, "Wrong alignment on MM_CheatWidget_GetMirCurrentTime");
static_assert(sizeof(MM_CheatWidget_GetMirCurrentTime) == 0x000010, "Wrong size on MM_CheatWidget_GetMirCurrentTime");
static_assert(offsetof(MM_CheatWidget_GetMirCurrentTime, CurrentWeek) == 0x000000, "Member 'MM_CheatWidget_GetMirCurrentTime::CurrentWeek' has a wrong offset!");
static_assert(offsetof(MM_CheatWidget_GetMirCurrentTime, CurrentHour) == 0x000004, "Member 'MM_CheatWidget_GetMirCurrentTime::CurrentHour' has a wrong offset!");
static_assert(offsetof(MM_CheatWidget_GetMirCurrentTime, CurrentMin) == 0x000008, "Member 'MM_CheatWidget_GetMirCurrentTime::CurrentMin' has a wrong offset!");
static_assert(offsetof(MM_CheatWidget_GetMirCurrentTime, CurrentSec) == 0x00000C, "Member 'MM_CheatWidget_GetMirCurrentTime::CurrentSec' has a wrong offset!");

// Function MirMobile.MM_CheatWidget.OnOffCheatConfirm
// 0x0004 (0x0004 - 0x0000)
struct MM_CheatWidget_OnOffCheatConfirm final
{
public:
	int32                                         CheatIndex;                                        // 0x0000(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(MM_CheatWidget_OnOffCheatConfirm) == 0x000004, "Wrong alignment on MM_CheatWidget_OnOffCheatConfirm");
static_assert(sizeof(MM_CheatWidget_OnOffCheatConfirm) == 0x000004, "Wrong size on MM_CheatWidget_OnOffCheatConfirm");
static_assert(offsetof(MM_CheatWidget_OnOffCheatConfirm, CheatIndex) == 0x000000, "Member 'MM_CheatWidget_OnOffCheatConfirm::CheatIndex' has a wrong offset!");

// Function MirMobile.MM_CheatWidget.OnQuestMoveAndTake
// 0x0004 (0x0004 - 0x0000)
struct MM_CheatWidget_OnQuestMoveAndTake final
{
public:
	int32                                         QuestId;                                           // 0x0000(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(MM_CheatWidget_OnQuestMoveAndTake) == 0x000004, "Wrong alignment on MM_CheatWidget_OnQuestMoveAndTake");
static_assert(sizeof(MM_CheatWidget_OnQuestMoveAndTake) == 0x000004, "Wrong size on MM_CheatWidget_OnQuestMoveAndTake");
static_assert(offsetof(MM_CheatWidget_OnQuestMoveAndTake, QuestId) == 0x000000, "Member 'MM_CheatWidget_OnQuestMoveAndTake::QuestId' has a wrong offset!");

// Function MirMobile.MM_CheatWidget.OnResetPrevQuest
// 0x0018 (0x0018 - 0x0000)
struct MM_CheatWidget_OnResetPrevQuest final
{
public:
	TArray<int32>                                 QuestIDArray;                                      // 0x0000(0x0010)(Parm, ZeroConstructor, NativeAccessSpecifierPublic)
	ECheatSuccessOrFail                           OutResult;                                         // 0x0010(0x0001)(Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_11[0x7];                                       // 0x0011(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(MM_CheatWidget_OnResetPrevQuest) == 0x000008, "Wrong alignment on MM_CheatWidget_OnResetPrevQuest");
static_assert(sizeof(MM_CheatWidget_OnResetPrevQuest) == 0x000018, "Wrong size on MM_CheatWidget_OnResetPrevQuest");
static_assert(offsetof(MM_CheatWidget_OnResetPrevQuest, QuestIDArray) == 0x000000, "Member 'MM_CheatWidget_OnResetPrevQuest::QuestIDArray' has a wrong offset!");
static_assert(offsetof(MM_CheatWidget_OnResetPrevQuest, OutResult) == 0x000010, "Member 'MM_CheatWidget_OnResetPrevQuest::OutResult' has a wrong offset!");

// Function MirMobile.MM_CheatWidget.OnResetQuest
// 0x0004 (0x0004 - 0x0000)
struct MM_CheatWidget_OnResetQuest final
{
public:
	int32                                         QuestId;                                           // 0x0000(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(MM_CheatWidget_OnResetQuest) == 0x000004, "Wrong alignment on MM_CheatWidget_OnResetQuest");
static_assert(sizeof(MM_CheatWidget_OnResetQuest) == 0x000004, "Wrong size on MM_CheatWidget_OnResetQuest");
static_assert(offsetof(MM_CheatWidget_OnResetQuest, QuestId) == 0x000000, "Member 'MM_CheatWidget_OnResetQuest::QuestId' has a wrong offset!");

// Function MirMobile.MM_CheatWidget.OnWarpCheate
// 0x0004 (0x0004 - 0x0000)
struct MM_CheatWidget_OnWarpCheate final
{
public:
	int32                                         WarpId;                                            // 0x0000(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(MM_CheatWidget_OnWarpCheate) == 0x000004, "Wrong alignment on MM_CheatWidget_OnWarpCheate");
static_assert(sizeof(MM_CheatWidget_OnWarpCheate) == 0x000004, "Wrong size on MM_CheatWidget_OnWarpCheate");
static_assert(offsetof(MM_CheatWidget_OnWarpCheate, WarpId) == 0x000000, "Member 'MM_CheatWidget_OnWarpCheate::WarpId' has a wrong offset!");

// Function MirMobile.MM_CheatWidget.OnWarpLocation
// 0x000C (0x000C - 0x0000)
struct MM_CheatWidget_OnWarpLocation final
{
public:
	struct FVector                                WarpLocation;                                      // 0x0000(0x000C)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(MM_CheatWidget_OnWarpLocation) == 0x000004, "Wrong alignment on MM_CheatWidget_OnWarpLocation");
static_assert(sizeof(MM_CheatWidget_OnWarpLocation) == 0x00000C, "Wrong size on MM_CheatWidget_OnWarpLocation");
static_assert(offsetof(MM_CheatWidget_OnWarpLocation, WarpLocation) == 0x000000, "Member 'MM_CheatWidget_OnWarpLocation::WarpLocation' has a wrong offset!");

// Function MirMobile.MM_CheatWidget.OnWarpQuestLocation
// 0x0004 (0x0004 - 0x0000)
struct MM_CheatWidget_OnWarpQuestLocation final
{
public:
	int32                                         QuestId;                                           // 0x0000(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(MM_CheatWidget_OnWarpQuestLocation) == 0x000004, "Wrong alignment on MM_CheatWidget_OnWarpQuestLocation");
static_assert(sizeof(MM_CheatWidget_OnWarpQuestLocation) == 0x000004, "Wrong size on MM_CheatWidget_OnWarpQuestLocation");
static_assert(offsetof(MM_CheatWidget_OnWarpQuestLocation, QuestId) == 0x000000, "Member 'MM_CheatWidget_OnWarpQuestLocation::QuestId' has a wrong offset!");

// Function MirMobile.MM_CheatWidget.OnWarpStageLocation
// 0x0010 (0x0010 - 0x0000)
struct MM_CheatWidget_OnWarpStageLocation final
{
public:
	int32                                         StageID;                                           // 0x0000(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                WarpLocation;                                      // 0x0004(0x000C)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(MM_CheatWidget_OnWarpStageLocation) == 0x000004, "Wrong alignment on MM_CheatWidget_OnWarpStageLocation");
static_assert(sizeof(MM_CheatWidget_OnWarpStageLocation) == 0x000010, "Wrong size on MM_CheatWidget_OnWarpStageLocation");
static_assert(offsetof(MM_CheatWidget_OnWarpStageLocation, StageID) == 0x000000, "Member 'MM_CheatWidget_OnWarpStageLocation::StageID' has a wrong offset!");
static_assert(offsetof(MM_CheatWidget_OnWarpStageLocation, WarpLocation) == 0x000004, "Member 'MM_CheatWidget_OnWarpStageLocation::WarpLocation' has a wrong offset!");

// Function MirMobile.MM_CheatWidget.ScreenShotTest
// 0x0018 (0x0018 - 0x0000)
struct MM_CheatWidget_ScreenShotTest final
{
public:
	class FString                                 FilePath;                                          // 0x0000(0x0010)(Parm, OutParm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          ReturnValue;                                       // 0x0010(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_11[0x7];                                       // 0x0011(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(MM_CheatWidget_ScreenShotTest) == 0x000008, "Wrong alignment on MM_CheatWidget_ScreenShotTest");
static_assert(sizeof(MM_CheatWidget_ScreenShotTest) == 0x000018, "Wrong size on MM_CheatWidget_ScreenShotTest");
static_assert(offsetof(MM_CheatWidget_ScreenShotTest, FilePath) == 0x000000, "Member 'MM_CheatWidget_ScreenShotTest::FilePath' has a wrong offset!");
static_assert(offsetof(MM_CheatWidget_ScreenShotTest, ReturnValue) == 0x000010, "Member 'MM_CheatWidget_ScreenShotTest::ReturnValue' has a wrong offset!");

// Function MirMobile.MM_CheatWidget.ShowServerBlock
// 0x0001 (0x0001 - 0x0000)
struct MM_CheatWidget_ShowServerBlock final
{
public:
	bool                                          bShow;                                             // 0x0000(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(MM_CheatWidget_ShowServerBlock) == 0x000001, "Wrong alignment on MM_CheatWidget_ShowServerBlock");
static_assert(sizeof(MM_CheatWidget_ShowServerBlock) == 0x000001, "Wrong size on MM_CheatWidget_ShowServerBlock");
static_assert(offsetof(MM_CheatWidget_ShowServerBlock, bShow) == 0x000000, "Member 'MM_CheatWidget_ShowServerBlock::bShow' has a wrong offset!");

// Function MirMobile.MM_CheatWidget.ValueCheatConfirm
// 0x000C (0x000C - 0x0000)
struct MM_CheatWidget_ValueCheatConfirm final
{
public:
	int32                                         CheatIndex;                                        // 0x0000(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         CheatValue1;                                       // 0x0004(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         CheatValue2;                                       // 0x0008(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(MM_CheatWidget_ValueCheatConfirm) == 0x000004, "Wrong alignment on MM_CheatWidget_ValueCheatConfirm");
static_assert(sizeof(MM_CheatWidget_ValueCheatConfirm) == 0x00000C, "Wrong size on MM_CheatWidget_ValueCheatConfirm");
static_assert(offsetof(MM_CheatWidget_ValueCheatConfirm, CheatIndex) == 0x000000, "Member 'MM_CheatWidget_ValueCheatConfirm::CheatIndex' has a wrong offset!");
static_assert(offsetof(MM_CheatWidget_ValueCheatConfirm, CheatValue1) == 0x000004, "Member 'MM_CheatWidget_ValueCheatConfirm::CheatValue1' has a wrong offset!");
static_assert(offsetof(MM_CheatWidget_ValueCheatConfirm, CheatValue2) == 0x000008, "Member 'MM_CheatWidget_ValueCheatConfirm::CheatValue2' has a wrong offset!");

// Function MirMobile.MM_Popup_UnsealingAcceleration.OnChangePoint
// 0x0008 (0x0008 - 0x0000)
struct MM_Popup_UnsealingAcceleration_OnChangePoint final
{
public:
	int64                                         IUsePoint;                                         // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(MM_Popup_UnsealingAcceleration_OnChangePoint) == 0x000008, "Wrong alignment on MM_Popup_UnsealingAcceleration_OnChangePoint");
static_assert(sizeof(MM_Popup_UnsealingAcceleration_OnChangePoint) == 0x000008, "Wrong size on MM_Popup_UnsealingAcceleration_OnChangePoint");
static_assert(offsetof(MM_Popup_UnsealingAcceleration_OnChangePoint, IUsePoint) == 0x000000, "Member 'MM_Popup_UnsealingAcceleration_OnChangePoint::IUsePoint' has a wrong offset!");

// Function MirMobile.MM_B_MysticalPiece.OnClickEquipSlot
// 0x0004 (0x0004 - 0x0000)
struct MM_B_MysticalPiece_OnClickEquipSlot final
{
public:
	int32                                         Slot_index_;                                       // 0x0000(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(MM_B_MysticalPiece_OnClickEquipSlot) == 0x000004, "Wrong alignment on MM_B_MysticalPiece_OnClickEquipSlot");
static_assert(sizeof(MM_B_MysticalPiece_OnClickEquipSlot) == 0x000004, "Wrong size on MM_B_MysticalPiece_OnClickEquipSlot");
static_assert(offsetof(MM_B_MysticalPiece_OnClickEquipSlot, Slot_index_) == 0x000000, "Member 'MM_B_MysticalPiece_OnClickEquipSlot::Slot_index_' has a wrong offset!");

// Function MirMobile.MM_B_MysticalPiece.OnClickSlotOpen
// 0x0004 (0x0004 - 0x0000)
struct MM_B_MysticalPiece_OnClickSlotOpen final
{
public:
	int32                                         SlotID;                                            // 0x0000(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(MM_B_MysticalPiece_OnClickSlotOpen) == 0x000004, "Wrong alignment on MM_B_MysticalPiece_OnClickSlotOpen");
static_assert(sizeof(MM_B_MysticalPiece_OnClickSlotOpen) == 0x000004, "Wrong size on MM_B_MysticalPiece_OnClickSlotOpen");
static_assert(offsetof(MM_B_MysticalPiece_OnClickSlotOpen, SlotID) == 0x000000, "Member 'MM_B_MysticalPiece_OnClickSlotOpen::SlotID' has a wrong offset!");

// Function MirMobile.MM_B_MysticalPiece.OnClickUnEuquipSlot
// 0x0004 (0x0004 - 0x0000)
struct MM_B_MysticalPiece_OnClickUnEuquipSlot final
{
public:
	int32                                         Slot_index_;                                       // 0x0000(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(MM_B_MysticalPiece_OnClickUnEuquipSlot) == 0x000004, "Wrong alignment on MM_B_MysticalPiece_OnClickUnEuquipSlot");
static_assert(sizeof(MM_B_MysticalPiece_OnClickUnEuquipSlot) == 0x000004, "Wrong size on MM_B_MysticalPiece_OnClickUnEuquipSlot");
static_assert(offsetof(MM_B_MysticalPiece_OnClickUnEuquipSlot, Slot_index_) == 0x000000, "Member 'MM_B_MysticalPiece_OnClickUnEuquipSlot::Slot_index_' has a wrong offset!");

// Function MirMobile.MM_B_MysticalPiece.OnOpenEuquipSlot
// 0x0004 (0x0004 - 0x0000)
struct MM_B_MysticalPiece_OnOpenEuquipSlot final
{
public:
	int32                                         Slot_index_;                                       // 0x0000(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(MM_B_MysticalPiece_OnOpenEuquipSlot) == 0x000004, "Wrong alignment on MM_B_MysticalPiece_OnOpenEuquipSlot");
static_assert(sizeof(MM_B_MysticalPiece_OnOpenEuquipSlot) == 0x000004, "Wrong size on MM_B_MysticalPiece_OnOpenEuquipSlot");
static_assert(offsetof(MM_B_MysticalPiece_OnOpenEuquipSlot, Slot_index_) == 0x000000, "Member 'MM_B_MysticalPiece_OnOpenEuquipSlot::Slot_index_' has a wrong offset!");

// Function MirMobile.MM_B_NewGuild.OnClickTab
// 0x0008 (0x0008 - 0x0000)
struct MM_B_NewGuild_OnClickTab final
{
public:
	int32                                         IIndex;                                            // 0x0000(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bLocked;                                           // 0x0004(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_5[0x3];                                        // 0x0005(0x0003)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(MM_B_NewGuild_OnClickTab) == 0x000004, "Wrong alignment on MM_B_NewGuild_OnClickTab");
static_assert(sizeof(MM_B_NewGuild_OnClickTab) == 0x000008, "Wrong size on MM_B_NewGuild_OnClickTab");
static_assert(offsetof(MM_B_NewGuild_OnClickTab, IIndex) == 0x000000, "Member 'MM_B_NewGuild_OnClickTab::IIndex' has a wrong offset!");
static_assert(offsetof(MM_B_NewGuild_OnClickTab, bLocked) == 0x000004, "Member 'MM_B_NewGuild_OnClickTab::bLocked' has a wrong offset!");

// Function MirMobile.MM_B_NFT_Relocation.OnClickMenuTab
// 0x0008 (0x0008 - 0x0000)
struct MM_B_NFT_Relocation_OnClickMenuTab final
{
public:
	int32                                         IIndex;                                            // 0x0000(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bLocked;                                           // 0x0004(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_5[0x3];                                        // 0x0005(0x0003)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(MM_B_NFT_Relocation_OnClickMenuTab) == 0x000004, "Wrong alignment on MM_B_NFT_Relocation_OnClickMenuTab");
static_assert(sizeof(MM_B_NFT_Relocation_OnClickMenuTab) == 0x000008, "Wrong size on MM_B_NFT_Relocation_OnClickMenuTab");
static_assert(offsetof(MM_B_NFT_Relocation_OnClickMenuTab, IIndex) == 0x000000, "Member 'MM_B_NFT_Relocation_OnClickMenuTab::IIndex' has a wrong offset!");
static_assert(offsetof(MM_B_NFT_Relocation_OnClickMenuTab, bLocked) == 0x000004, "Member 'MM_B_NFT_Relocation_OnClickMenuTab::bLocked' has a wrong offset!");

// Function MirMobile.MM_Item_Make_Info.OnChangeMakeCount
// 0x0008 (0x0008 - 0x0000)
struct MM_Item_Make_Info_OnChangeMakeCount final
{
public:
	int64                                         MakeCount;                                         // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(MM_Item_Make_Info_OnChangeMakeCount) == 0x000008, "Wrong alignment on MM_Item_Make_Info_OnChangeMakeCount");
static_assert(sizeof(MM_Item_Make_Info_OnChangeMakeCount) == 0x000008, "Wrong size on MM_Item_Make_Info_OnChangeMakeCount");
static_assert(offsetof(MM_Item_Make_Info_OnChangeMakeCount, MakeCount) == 0x000000, "Member 'MM_Item_Make_Info_OnChangeMakeCount::MakeCount' has a wrong offset!");

// Function MirMobile.MM_Item_Make_Info.OnClickCraftSwitch
// 0x0004 (0x0004 - 0x0000)
struct MM_Item_Make_Info_OnClickCraftSwitch final
{
public:
	int32                                         Index_0;                                           // 0x0000(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(MM_Item_Make_Info_OnClickCraftSwitch) == 0x000004, "Wrong alignment on MM_Item_Make_Info_OnClickCraftSwitch");
static_assert(sizeof(MM_Item_Make_Info_OnClickCraftSwitch) == 0x000004, "Wrong size on MM_Item_Make_Info_OnClickCraftSwitch");
static_assert(offsetof(MM_Item_Make_Info_OnClickCraftSwitch, Index_0) == 0x000000, "Member 'MM_Item_Make_Info_OnClickCraftSwitch::Index_0' has a wrong offset!");

// Function MirMobile.MM_Item_Make_Info.OnClickLuckyItem
// 0x0010 (0x0010 - 0x0000)
struct MM_Item_Make_Info_OnClickLuckyItem final
{
public:
	int64                                         _UID;                                              // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         _TID;                                              // 0x0008(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         _Pos;                                              // 0x000C(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(MM_Item_Make_Info_OnClickLuckyItem) == 0x000008, "Wrong alignment on MM_Item_Make_Info_OnClickLuckyItem");
static_assert(sizeof(MM_Item_Make_Info_OnClickLuckyItem) == 0x000010, "Wrong size on MM_Item_Make_Info_OnClickLuckyItem");
static_assert(offsetof(MM_Item_Make_Info_OnClickLuckyItem, _UID) == 0x000000, "Member 'MM_Item_Make_Info_OnClickLuckyItem::_UID' has a wrong offset!");
static_assert(offsetof(MM_Item_Make_Info_OnClickLuckyItem, _TID) == 0x000008, "Member 'MM_Item_Make_Info_OnClickLuckyItem::_TID' has a wrong offset!");
static_assert(offsetof(MM_Item_Make_Info_OnClickLuckyItem, _Pos) == 0x00000C, "Member 'MM_Item_Make_Info_OnClickLuckyItem::_Pos' has a wrong offset!");

// Function MirMobile.MM_Item_Make_Info.OnClickMakeItem
// 0x0010 (0x0010 - 0x0000)
struct MM_Item_Make_Info_OnClickMakeItem final
{
public:
	int64                                         _UID;                                              // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         _TID;                                              // 0x0008(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         _Pos;                                              // 0x000C(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(MM_Item_Make_Info_OnClickMakeItem) == 0x000008, "Wrong alignment on MM_Item_Make_Info_OnClickMakeItem");
static_assert(sizeof(MM_Item_Make_Info_OnClickMakeItem) == 0x000010, "Wrong size on MM_Item_Make_Info_OnClickMakeItem");
static_assert(offsetof(MM_Item_Make_Info_OnClickMakeItem, _UID) == 0x000000, "Member 'MM_Item_Make_Info_OnClickMakeItem::_UID' has a wrong offset!");
static_assert(offsetof(MM_Item_Make_Info_OnClickMakeItem, _TID) == 0x000008, "Member 'MM_Item_Make_Info_OnClickMakeItem::_TID' has a wrong offset!");
static_assert(offsetof(MM_Item_Make_Info_OnClickMakeItem, _Pos) == 0x00000C, "Member 'MM_Item_Make_Info_OnClickMakeItem::_Pos' has a wrong offset!");

// Function MirMobile.MM_Item_Make_Info.OnClickMaterialItemSlot
// 0x0008 (0x0008 - 0x0000)
struct MM_Item_Make_Info_OnClickMaterialItemSlot final
{
public:
	class UMM_Slot_Base*                          PSlot;                                             // 0x0000(0x0008)(Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(MM_Item_Make_Info_OnClickMaterialItemSlot) == 0x000008, "Wrong alignment on MM_Item_Make_Info_OnClickMaterialItemSlot");
static_assert(sizeof(MM_Item_Make_Info_OnClickMaterialItemSlot) == 0x000008, "Wrong size on MM_Item_Make_Info_OnClickMaterialItemSlot");
static_assert(offsetof(MM_Item_Make_Info_OnClickMaterialItemSlot, PSlot) == 0x000000, "Member 'MM_Item_Make_Info_OnClickMaterialItemSlot::PSlot' has a wrong offset!");

// Function MirMobile.MM_Popup_Party_Make.OnClickCheckBoxGuild
// 0x0001 (0x0001 - 0x0000)
struct MM_Popup_Party_Make_OnClickCheckBoxGuild final
{
public:
	bool                                          bChecked;                                          // 0x0000(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(MM_Popup_Party_Make_OnClickCheckBoxGuild) == 0x000001, "Wrong alignment on MM_Popup_Party_Make_OnClickCheckBoxGuild");
static_assert(sizeof(MM_Popup_Party_Make_OnClickCheckBoxGuild) == 0x000001, "Wrong size on MM_Popup_Party_Make_OnClickCheckBoxGuild");
static_assert(offsetof(MM_Popup_Party_Make_OnClickCheckBoxGuild, bChecked) == 0x000000, "Member 'MM_Popup_Party_Make_OnClickCheckBoxGuild::bChecked' has a wrong offset!");

// Function MirMobile.MM_Popup_Party_Make.OnClickCheckBoxMember_15
// 0x0001 (0x0001 - 0x0000)
struct MM_Popup_Party_Make_OnClickCheckBoxMember_15 final
{
public:
	bool                                          bChecked;                                          // 0x0000(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(MM_Popup_Party_Make_OnClickCheckBoxMember_15) == 0x000001, "Wrong alignment on MM_Popup_Party_Make_OnClickCheckBoxMember_15");
static_assert(sizeof(MM_Popup_Party_Make_OnClickCheckBoxMember_15) == 0x000001, "Wrong size on MM_Popup_Party_Make_OnClickCheckBoxMember_15");
static_assert(offsetof(MM_Popup_Party_Make_OnClickCheckBoxMember_15, bChecked) == 0x000000, "Member 'MM_Popup_Party_Make_OnClickCheckBoxMember_15::bChecked' has a wrong offset!");

// Function MirMobile.MM_Popup_Party_Make.OnClickCheckBoxMember_5
// 0x0001 (0x0001 - 0x0000)
struct MM_Popup_Party_Make_OnClickCheckBoxMember_5 final
{
public:
	bool                                          bChecked;                                          // 0x0000(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(MM_Popup_Party_Make_OnClickCheckBoxMember_5) == 0x000001, "Wrong alignment on MM_Popup_Party_Make_OnClickCheckBoxMember_5");
static_assert(sizeof(MM_Popup_Party_Make_OnClickCheckBoxMember_5) == 0x000001, "Wrong size on MM_Popup_Party_Make_OnClickCheckBoxMember_5");
static_assert(offsetof(MM_Popup_Party_Make_OnClickCheckBoxMember_5, bChecked) == 0x000000, "Member 'MM_Popup_Party_Make_OnClickCheckBoxMember_5::bChecked' has a wrong offset!");

// Function MirMobile.MM_Popup_Party_Make.OnClickCheckBoxPrivate
// 0x0001 (0x0001 - 0x0000)
struct MM_Popup_Party_Make_OnClickCheckBoxPrivate final
{
public:
	bool                                          bChecked;                                          // 0x0000(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(MM_Popup_Party_Make_OnClickCheckBoxPrivate) == 0x000001, "Wrong alignment on MM_Popup_Party_Make_OnClickCheckBoxPrivate");
static_assert(sizeof(MM_Popup_Party_Make_OnClickCheckBoxPrivate) == 0x000001, "Wrong size on MM_Popup_Party_Make_OnClickCheckBoxPrivate");
static_assert(offsetof(MM_Popup_Party_Make_OnClickCheckBoxPrivate, bChecked) == 0x000000, "Member 'MM_Popup_Party_Make_OnClickCheckBoxPrivate::bChecked' has a wrong offset!");

// Function MirMobile.MM_Popup_Party_Make.OnClickCheckBoxPublic
// 0x0001 (0x0001 - 0x0000)
struct MM_Popup_Party_Make_OnClickCheckBoxPublic final
{
public:
	bool                                          bChecked;                                          // 0x0000(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(MM_Popup_Party_Make_OnClickCheckBoxPublic) == 0x000001, "Wrong alignment on MM_Popup_Party_Make_OnClickCheckBoxPublic");
static_assert(sizeof(MM_Popup_Party_Make_OnClickCheckBoxPublic) == 0x000001, "Wrong size on MM_Popup_Party_Make_OnClickCheckBoxPublic");
static_assert(offsetof(MM_Popup_Party_Make_OnClickCheckBoxPublic, bChecked) == 0x000000, "Member 'MM_Popup_Party_Make_OnClickCheckBoxPublic::bChecked' has a wrong offset!");

// Function MirMobile.MM_Popup_Party_Make.ReturnCombatPoint
// 0x0008 (0x0008 - 0x0000)
struct MM_Popup_Party_Make_ReturnCombatPoint final
{
public:
	int64                                         IValue;                                            // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(MM_Popup_Party_Make_ReturnCombatPoint) == 0x000008, "Wrong alignment on MM_Popup_Party_Make_ReturnCombatPoint");
static_assert(sizeof(MM_Popup_Party_Make_ReturnCombatPoint) == 0x000008, "Wrong size on MM_Popup_Party_Make_ReturnCombatPoint");
static_assert(offsetof(MM_Popup_Party_Make_ReturnCombatPoint, IValue) == 0x000000, "Member 'MM_Popup_Party_Make_ReturnCombatPoint::IValue' has a wrong offset!");

// Function MirMobile.MM_Popup_Party_Make.ReturnPassword
// 0x0010 (0x0010 - 0x0000)
struct MM_Popup_Party_Make_ReturnPassword final
{
public:
	class FString                                 StrPassword;                                       // 0x0000(0x0010)(Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(MM_Popup_Party_Make_ReturnPassword) == 0x000008, "Wrong alignment on MM_Popup_Party_Make_ReturnPassword");
static_assert(sizeof(MM_Popup_Party_Make_ReturnPassword) == 0x000010, "Wrong size on MM_Popup_Party_Make_ReturnPassword");
static_assert(offsetof(MM_Popup_Party_Make_ReturnPassword, StrPassword) == 0x000000, "Member 'MM_Popup_Party_Make_ReturnPassword::StrPassword' has a wrong offset!");

// Function MirMobile.MM_B_NPC_Exchange.OnChangeMakeCount
// 0x0008 (0x0008 - 0x0000)
struct MM_B_NPC_Exchange_OnChangeMakeCount final
{
public:
	int64                                         MakeCount;                                         // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(MM_B_NPC_Exchange_OnChangeMakeCount) == 0x000008, "Wrong alignment on MM_B_NPC_Exchange_OnChangeMakeCount");
static_assert(sizeof(MM_B_NPC_Exchange_OnChangeMakeCount) == 0x000008, "Wrong size on MM_B_NPC_Exchange_OnChangeMakeCount");
static_assert(offsetof(MM_B_NPC_Exchange_OnChangeMakeCount, MakeCount) == 0x000000, "Member 'MM_B_NPC_Exchange_OnChangeMakeCount::MakeCount' has a wrong offset!");

// Function MirMobile.MM_B_NPC_Exchange.OnClickFilter
// 0x0001 (0x0001 - 0x0000)
struct MM_B_NPC_Exchange_OnClickFilter final
{
public:
	bool                                          Toggle;                                            // 0x0000(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(MM_B_NPC_Exchange_OnClickFilter) == 0x000001, "Wrong alignment on MM_B_NPC_Exchange_OnClickFilter");
static_assert(sizeof(MM_B_NPC_Exchange_OnClickFilter) == 0x000001, "Wrong size on MM_B_NPC_Exchange_OnClickFilter");
static_assert(offsetof(MM_B_NPC_Exchange_OnClickFilter, Toggle) == 0x000000, "Member 'MM_B_NPC_Exchange_OnClickFilter::Toggle' has a wrong offset!");

// Function MirMobile.MM_B_NPC_Exchange.OnClickInvenMaterialSlot
// 0x0004 (0x0004 - 0x0000)
struct MM_B_NPC_Exchange_OnClickInvenMaterialSlot final
{
public:
	int32                                         SelectItemTID;                                     // 0x0000(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(MM_B_NPC_Exchange_OnClickInvenMaterialSlot) == 0x000004, "Wrong alignment on MM_B_NPC_Exchange_OnClickInvenMaterialSlot");
static_assert(sizeof(MM_B_NPC_Exchange_OnClickInvenMaterialSlot) == 0x000004, "Wrong size on MM_B_NPC_Exchange_OnClickInvenMaterialSlot");
static_assert(offsetof(MM_B_NPC_Exchange_OnClickInvenMaterialSlot, SelectItemTID) == 0x000000, "Member 'MM_B_NPC_Exchange_OnClickInvenMaterialSlot::SelectItemTID' has a wrong offset!");

// Function MirMobile.MM_B_NPC_Exchange.OnClickMaterialItem
// 0x0010 (0x0010 - 0x0000)
struct MM_B_NPC_Exchange_OnClickMaterialItem final
{
public:
	int64                                         Uid;                                               // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         TID;                                               // 0x0008(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         EquipPosition;                                     // 0x000C(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(MM_B_NPC_Exchange_OnClickMaterialItem) == 0x000008, "Wrong alignment on MM_B_NPC_Exchange_OnClickMaterialItem");
static_assert(sizeof(MM_B_NPC_Exchange_OnClickMaterialItem) == 0x000010, "Wrong size on MM_B_NPC_Exchange_OnClickMaterialItem");
static_assert(offsetof(MM_B_NPC_Exchange_OnClickMaterialItem, Uid) == 0x000000, "Member 'MM_B_NPC_Exchange_OnClickMaterialItem::Uid' has a wrong offset!");
static_assert(offsetof(MM_B_NPC_Exchange_OnClickMaterialItem, TID) == 0x000008, "Member 'MM_B_NPC_Exchange_OnClickMaterialItem::TID' has a wrong offset!");
static_assert(offsetof(MM_B_NPC_Exchange_OnClickMaterialItem, EquipPosition) == 0x00000C, "Member 'MM_B_NPC_Exchange_OnClickMaterialItem::EquipPosition' has a wrong offset!");

// Function MirMobile.MM_B_NPC_Exchange.OnClickSubMenu
// 0x0008 (0x0008 - 0x0000)
struct MM_B_NPC_Exchange_OnClickSubMenu final
{
public:
	int32                                         Index_0;                                           // 0x0000(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bLocked;                                           // 0x0004(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_5[0x3];                                        // 0x0005(0x0003)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(MM_B_NPC_Exchange_OnClickSubMenu) == 0x000004, "Wrong alignment on MM_B_NPC_Exchange_OnClickSubMenu");
static_assert(sizeof(MM_B_NPC_Exchange_OnClickSubMenu) == 0x000008, "Wrong size on MM_B_NPC_Exchange_OnClickSubMenu");
static_assert(offsetof(MM_B_NPC_Exchange_OnClickSubMenu, Index_0) == 0x000000, "Member 'MM_B_NPC_Exchange_OnClickSubMenu::Index_0' has a wrong offset!");
static_assert(offsetof(MM_B_NPC_Exchange_OnClickSubMenu, bLocked) == 0x000004, "Member 'MM_B_NPC_Exchange_OnClickSubMenu::bLocked' has a wrong offset!");

// Function MirMobile.MM_B_NPC_Exchange.OnClickTargetSlot
// 0x0010 (0x0010 - 0x0000)
struct MM_B_NPC_Exchange_OnClickTargetSlot final
{
public:
	int64                                         ItemUID;                                           // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         ItemTID;                                           // 0x0008(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         EquipPosition;                                     // 0x000C(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(MM_B_NPC_Exchange_OnClickTargetSlot) == 0x000008, "Wrong alignment on MM_B_NPC_Exchange_OnClickTargetSlot");
static_assert(sizeof(MM_B_NPC_Exchange_OnClickTargetSlot) == 0x000010, "Wrong size on MM_B_NPC_Exchange_OnClickTargetSlot");
static_assert(offsetof(MM_B_NPC_Exchange_OnClickTargetSlot, ItemUID) == 0x000000, "Member 'MM_B_NPC_Exchange_OnClickTargetSlot::ItemUID' has a wrong offset!");
static_assert(offsetof(MM_B_NPC_Exchange_OnClickTargetSlot, ItemTID) == 0x000008, "Member 'MM_B_NPC_Exchange_OnClickTargetSlot::ItemTID' has a wrong offset!");
static_assert(offsetof(MM_B_NPC_Exchange_OnClickTargetSlot, EquipPosition) == 0x00000C, "Member 'MM_B_NPC_Exchange_OnClickTargetSlot::EquipPosition' has a wrong offset!");

// Function MirMobile.MM_B_NPC_Exchange.PlayCloseAni
// 0x0004 (0x0004 - 0x0000)
struct MM_B_NPC_Exchange_PlayCloseAni final
{
public:
	float                                         ReturnValue;                                       // 0x0000(0x0004)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(MM_B_NPC_Exchange_PlayCloseAni) == 0x000004, "Wrong alignment on MM_B_NPC_Exchange_PlayCloseAni");
static_assert(sizeof(MM_B_NPC_Exchange_PlayCloseAni) == 0x000004, "Wrong size on MM_B_NPC_Exchange_PlayCloseAni");
static_assert(offsetof(MM_B_NPC_Exchange_PlayCloseAni, ReturnValue) == 0x000000, "Member 'MM_B_NPC_Exchange_PlayCloseAni::ReturnValue' has a wrong offset!");

// Function MirMobile.MM_B_NpcItemCraft.ClickCraftSlotByInven
// 0x0004 (0x0004 - 0x0000)
struct MM_B_NpcItemCraft_ClickCraftSlotByInven final
{
public:
	int32                                         CraftId;                                           // 0x0000(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(MM_B_NpcItemCraft_ClickCraftSlotByInven) == 0x000004, "Wrong alignment on MM_B_NpcItemCraft_ClickCraftSlotByInven");
static_assert(sizeof(MM_B_NpcItemCraft_ClickCraftSlotByInven) == 0x000004, "Wrong size on MM_B_NpcItemCraft_ClickCraftSlotByInven");
static_assert(offsetof(MM_B_NpcItemCraft_ClickCraftSlotByInven, CraftId) == 0x000000, "Member 'MM_B_NpcItemCraft_ClickCraftSlotByInven::CraftId' has a wrong offset!");

// Function MirMobile.MM_B_NpcItemCraft.OnClickCraftItemInfo
// 0x0010 (0x0010 - 0x0000)
struct MM_B_NpcItemCraft_OnClickCraftItemInfo final
{
public:
	int64                                         Uid;                                               // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         TID;                                               // 0x0008(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         Pos;                                               // 0x000C(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(MM_B_NpcItemCraft_OnClickCraftItemInfo) == 0x000008, "Wrong alignment on MM_B_NpcItemCraft_OnClickCraftItemInfo");
static_assert(sizeof(MM_B_NpcItemCraft_OnClickCraftItemInfo) == 0x000010, "Wrong size on MM_B_NpcItemCraft_OnClickCraftItemInfo");
static_assert(offsetof(MM_B_NpcItemCraft_OnClickCraftItemInfo, Uid) == 0x000000, "Member 'MM_B_NpcItemCraft_OnClickCraftItemInfo::Uid' has a wrong offset!");
static_assert(offsetof(MM_B_NpcItemCraft_OnClickCraftItemInfo, TID) == 0x000008, "Member 'MM_B_NpcItemCraft_OnClickCraftItemInfo::TID' has a wrong offset!");
static_assert(offsetof(MM_B_NpcItemCraft_OnClickCraftItemInfo, Pos) == 0x00000C, "Member 'MM_B_NpcItemCraft_OnClickCraftItemInfo::Pos' has a wrong offset!");

// Function MirMobile.MM_B_NpcItemCraft.OnClickMaterialInfo
// 0x0008 (0x0008 - 0x0000)
struct MM_B_NpcItemCraft_OnClickMaterialInfo final
{
public:
	class UMM_Slot_Base*                          SlotBase;                                          // 0x0000(0x0008)(Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(MM_B_NpcItemCraft_OnClickMaterialInfo) == 0x000008, "Wrong alignment on MM_B_NpcItemCraft_OnClickMaterialInfo");
static_assert(sizeof(MM_B_NpcItemCraft_OnClickMaterialInfo) == 0x000008, "Wrong size on MM_B_NpcItemCraft_OnClickMaterialInfo");
static_assert(offsetof(MM_B_NpcItemCraft_OnClickMaterialInfo, SlotBase) == 0x000000, "Member 'MM_B_NpcItemCraft_OnClickMaterialInfo::SlotBase' has a wrong offset!");

// Function MirMobile.MM_B_NpcItemCraft.OnClickMaterialInInven
// 0x0018 (0x0018 - 0x0000)
struct MM_B_NpcItemCraft_OnClickMaterialInInven final
{
public:
	int32                                         ItemTID;                                           // 0x0000(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_4[0x4];                                        // 0x0004(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	int64                                         ItemUID;                                           // 0x0008(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UMM_Slot_Base*                          SlotBase;                                          // 0x0010(0x0008)(Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(MM_B_NpcItemCraft_OnClickMaterialInInven) == 0x000008, "Wrong alignment on MM_B_NpcItemCraft_OnClickMaterialInInven");
static_assert(sizeof(MM_B_NpcItemCraft_OnClickMaterialInInven) == 0x000018, "Wrong size on MM_B_NpcItemCraft_OnClickMaterialInInven");
static_assert(offsetof(MM_B_NpcItemCraft_OnClickMaterialInInven, ItemTID) == 0x000000, "Member 'MM_B_NpcItemCraft_OnClickMaterialInInven::ItemTID' has a wrong offset!");
static_assert(offsetof(MM_B_NpcItemCraft_OnClickMaterialInInven, ItemUID) == 0x000008, "Member 'MM_B_NpcItemCraft_OnClickMaterialInInven::ItemUID' has a wrong offset!");
static_assert(offsetof(MM_B_NpcItemCraft_OnClickMaterialInInven, SlotBase) == 0x000010, "Member 'MM_B_NpcItemCraft_OnClickMaterialInInven::SlotBase' has a wrong offset!");

// Function MirMobile.MM_B_NpcItemCraft.OnClickMaterialSwitch
// 0x0008 (0x0008 - 0x0000)
struct MM_B_NpcItemCraft_OnClickMaterialSwitch final
{
public:
	class UMM_Slot_Base*                          SlotBase;                                          // 0x0000(0x0008)(Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(MM_B_NpcItemCraft_OnClickMaterialSwitch) == 0x000008, "Wrong alignment on MM_B_NpcItemCraft_OnClickMaterialSwitch");
static_assert(sizeof(MM_B_NpcItemCraft_OnClickMaterialSwitch) == 0x000008, "Wrong size on MM_B_NpcItemCraft_OnClickMaterialSwitch");
static_assert(offsetof(MM_B_NpcItemCraft_OnClickMaterialSwitch, SlotBase) == 0x000000, "Member 'MM_B_NpcItemCraft_OnClickMaterialSwitch::SlotBase' has a wrong offset!");

// Function MirMobile.MM_B_NpcItemCraft.OnClickVerticalTab
// 0x0008 (0x0008 - 0x0000)
struct MM_B_NpcItemCraft_OnClickVerticalTab final
{
public:
	int32                                         SlotIndex;                                         // 0x0000(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          IsLocked;                                          // 0x0004(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_5[0x3];                                        // 0x0005(0x0003)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(MM_B_NpcItemCraft_OnClickVerticalTab) == 0x000004, "Wrong alignment on MM_B_NpcItemCraft_OnClickVerticalTab");
static_assert(sizeof(MM_B_NpcItemCraft_OnClickVerticalTab) == 0x000008, "Wrong size on MM_B_NpcItemCraft_OnClickVerticalTab");
static_assert(offsetof(MM_B_NpcItemCraft_OnClickVerticalTab, SlotIndex) == 0x000000, "Member 'MM_B_NpcItemCraft_OnClickVerticalTab::SlotIndex' has a wrong offset!");
static_assert(offsetof(MM_B_NpcItemCraft_OnClickVerticalTab, IsLocked) == 0x000004, "Member 'MM_B_NpcItemCraft_OnClickVerticalTab::IsLocked' has a wrong offset!");

// Function MirMobile.MM_ClassSelect_Slot.OnSelectEffectSlot
// 0x0004 (0x0004 - 0x0000)
struct MM_ClassSelect_Slot_OnSelectEffectSlot final
{
public:
	int32                                         ClassID;                                           // 0x0000(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(MM_ClassSelect_Slot_OnSelectEffectSlot) == 0x000004, "Wrong alignment on MM_ClassSelect_Slot_OnSelectEffectSlot");
static_assert(sizeof(MM_ClassSelect_Slot_OnSelectEffectSlot) == 0x000004, "Wrong size on MM_ClassSelect_Slot_OnSelectEffectSlot");
static_assert(offsetof(MM_ClassSelect_Slot_OnSelectEffectSlot, ClassID) == 0x000000, "Member 'MM_ClassSelect_Slot_OnSelectEffectSlot::ClassID' has a wrong offset!");

// Function MirMobile.MM_Popup_XsollaIAP.OnUrlChanged
// 0x0018 (0x0018 - 0x0000)
struct MM_Popup_XsollaIAP_OnUrlChanged final
{
public:
	class FText                                   URL;                                               // 0x0000(0x0018)(ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
};
static_assert(alignof(MM_Popup_XsollaIAP_OnUrlChanged) == 0x000008, "Wrong alignment on MM_Popup_XsollaIAP_OnUrlChanged");
static_assert(sizeof(MM_Popup_XsollaIAP_OnUrlChanged) == 0x000018, "Wrong size on MM_Popup_XsollaIAP_OnUrlChanged");
static_assert(offsetof(MM_Popup_XsollaIAP_OnUrlChanged, URL) == 0x000000, "Member 'MM_Popup_XsollaIAP_OnUrlChanged::URL' has a wrong offset!");

// Function MirMobile.MM_B_Party_Info.StopAutoMission
// 0x0001 (0x0001 - 0x0000)
struct MM_B_Party_Info_StopAutoMission final
{
public:
	bool                                          IsReader;                                          // 0x0000(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(MM_B_Party_Info_StopAutoMission) == 0x000001, "Wrong alignment on MM_B_Party_Info_StopAutoMission");
static_assert(sizeof(MM_B_Party_Info_StopAutoMission) == 0x000001, "Wrong size on MM_B_Party_Info_StopAutoMission");
static_assert(offsetof(MM_B_Party_Info_StopAutoMission, IsReader) == 0x000000, "Member 'MM_B_Party_Info_StopAutoMission::IsReader' has a wrong offset!");

// Function MirMobile.MM_B_Party_Invite.OnChangeTab
// 0x0008 (0x0008 - 0x0000)
struct MM_B_Party_Invite_OnChangeTab final
{
public:
	int32                                         IIndex;                                            // 0x0000(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bLocked;                                           // 0x0004(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_5[0x3];                                        // 0x0005(0x0003)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(MM_B_Party_Invite_OnChangeTab) == 0x000004, "Wrong alignment on MM_B_Party_Invite_OnChangeTab");
static_assert(sizeof(MM_B_Party_Invite_OnChangeTab) == 0x000008, "Wrong size on MM_B_Party_Invite_OnChangeTab");
static_assert(offsetof(MM_B_Party_Invite_OnChangeTab, IIndex) == 0x000000, "Member 'MM_B_Party_Invite_OnChangeTab::IIndex' has a wrong offset!");
static_assert(offsetof(MM_B_Party_Invite_OnChangeTab, bLocked) == 0x000004, "Member 'MM_B_Party_Invite_OnChangeTab::bLocked' has a wrong offset!");

// Function MirMobile.MM_B_Party_Invite.OnTextNickNameCommitted
// 0x0020 (0x0020 - 0x0000)
struct MM_B_Party_Invite_OnTextNickNameCommitted final
{
public:
	class FText                                   Text;                                              // 0x0000(0x0018)(ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
	ETextCommit                                   CommitMethod;                                      // 0x0018(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_19[0x7];                                       // 0x0019(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(MM_B_Party_Invite_OnTextNickNameCommitted) == 0x000008, "Wrong alignment on MM_B_Party_Invite_OnTextNickNameCommitted");
static_assert(sizeof(MM_B_Party_Invite_OnTextNickNameCommitted) == 0x000020, "Wrong size on MM_B_Party_Invite_OnTextNickNameCommitted");
static_assert(offsetof(MM_B_Party_Invite_OnTextNickNameCommitted, Text) == 0x000000, "Member 'MM_B_Party_Invite_OnTextNickNameCommitted::Text' has a wrong offset!");
static_assert(offsetof(MM_B_Party_Invite_OnTextNickNameCommitted, CommitMethod) == 0x000018, "Member 'MM_B_Party_Invite_OnTextNickNameCommitted::CommitMethod' has a wrong offset!");

// Function MirMobile.MM_B_Party_List.OnClickCheckBoxAlarm
// 0x0001 (0x0001 - 0x0000)
struct MM_B_Party_List_OnClickCheckBoxAlarm final
{
public:
	bool                                          bChecked;                                          // 0x0000(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(MM_B_Party_List_OnClickCheckBoxAlarm) == 0x000001, "Wrong alignment on MM_B_Party_List_OnClickCheckBoxAlarm");
static_assert(sizeof(MM_B_Party_List_OnClickCheckBoxAlarm) == 0x000001, "Wrong size on MM_B_Party_List_OnClickCheckBoxAlarm");
static_assert(offsetof(MM_B_Party_List_OnClickCheckBoxAlarm, bChecked) == 0x000000, "Member 'MM_B_Party_List_OnClickCheckBoxAlarm::bChecked' has a wrong offset!");

// Function MirMobile.MM_B_Party_List.OnClickCheckBoxGuild
// 0x0001 (0x0001 - 0x0000)
struct MM_B_Party_List_OnClickCheckBoxGuild final
{
public:
	bool                                          bChecked;                                          // 0x0000(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(MM_B_Party_List_OnClickCheckBoxGuild) == 0x000001, "Wrong alignment on MM_B_Party_List_OnClickCheckBoxGuild");
static_assert(sizeof(MM_B_Party_List_OnClickCheckBoxGuild) == 0x000001, "Wrong size on MM_B_Party_List_OnClickCheckBoxGuild");
static_assert(offsetof(MM_B_Party_List_OnClickCheckBoxGuild, bChecked) == 0x000000, "Member 'MM_B_Party_List_OnClickCheckBoxGuild::bChecked' has a wrong offset!");

// Function MirMobile.MM_B_Party_List.ReturnMaxLv
// 0x0008 (0x0008 - 0x0000)
struct MM_B_Party_List_ReturnMaxLv final
{
public:
	int64                                         IValue;                                            // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(MM_B_Party_List_ReturnMaxLv) == 0x000008, "Wrong alignment on MM_B_Party_List_ReturnMaxLv");
static_assert(sizeof(MM_B_Party_List_ReturnMaxLv) == 0x000008, "Wrong size on MM_B_Party_List_ReturnMaxLv");
static_assert(offsetof(MM_B_Party_List_ReturnMaxLv, IValue) == 0x000000, "Member 'MM_B_Party_List_ReturnMaxLv::IValue' has a wrong offset!");

// Function MirMobile.MM_B_Party_List.ReturnMinLv
// 0x0008 (0x0008 - 0x0000)
struct MM_B_Party_List_ReturnMinLv final
{
public:
	int64                                         IValue;                                            // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(MM_B_Party_List_ReturnMinLv) == 0x000008, "Wrong alignment on MM_B_Party_List_ReturnMinLv");
static_assert(sizeof(MM_B_Party_List_ReturnMinLv) == 0x000008, "Wrong size on MM_B_Party_List_ReturnMinLv");
static_assert(offsetof(MM_B_Party_List_ReturnMinLv, IValue) == 0x000000, "Member 'MM_B_Party_List_ReturnMinLv::IValue' has a wrong offset!");

// Function MirMobile.MM_B_Pet.OnPetLoaded
// 0x0004 (0x0004 - 0x0000)
struct MM_B_Pet_OnPetLoaded final
{
public:
	int32                                         IPetID;                                            // 0x0000(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(MM_B_Pet_OnPetLoaded) == 0x000004, "Wrong alignment on MM_B_Pet_OnPetLoaded");
static_assert(sizeof(MM_B_Pet_OnPetLoaded) == 0x000004, "Wrong size on MM_B_Pet_OnPetLoaded");
static_assert(offsetof(MM_B_Pet_OnPetLoaded, IPetID) == 0x000000, "Member 'MM_B_Pet_OnPetLoaded::IPetID' has a wrong offset!");

// Function MirMobile.MM_Popup_SteamIAP.OnUrlChanged
// 0x0018 (0x0018 - 0x0000)
struct MM_Popup_SteamIAP_OnUrlChanged final
{
public:
	class FText                                   URL;                                               // 0x0000(0x0018)(ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
};
static_assert(alignof(MM_Popup_SteamIAP_OnUrlChanged) == 0x000008, "Wrong alignment on MM_Popup_SteamIAP_OnUrlChanged");
static_assert(sizeof(MM_Popup_SteamIAP_OnUrlChanged) == 0x000018, "Wrong size on MM_Popup_SteamIAP_OnUrlChanged");
static_assert(offsetof(MM_Popup_SteamIAP_OnUrlChanged, URL) == 0x000000, "Member 'MM_Popup_SteamIAP_OnUrlChanged::URL' has a wrong offset!");

// Function MirMobile.MM_B_PKRecord.UpdateCurrentPage
// 0x0001 (0x0001 - 0x0000)
struct MM_B_PKRecord_UpdateCurrentPage final
{
public:
	bool                                          IsCheck;                                           // 0x0000(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(MM_B_PKRecord_UpdateCurrentPage) == 0x000001, "Wrong alignment on MM_B_PKRecord_UpdateCurrentPage");
static_assert(sizeof(MM_B_PKRecord_UpdateCurrentPage) == 0x000001, "Wrong size on MM_B_PKRecord_UpdateCurrentPage");
static_assert(offsetof(MM_B_PKRecord_UpdateCurrentPage, IsCheck) == 0x000000, "Member 'MM_B_PKRecord_UpdateCurrentPage::IsCheck' has a wrong offset!");

// Function MirMobile.MM_B_Potential.DrawLine
// 0x0018 (0x0018 - 0x0000)
struct MM_B_Potential_DrawLine final
{
public:
	class UWidget*                                PLine;                                             // 0x0000(0x0008)(Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UWidget*                                PStartNode;                                        // 0x0008(0x0008)(Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UWidget*                                PEndNode;                                          // 0x0010(0x0008)(Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(MM_B_Potential_DrawLine) == 0x000008, "Wrong alignment on MM_B_Potential_DrawLine");
static_assert(sizeof(MM_B_Potential_DrawLine) == 0x000018, "Wrong size on MM_B_Potential_DrawLine");
static_assert(offsetof(MM_B_Potential_DrawLine, PLine) == 0x000000, "Member 'MM_B_Potential_DrawLine::PLine' has a wrong offset!");
static_assert(offsetof(MM_B_Potential_DrawLine, PStartNode) == 0x000008, "Member 'MM_B_Potential_DrawLine::PStartNode' has a wrong offset!");
static_assert(offsetof(MM_B_Potential_DrawLine, PEndNode) == 0x000010, "Member 'MM_B_Potential_DrawLine::PEndNode' has a wrong offset!");

// Function MirMobile.MM_B_Potential.GetPotentialLineInfo_ForDesignTime
// 0x0050 (0x0050 - 0x0000)
struct MM_B_Potential_GetPotentialLineInfo_ForDesignTime final
{
public:
	TMap<int32, struct FPotentialLineInfo_ForDesignTime> _Out;                                              // 0x0000(0x0050)(Parm, OutParm, ZeroConstructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(MM_B_Potential_GetPotentialLineInfo_ForDesignTime) == 0x000008, "Wrong alignment on MM_B_Potential_GetPotentialLineInfo_ForDesignTime");
static_assert(sizeof(MM_B_Potential_GetPotentialLineInfo_ForDesignTime) == 0x000050, "Wrong size on MM_B_Potential_GetPotentialLineInfo_ForDesignTime");
static_assert(offsetof(MM_B_Potential_GetPotentialLineInfo_ForDesignTime, _Out) == 0x000000, "Member 'MM_B_Potential_GetPotentialLineInfo_ForDesignTime::_Out' has a wrong offset!");

// Function MirMobile.MM_B_Potential.OnChangedZoom
// 0x0004 (0x0004 - 0x0000)
struct MM_B_Potential_OnChangedZoom final
{
public:
	float                                         FZoom;                                             // 0x0000(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(MM_B_Potential_OnChangedZoom) == 0x000004, "Wrong alignment on MM_B_Potential_OnChangedZoom");
static_assert(sizeof(MM_B_Potential_OnChangedZoom) == 0x000004, "Wrong size on MM_B_Potential_OnChangedZoom");
static_assert(offsetof(MM_B_Potential_OnChangedZoom, FZoom) == 0x000000, "Member 'MM_B_Potential_OnChangedZoom::FZoom' has a wrong offset!");

// Function MirMobile.MM_B_Potential.OnClickShowTrainingAble
// 0x0001 (0x0001 - 0x0000)
struct MM_B_Potential_OnClickShowTrainingAble final
{
public:
	bool                                          bChecked;                                          // 0x0000(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(MM_B_Potential_OnClickShowTrainingAble) == 0x000001, "Wrong alignment on MM_B_Potential_OnClickShowTrainingAble");
static_assert(sizeof(MM_B_Potential_OnClickShowTrainingAble) == 0x000001, "Wrong size on MM_B_Potential_OnClickShowTrainingAble");
static_assert(offsetof(MM_B_Potential_OnClickShowTrainingAble, bChecked) == 0x000000, "Member 'MM_B_Potential_OnClickShowTrainingAble::bChecked' has a wrong offset!");

// Function MirMobile.MM_B_Potential.OnEditFilterCommitted
// 0x0020 (0x0020 - 0x0000)
struct MM_B_Potential_OnEditFilterCommitted final
{
public:
	class FText                                   Text;                                              // 0x0000(0x0018)(ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
	ETextCommit                                   CommitMethod;                                      // 0x0018(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_19[0x7];                                       // 0x0019(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(MM_B_Potential_OnEditFilterCommitted) == 0x000008, "Wrong alignment on MM_B_Potential_OnEditFilterCommitted");
static_assert(sizeof(MM_B_Potential_OnEditFilterCommitted) == 0x000020, "Wrong size on MM_B_Potential_OnEditFilterCommitted");
static_assert(offsetof(MM_B_Potential_OnEditFilterCommitted, Text) == 0x000000, "Member 'MM_B_Potential_OnEditFilterCommitted::Text' has a wrong offset!");
static_assert(offsetof(MM_B_Potential_OnEditFilterCommitted, CommitMethod) == 0x000018, "Member 'MM_B_Potential_OnEditFilterCommitted::CommitMethod' has a wrong offset!");

// Function MirMobile.MM_B_QuestNormal.OnClickCheckBox
// 0x0001 (0x0001 - 0x0000)
struct MM_B_QuestNormal_OnClickCheckBox final
{
public:
	bool                                          Checked;                                           // 0x0000(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(MM_B_QuestNormal_OnClickCheckBox) == 0x000001, "Wrong alignment on MM_B_QuestNormal_OnClickCheckBox");
static_assert(sizeof(MM_B_QuestNormal_OnClickCheckBox) == 0x000001, "Wrong size on MM_B_QuestNormal_OnClickCheckBox");
static_assert(offsetof(MM_B_QuestNormal_OnClickCheckBox, Checked) == 0x000000, "Member 'MM_B_QuestNormal_OnClickCheckBox::Checked' has a wrong offset!");

// Function MirMobile.MM_B_QuestNormal.OnClickStage
// 0x0008 (0x0008 - 0x0000)
struct MM_B_QuestNormal_OnClickStage final
{
public:
	int32                                         SlotIndex;                                         // 0x0000(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bLocked;                                           // 0x0004(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_5[0x3];                                        // 0x0005(0x0003)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(MM_B_QuestNormal_OnClickStage) == 0x000004, "Wrong alignment on MM_B_QuestNormal_OnClickStage");
static_assert(sizeof(MM_B_QuestNormal_OnClickStage) == 0x000008, "Wrong size on MM_B_QuestNormal_OnClickStage");
static_assert(offsetof(MM_B_QuestNormal_OnClickStage, SlotIndex) == 0x000000, "Member 'MM_B_QuestNormal_OnClickStage::SlotIndex' has a wrong offset!");
static_assert(offsetof(MM_B_QuestNormal_OnClickStage, bLocked) == 0x000004, "Member 'MM_B_QuestNormal_OnClickStage::bLocked' has a wrong offset!");

// Function MirMobile.MM_B_QuestNormal.OnClickStageType
// 0x0008 (0x0008 - 0x0000)
struct MM_B_QuestNormal_OnClickStageType final
{
public:
	int32                                         SlotIndex;                                         // 0x0000(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bLocked;                                           // 0x0004(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_5[0x3];                                        // 0x0005(0x0003)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(MM_B_QuestNormal_OnClickStageType) == 0x000004, "Wrong alignment on MM_B_QuestNormal_OnClickStageType");
static_assert(sizeof(MM_B_QuestNormal_OnClickStageType) == 0x000008, "Wrong size on MM_B_QuestNormal_OnClickStageType");
static_assert(offsetof(MM_B_QuestNormal_OnClickStageType, SlotIndex) == 0x000000, "Member 'MM_B_QuestNormal_OnClickStageType::SlotIndex' has a wrong offset!");
static_assert(offsetof(MM_B_QuestNormal_OnClickStageType, bLocked) == 0x000004, "Member 'MM_B_QuestNormal_OnClickStageType::bLocked' has a wrong offset!");

// Function MirMobile.MM_B_Ranking.OnClickVerticalTab
// 0x0008 (0x0008 - 0x0000)
struct MM_B_Ranking_OnClickVerticalTab final
{
public:
	int32                                         SlotIndex;                                         // 0x0000(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bLocked;                                           // 0x0004(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_5[0x3];                                        // 0x0005(0x0003)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(MM_B_Ranking_OnClickVerticalTab) == 0x000004, "Wrong alignment on MM_B_Ranking_OnClickVerticalTab");
static_assert(sizeof(MM_B_Ranking_OnClickVerticalTab) == 0x000008, "Wrong size on MM_B_Ranking_OnClickVerticalTab");
static_assert(offsetof(MM_B_Ranking_OnClickVerticalTab, SlotIndex) == 0x000000, "Member 'MM_B_Ranking_OnClickVerticalTab::SlotIndex' has a wrong offset!");
static_assert(offsetof(MM_B_Ranking_OnClickVerticalTab, bLocked) == 0x000004, "Member 'MM_B_Ranking_OnClickVerticalTab::bLocked' has a wrong offset!");

// Function MirMobile.MM_B_Request.OnClickCheckBox
// 0x0001 (0x0001 - 0x0000)
struct MM_B_Request_OnClickCheckBox final
{
public:
	bool                                          Checked;                                           // 0x0000(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(MM_B_Request_OnClickCheckBox) == 0x000001, "Wrong alignment on MM_B_Request_OnClickCheckBox");
static_assert(sizeof(MM_B_Request_OnClickCheckBox) == 0x000001, "Wrong size on MM_B_Request_OnClickCheckBox");
static_assert(offsetof(MM_B_Request_OnClickCheckBox, Checked) == 0x000000, "Member 'MM_B_Request_OnClickCheckBox::Checked' has a wrong offset!");

// Function MirMobile.MM_B_Request.OnClickStage
// 0x0008 (0x0008 - 0x0000)
struct MM_B_Request_OnClickStage final
{
public:
	int32                                         SlotIndex;                                         // 0x0000(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bLocked;                                           // 0x0004(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_5[0x3];                                        // 0x0005(0x0003)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(MM_B_Request_OnClickStage) == 0x000004, "Wrong alignment on MM_B_Request_OnClickStage");
static_assert(sizeof(MM_B_Request_OnClickStage) == 0x000008, "Wrong size on MM_B_Request_OnClickStage");
static_assert(offsetof(MM_B_Request_OnClickStage, SlotIndex) == 0x000000, "Member 'MM_B_Request_OnClickStage::SlotIndex' has a wrong offset!");
static_assert(offsetof(MM_B_Request_OnClickStage, bLocked) == 0x000004, "Member 'MM_B_Request_OnClickStage::bLocked' has a wrong offset!");

// Function MirMobile.MM_B_Request.OnClickStageType
// 0x0008 (0x0008 - 0x0000)
struct MM_B_Request_OnClickStageType final
{
public:
	int32                                         SlotIndex;                                         // 0x0000(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bLocked;                                           // 0x0004(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_5[0x3];                                        // 0x0005(0x0003)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(MM_B_Request_OnClickStageType) == 0x000004, "Wrong alignment on MM_B_Request_OnClickStageType");
static_assert(sizeof(MM_B_Request_OnClickStageType) == 0x000008, "Wrong size on MM_B_Request_OnClickStageType");
static_assert(offsetof(MM_B_Request_OnClickStageType, SlotIndex) == 0x000000, "Member 'MM_B_Request_OnClickStageType::SlotIndex' has a wrong offset!");
static_assert(offsetof(MM_B_Request_OnClickStageType, bLocked) == 0x000004, "Member 'MM_B_Request_OnClickStageType::bLocked' has a wrong offset!");

// Function MirMobile.MM_B_Sabuk_Dominion.OnClickMainTab
// 0x0008 (0x0008 - 0x0000)
struct MM_B_Sabuk_Dominion_OnClickMainTab final
{
public:
	int32                                         ITabIndex;                                         // 0x0000(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bLocked;                                           // 0x0004(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_5[0x3];                                        // 0x0005(0x0003)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(MM_B_Sabuk_Dominion_OnClickMainTab) == 0x000004, "Wrong alignment on MM_B_Sabuk_Dominion_OnClickMainTab");
static_assert(sizeof(MM_B_Sabuk_Dominion_OnClickMainTab) == 0x000008, "Wrong size on MM_B_Sabuk_Dominion_OnClickMainTab");
static_assert(offsetof(MM_B_Sabuk_Dominion_OnClickMainTab, ITabIndex) == 0x000000, "Member 'MM_B_Sabuk_Dominion_OnClickMainTab::ITabIndex' has a wrong offset!");
static_assert(offsetof(MM_B_Sabuk_Dominion_OnClickMainTab, bLocked) == 0x000004, "Member 'MM_B_Sabuk_Dominion_OnClickMainTab::bLocked' has a wrong offset!");

// Function MirMobile.MM_B_Sabuk_Situationboard.OnClickCheckBoxCommandInfo
// 0x0001 (0x0001 - 0x0000)
struct MM_B_Sabuk_Situationboard_OnClickCheckBoxCommandInfo final
{
public:
	bool                                          Checked;                                           // 0x0000(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(MM_B_Sabuk_Situationboard_OnClickCheckBoxCommandInfo) == 0x000001, "Wrong alignment on MM_B_Sabuk_Situationboard_OnClickCheckBoxCommandInfo");
static_assert(sizeof(MM_B_Sabuk_Situationboard_OnClickCheckBoxCommandInfo) == 0x000001, "Wrong size on MM_B_Sabuk_Situationboard_OnClickCheckBoxCommandInfo");
static_assert(offsetof(MM_B_Sabuk_Situationboard_OnClickCheckBoxCommandInfo, Checked) == 0x000000, "Member 'MM_B_Sabuk_Situationboard_OnClickCheckBoxCommandInfo::Checked' has a wrong offset!");

// Function MirMobile.MM_Popup_Skill_ItemExchange.OnChangeMakeCount
// 0x0008 (0x0008 - 0x0000)
struct MM_Popup_Skill_ItemExchange_OnChangeMakeCount final
{
public:
	int64                                         MakeCount;                                         // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(MM_Popup_Skill_ItemExchange_OnChangeMakeCount) == 0x000008, "Wrong alignment on MM_Popup_Skill_ItemExchange_OnChangeMakeCount");
static_assert(sizeof(MM_Popup_Skill_ItemExchange_OnChangeMakeCount) == 0x000008, "Wrong size on MM_Popup_Skill_ItemExchange_OnChangeMakeCount");
static_assert(offsetof(MM_Popup_Skill_ItemExchange_OnChangeMakeCount, MakeCount) == 0x000000, "Member 'MM_Popup_Skill_ItemExchange_OnChangeMakeCount::MakeCount' has a wrong offset!");

// Function MirMobile.MM_Common_ComboList.OnClickSlot
// 0x0008 (0x0008 - 0x0000)
struct MM_Common_ComboList_OnClickSlot final
{
public:
	const class UMM_Common_ComboSlot*             ComboSlot;                                         // 0x0000(0x0008)(ConstParm, Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(MM_Common_ComboList_OnClickSlot) == 0x000008, "Wrong alignment on MM_Common_ComboList_OnClickSlot");
static_assert(sizeof(MM_Common_ComboList_OnClickSlot) == 0x000008, "Wrong size on MM_Common_ComboList_OnClickSlot");
static_assert(offsetof(MM_Common_ComboList_OnClickSlot, ComboSlot) == 0x000000, "Member 'MM_Common_ComboList_OnClickSlot::ComboSlot' has a wrong offset!");

// Function MirMobile.MM_Common_Popup_EditText.OnTextCommitted
// 0x0020 (0x0020 - 0x0000)
struct MM_Common_Popup_EditText_OnTextCommitted final
{
public:
	class FText                                   Text_;                                             // 0x0000(0x0018)(ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
	ETextCommit                                   Commit_method_;                                    // 0x0018(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_19[0x7];                                       // 0x0019(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(MM_Common_Popup_EditText_OnTextCommitted) == 0x000008, "Wrong alignment on MM_Common_Popup_EditText_OnTextCommitted");
static_assert(sizeof(MM_Common_Popup_EditText_OnTextCommitted) == 0x000020, "Wrong size on MM_Common_Popup_EditText_OnTextCommitted");
static_assert(offsetof(MM_Common_Popup_EditText_OnTextCommitted, Text_) == 0x000000, "Member 'MM_Common_Popup_EditText_OnTextCommitted::Text_' has a wrong offset!");
static_assert(offsetof(MM_Common_Popup_EditText_OnTextCommitted, Commit_method_) == 0x000018, "Member 'MM_Common_Popup_EditText_OnTextCommitted::Commit_method_' has a wrong offset!");

// Function MirMobile.MM_Common_GuideBtn.OnGetGuideURL
// 0x0010 (0x0010 - 0x0000)
struct MM_Common_GuideBtn_OnGetGuideURL final
{
public:
	class FString                                 StrGuideURL;                                       // 0x0000(0x0010)(Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(MM_Common_GuideBtn_OnGetGuideURL) == 0x000008, "Wrong alignment on MM_Common_GuideBtn_OnGetGuideURL");
static_assert(sizeof(MM_Common_GuideBtn_OnGetGuideURL) == 0x000010, "Wrong size on MM_Common_GuideBtn_OnGetGuideURL");
static_assert(offsetof(MM_Common_GuideBtn_OnGetGuideURL, StrGuideURL) == 0x000000, "Member 'MM_Common_GuideBtn_OnGetGuideURL::StrGuideURL' has a wrong offset!");

// Function MirMobile.MM_B_Squad_Info.OnClickCheckBoxAutoStart
// 0x0001 (0x0001 - 0x0000)
struct MM_B_Squad_Info_OnClickCheckBoxAutoStart final
{
public:
	bool                                          bChecked;                                          // 0x0000(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(MM_B_Squad_Info_OnClickCheckBoxAutoStart) == 0x000001, "Wrong alignment on MM_B_Squad_Info_OnClickCheckBoxAutoStart");
static_assert(sizeof(MM_B_Squad_Info_OnClickCheckBoxAutoStart) == 0x000001, "Wrong size on MM_B_Squad_Info_OnClickCheckBoxAutoStart");
static_assert(offsetof(MM_B_Squad_Info_OnClickCheckBoxAutoStart, bChecked) == 0x000000, "Member 'MM_B_Squad_Info_OnClickCheckBoxAutoStart::bChecked' has a wrong offset!");

// Function MirMobile.MM_B_Squad_Info.OnClickSlot
// 0x0008 (0x0008 - 0x0000)
struct MM_B_Squad_Info_OnClickSlot final
{
public:
	class UMM_Slot_Base*                          PSlot;                                             // 0x0000(0x0008)(Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(MM_B_Squad_Info_OnClickSlot) == 0x000008, "Wrong alignment on MM_B_Squad_Info_OnClickSlot");
static_assert(sizeof(MM_B_Squad_Info_OnClickSlot) == 0x000008, "Wrong size on MM_B_Squad_Info_OnClickSlot");
static_assert(offsetof(MM_B_Squad_Info_OnClickSlot, PSlot) == 0x000000, "Member 'MM_B_Squad_Info_OnClickSlot::PSlot' has a wrong offset!");

// Function MirMobile.MM_B_Squad_List.OnClickCheckBoxBookmark
// 0x0001 (0x0001 - 0x0000)
struct MM_B_Squad_List_OnClickCheckBoxBookmark final
{
public:
	bool                                          bChecked;                                          // 0x0000(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(MM_B_Squad_List_OnClickCheckBoxBookmark) == 0x000001, "Wrong alignment on MM_B_Squad_List_OnClickCheckBoxBookmark");
static_assert(sizeof(MM_B_Squad_List_OnClickCheckBoxBookmark) == 0x000001, "Wrong size on MM_B_Squad_List_OnClickCheckBoxBookmark");
static_assert(offsetof(MM_B_Squad_List_OnClickCheckBoxBookmark, bChecked) == 0x000000, "Member 'MM_B_Squad_List_OnClickCheckBoxBookmark::bChecked' has a wrong offset!");

// Function MirMobile.MM_B_Squad_List.OnClickHorizonTabBtn
// 0x0008 (0x0008 - 0x0000)
struct MM_B_Squad_List_OnClickHorizonTabBtn final
{
public:
	int32                                         Idx;                                               // 0x0000(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bLocked;                                           // 0x0004(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_5[0x3];                                        // 0x0005(0x0003)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(MM_B_Squad_List_OnClickHorizonTabBtn) == 0x000004, "Wrong alignment on MM_B_Squad_List_OnClickHorizonTabBtn");
static_assert(sizeof(MM_B_Squad_List_OnClickHorizonTabBtn) == 0x000008, "Wrong size on MM_B_Squad_List_OnClickHorizonTabBtn");
static_assert(offsetof(MM_B_Squad_List_OnClickHorizonTabBtn, Idx) == 0x000000, "Member 'MM_B_Squad_List_OnClickHorizonTabBtn::Idx' has a wrong offset!");
static_assert(offsetof(MM_B_Squad_List_OnClickHorizonTabBtn, bLocked) == 0x000004, "Member 'MM_B_Squad_List_OnClickHorizonTabBtn::bLocked' has a wrong offset!");

// Function MirMobile.MM_B_Synthesis.OnClickTabHorizon
// 0x0008 (0x0008 - 0x0000)
struct MM_B_Synthesis_OnClickTabHorizon final
{
public:
	int32                                         IIndex;                                            // 0x0000(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bLocked;                                           // 0x0004(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_5[0x3];                                        // 0x0005(0x0003)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(MM_B_Synthesis_OnClickTabHorizon) == 0x000004, "Wrong alignment on MM_B_Synthesis_OnClickTabHorizon");
static_assert(sizeof(MM_B_Synthesis_OnClickTabHorizon) == 0x000008, "Wrong size on MM_B_Synthesis_OnClickTabHorizon");
static_assert(offsetof(MM_B_Synthesis_OnClickTabHorizon, IIndex) == 0x000000, "Member 'MM_B_Synthesis_OnClickTabHorizon::IIndex' has a wrong offset!");
static_assert(offsetof(MM_B_Synthesis_OnClickTabHorizon, bLocked) == 0x000004, "Member 'MM_B_Synthesis_OnClickTabHorizon::bLocked' has a wrong offset!");

// Function MirMobile.MM_B_Synthesis.OnClickTabVertical
// 0x0008 (0x0008 - 0x0000)
struct MM_B_Synthesis_OnClickTabVertical final
{
public:
	int32                                         IIndex;                                            // 0x0000(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bLocked;                                           // 0x0004(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_5[0x3];                                        // 0x0005(0x0003)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(MM_B_Synthesis_OnClickTabVertical) == 0x000004, "Wrong alignment on MM_B_Synthesis_OnClickTabVertical");
static_assert(sizeof(MM_B_Synthesis_OnClickTabVertical) == 0x000008, "Wrong size on MM_B_Synthesis_OnClickTabVertical");
static_assert(offsetof(MM_B_Synthesis_OnClickTabVertical, IIndex) == 0x000000, "Member 'MM_B_Synthesis_OnClickTabVertical::IIndex' has a wrong offset!");
static_assert(offsetof(MM_B_Synthesis_OnClickTabVertical, bLocked) == 0x000004, "Member 'MM_B_Synthesis_OnClickTabVertical::bLocked' has a wrong offset!");

// Function MirMobile.MM_GameOption_Switch.OnClickSwitch
// 0x0001 (0x0001 - 0x0000)
struct MM_GameOption_Switch_OnClickSwitch final
{
public:
	bool                                          bChecked;                                          // 0x0000(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(MM_GameOption_Switch_OnClickSwitch) == 0x000001, "Wrong alignment on MM_GameOption_Switch_OnClickSwitch");
static_assert(sizeof(MM_GameOption_Switch_OnClickSwitch) == 0x000001, "Wrong size on MM_GameOption_Switch_OnClickSwitch");
static_assert(offsetof(MM_GameOption_Switch_OnClickSwitch, bChecked) == 0x000000, "Member 'MM_GameOption_Switch_OnClickSwitch::bChecked' has a wrong offset!");

// Function MirMobile.MM_Popup_Sabuk_Class.OnSelectDelegate
// 0x0004 (0x0004 - 0x0000)
struct MM_Popup_Sabuk_Class_OnSelectDelegate final
{
public:
	int32                                         IPBS_ID;                                           // 0x0000(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(MM_Popup_Sabuk_Class_OnSelectDelegate) == 0x000004, "Wrong alignment on MM_Popup_Sabuk_Class_OnSelectDelegate");
static_assert(sizeof(MM_Popup_Sabuk_Class_OnSelectDelegate) == 0x000004, "Wrong size on MM_Popup_Sabuk_Class_OnSelectDelegate");
static_assert(offsetof(MM_Popup_Sabuk_Class_OnSelectDelegate, IPBS_ID) == 0x000000, "Member 'MM_Popup_Sabuk_Class_OnSelectDelegate::IPBS_ID' has a wrong offset!");

// Function MirMobile.MM_Common_Slider.OnDragSlider
// 0x0004 (0x0004 - 0x0000)
struct MM_Common_Slider_OnDragSlider final
{
public:
	float                                         Sliderrate;                                        // 0x0000(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(MM_Common_Slider_OnDragSlider) == 0x000004, "Wrong alignment on MM_Common_Slider_OnDragSlider");
static_assert(sizeof(MM_Common_Slider_OnDragSlider) == 0x000004, "Wrong size on MM_Common_Slider_OnDragSlider");
static_assert(offsetof(MM_Common_Slider_OnDragSlider, Sliderrate) == 0x000000, "Member 'MM_Common_Slider_OnDragSlider::Sliderrate' has a wrong offset!");

// Function MirMobile.MM_Common_Slider.SetValueByKeyPad
// 0x0008 (0x0008 - 0x0000)
struct MM_Common_Slider_SetValueByKeyPad final
{
public:
	int64                                         Value_;                                            // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(MM_Common_Slider_SetValueByKeyPad) == 0x000008, "Wrong alignment on MM_Common_Slider_SetValueByKeyPad");
static_assert(sizeof(MM_Common_Slider_SetValueByKeyPad) == 0x000008, "Wrong size on MM_Common_Slider_SetValueByKeyPad");
static_assert(offsetof(MM_Common_Slider_SetValueByKeyPad, Value_) == 0x000000, "Member 'MM_Common_Slider_SetValueByKeyPad::Value_' has a wrong offset!");

// Function MirMobile.MM_B_Transcend.OnClickProbability
// 0x0001 (0x0001 - 0x0000)
struct MM_B_Transcend_OnClickProbability final
{
public:
	bool                                          Checked_;                                          // 0x0000(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(MM_B_Transcend_OnClickProbability) == 0x000001, "Wrong alignment on MM_B_Transcend_OnClickProbability");
static_assert(sizeof(MM_B_Transcend_OnClickProbability) == 0x000001, "Wrong size on MM_B_Transcend_OnClickProbability");
static_assert(offsetof(MM_B_Transcend_OnClickProbability, Checked_) == 0x000000, "Member 'MM_B_Transcend_OnClickProbability::Checked_' has a wrong offset!");

// Function MirMobile.MM_B_UIShopAds.OnClickCheckBoxSkip
// 0x0001 (0x0001 - 0x0000)
struct MM_B_UIShopAds_OnClickCheckBoxSkip final
{
public:
	bool                                          Checked;                                           // 0x0000(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(MM_B_UIShopAds_OnClickCheckBoxSkip) == 0x000001, "Wrong alignment on MM_B_UIShopAds_OnClickCheckBoxSkip");
static_assert(sizeof(MM_B_UIShopAds_OnClickCheckBoxSkip) == 0x000001, "Wrong size on MM_B_UIShopAds_OnClickCheckBoxSkip");
static_assert(offsetof(MM_B_UIShopAds_OnClickCheckBoxSkip, Checked) == 0x000000, "Member 'MM_B_UIShopAds_OnClickCheckBoxSkip::Checked' has a wrong offset!");

// Function MirMobile.MM_MakeItem_Slot_Special.OnClickCraftSwitch
// 0x0004 (0x0004 - 0x0000)
struct MM_MakeItem_Slot_Special_OnClickCraftSwitch final
{
public:
	int32                                         Index_0;                                           // 0x0000(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(MM_MakeItem_Slot_Special_OnClickCraftSwitch) == 0x000004, "Wrong alignment on MM_MakeItem_Slot_Special_OnClickCraftSwitch");
static_assert(sizeof(MM_MakeItem_Slot_Special_OnClickCraftSwitch) == 0x000004, "Wrong size on MM_MakeItem_Slot_Special_OnClickCraftSwitch");
static_assert(offsetof(MM_MakeItem_Slot_Special_OnClickCraftSwitch, Index_0) == 0x000000, "Member 'MM_MakeItem_Slot_Special_OnClickCraftSwitch::Index_0' has a wrong offset!");

// Function MirMobile.MM_B_Unsealing.PlayCloseAni
// 0x0004 (0x0004 - 0x0000)
struct MM_B_Unsealing_PlayCloseAni final
{
public:
	float                                         ReturnValue;                                       // 0x0000(0x0004)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(MM_B_Unsealing_PlayCloseAni) == 0x000004, "Wrong alignment on MM_B_Unsealing_PlayCloseAni");
static_assert(sizeof(MM_B_Unsealing_PlayCloseAni) == 0x000004, "Wrong size on MM_B_Unsealing_PlayCloseAni");
static_assert(offsetof(MM_B_Unsealing_PlayCloseAni, ReturnValue) == 0x000000, "Member 'MM_B_Unsealing_PlayCloseAni::ReturnValue' has a wrong offset!");

// Function MirMobile.MM_SaleItemBasket.OnClick_CheckOption
// 0x0001 (0x0001 - 0x0000)
struct MM_SaleItemBasket_OnClick_CheckOption final
{
public:
	bool                                          bChecked;                                          // 0x0000(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(MM_SaleItemBasket_OnClick_CheckOption) == 0x000001, "Wrong alignment on MM_SaleItemBasket_OnClick_CheckOption");
static_assert(sizeof(MM_SaleItemBasket_OnClick_CheckOption) == 0x000001, "Wrong size on MM_SaleItemBasket_OnClick_CheckOption");
static_assert(offsetof(MM_SaleItemBasket_OnClick_CheckOption, bChecked) == 0x000000, "Member 'MM_SaleItemBasket_OnClick_CheckOption::bChecked' has a wrong offset!");

// Function MirMobile.MM_B_Wanted.OnClickVrtTab
// 0x0008 (0x0008 - 0x0000)
struct MM_B_Wanted_OnClickVrtTab final
{
public:
	int32                                         IIndex;                                            // 0x0000(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bLocked;                                           // 0x0004(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_5[0x3];                                        // 0x0005(0x0003)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(MM_B_Wanted_OnClickVrtTab) == 0x000004, "Wrong alignment on MM_B_Wanted_OnClickVrtTab");
static_assert(sizeof(MM_B_Wanted_OnClickVrtTab) == 0x000008, "Wrong size on MM_B_Wanted_OnClickVrtTab");
static_assert(offsetof(MM_B_Wanted_OnClickVrtTab, IIndex) == 0x000000, "Member 'MM_B_Wanted_OnClickVrtTab::IIndex' has a wrong offset!");
static_assert(offsetof(MM_B_Wanted_OnClickVrtTab, bLocked) == 0x000004, "Member 'MM_B_Wanted_OnClickVrtTab::bLocked' has a wrong offset!");

// Function MirMobile.MM_B_Wanted.ReqWantedList
// 0x000C (0x000C - 0x0000)
struct MM_B_Wanted_ReqWantedList final
{
public:
	int32                                         ListType;                                          // 0x0000(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         SortType;                                          // 0x0004(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         PageIndex;                                         // 0x0008(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(MM_B_Wanted_ReqWantedList) == 0x000004, "Wrong alignment on MM_B_Wanted_ReqWantedList");
static_assert(sizeof(MM_B_Wanted_ReqWantedList) == 0x00000C, "Wrong size on MM_B_Wanted_ReqWantedList");
static_assert(offsetof(MM_B_Wanted_ReqWantedList, ListType) == 0x000000, "Member 'MM_B_Wanted_ReqWantedList::ListType' has a wrong offset!");
static_assert(offsetof(MM_B_Wanted_ReqWantedList, SortType) == 0x000004, "Member 'MM_B_Wanted_ReqWantedList::SortType' has a wrong offset!");
static_assert(offsetof(MM_B_Wanted_ReqWantedList, PageIndex) == 0x000008, "Member 'MM_B_Wanted_ReqWantedList::PageIndex' has a wrong offset!");

// Function MirMobile.MM_CommonVerticalTabBtn.AddTutorialHighLight
// 0x0010 (0x0010 - 0x0000)
struct MM_CommonVerticalTabBtn_AddTutorialHighLight final
{
public:
	class FString                                 TargetName;                                        // 0x0000(0x0010)(Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(MM_CommonVerticalTabBtn_AddTutorialHighLight) == 0x000008, "Wrong alignment on MM_CommonVerticalTabBtn_AddTutorialHighLight");
static_assert(sizeof(MM_CommonVerticalTabBtn_AddTutorialHighLight) == 0x000010, "Wrong size on MM_CommonVerticalTabBtn_AddTutorialHighLight");
static_assert(offsetof(MM_CommonVerticalTabBtn_AddTutorialHighLight, TargetName) == 0x000000, "Member 'MM_CommonVerticalTabBtn_AddTutorialHighLight::TargetName' has a wrong offset!");

// Function MirMobile.MM_Popup_Occupation_Auction.SetValueByKeyPad
// 0x0008 (0x0008 - 0x0000)
struct MM_Popup_Occupation_Auction_SetValueByKeyPad final
{
public:
	int64                                         Value;                                             // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(MM_Popup_Occupation_Auction_SetValueByKeyPad) == 0x000008, "Wrong alignment on MM_Popup_Occupation_Auction_SetValueByKeyPad");
static_assert(sizeof(MM_Popup_Occupation_Auction_SetValueByKeyPad) == 0x000008, "Wrong size on MM_Popup_Occupation_Auction_SetValueByKeyPad");
static_assert(offsetof(MM_Popup_Occupation_Auction_SetValueByKeyPad, Value) == 0x000000, "Member 'MM_Popup_Occupation_Auction_SetValueByKeyPad::Value' has a wrong offset!");

// Function MirMobile.MM_BattlePass_Reward_Slot.OnClickSlot
// 0x0008 (0x0008 - 0x0000)
struct MM_BattlePass_Reward_Slot_OnClickSlot final
{
public:
	class UMM_Slot_Base*                          PSlot;                                             // 0x0000(0x0008)(Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(MM_BattlePass_Reward_Slot_OnClickSlot) == 0x000008, "Wrong alignment on MM_BattlePass_Reward_Slot_OnClickSlot");
static_assert(sizeof(MM_BattlePass_Reward_Slot_OnClickSlot) == 0x000008, "Wrong size on MM_BattlePass_Reward_Slot_OnClickSlot");
static_assert(offsetof(MM_BattlePass_Reward_Slot_OnClickSlot, PSlot) == 0x000000, "Member 'MM_BattlePass_Reward_Slot_OnClickSlot::PSlot' has a wrong offset!");

// Function MirMobile.MM_ItemCollectSlot.OnClickFavorites
// 0x0001 (0x0001 - 0x0000)
struct MM_ItemCollectSlot_OnClickFavorites final
{
public:
	bool                                          Checked;                                           // 0x0000(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(MM_ItemCollectSlot_OnClickFavorites) == 0x000001, "Wrong alignment on MM_ItemCollectSlot_OnClickFavorites");
static_assert(sizeof(MM_ItemCollectSlot_OnClickFavorites) == 0x000001, "Wrong size on MM_ItemCollectSlot_OnClickFavorites");
static_assert(offsetof(MM_ItemCollectSlot_OnClickFavorites, Checked) == 0x000000, "Member 'MM_ItemCollectSlot_OnClickFavorites::Checked' has a wrong offset!");

// Function MirMobile.MM_ItemCollectSlot.OnClickSlot
// 0x0008 (0x0008 - 0x0000)
struct MM_ItemCollectSlot_OnClickSlot final
{
public:
	class UMM_Slot_Collect_Item*                  PSlot;                                             // 0x0000(0x0008)(Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(MM_ItemCollectSlot_OnClickSlot) == 0x000008, "Wrong alignment on MM_ItemCollectSlot_OnClickSlot");
static_assert(sizeof(MM_ItemCollectSlot_OnClickSlot) == 0x000008, "Wrong size on MM_ItemCollectSlot_OnClickSlot");
static_assert(offsetof(MM_ItemCollectSlot_OnClickSlot, PSlot) == 0x000000, "Member 'MM_ItemCollectSlot_OnClickSlot::PSlot' has a wrong offset!");

// Function MirMobile.MM_SeasonToken_Make_Info.OnChangeSliderCount
// 0x0008 (0x0008 - 0x0000)
struct MM_SeasonToken_Make_Info_OnChangeSliderCount final
{
public:
	int64                                         IExchangeCount;                                    // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(MM_SeasonToken_Make_Info_OnChangeSliderCount) == 0x000008, "Wrong alignment on MM_SeasonToken_Make_Info_OnChangeSliderCount");
static_assert(sizeof(MM_SeasonToken_Make_Info_OnChangeSliderCount) == 0x000008, "Wrong size on MM_SeasonToken_Make_Info_OnChangeSliderCount");
static_assert(offsetof(MM_SeasonToken_Make_Info_OnChangeSliderCount, IExchangeCount) == 0x000000, "Member 'MM_SeasonToken_Make_Info_OnChangeSliderCount::IExchangeCount' has a wrong offset!");

// Function MirMobile.MM_SeasonToken_Make_Info.OnClickSelectedItemSlot
// 0x0010 (0x0010 - 0x0000)
struct MM_SeasonToken_Make_Info_OnClickSelectedItemSlot final
{
public:
	int64                                         Uid;                                               // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         TID;                                               // 0x0008(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         Pos;                                               // 0x000C(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(MM_SeasonToken_Make_Info_OnClickSelectedItemSlot) == 0x000008, "Wrong alignment on MM_SeasonToken_Make_Info_OnClickSelectedItemSlot");
static_assert(sizeof(MM_SeasonToken_Make_Info_OnClickSelectedItemSlot) == 0x000010, "Wrong size on MM_SeasonToken_Make_Info_OnClickSelectedItemSlot");
static_assert(offsetof(MM_SeasonToken_Make_Info_OnClickSelectedItemSlot, Uid) == 0x000000, "Member 'MM_SeasonToken_Make_Info_OnClickSelectedItemSlot::Uid' has a wrong offset!");
static_assert(offsetof(MM_SeasonToken_Make_Info_OnClickSelectedItemSlot, TID) == 0x000008, "Member 'MM_SeasonToken_Make_Info_OnClickSelectedItemSlot::TID' has a wrong offset!");
static_assert(offsetof(MM_SeasonToken_Make_Info_OnClickSelectedItemSlot, Pos) == 0x00000C, "Member 'MM_SeasonToken_Make_Info_OnClickSelectedItemSlot::Pos' has a wrong offset!");

// Function MirMobile.MM_BlueprintActionEffect.SetActionData
// 0x0008 (0x0008 - 0x0000)
struct MM_BlueprintActionEffect_SetActionData final
{
public:
	class UObject*                                EffectActionData;                                  // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(MM_BlueprintActionEffect_SetActionData) == 0x000008, "Wrong alignment on MM_BlueprintActionEffect_SetActionData");
static_assert(sizeof(MM_BlueprintActionEffect_SetActionData) == 0x000008, "Wrong size on MM_BlueprintActionEffect_SetActionData");
static_assert(offsetof(MM_BlueprintActionEffect_SetActionData, EffectActionData) == 0x000000, "Member 'MM_BlueprintActionEffect_SetActionData::EffectActionData' has a wrong offset!");

// Function MirMobile.MM_BlueprintAsyncLoadAction.MMAsyncPackageLoad
// 0x0020 (0x0020 - 0x0000)
struct MM_BlueprintAsyncLoadAction_MMAsyncPackageLoad final
{
public:
	class UObject*                                WorldContextObject;                                // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 AssetPath;                                         // 0x0008(0x0010)(Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UMM_BlueprintAsyncLoadAction*           ReturnValue;                                       // 0x0018(0x0008)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(MM_BlueprintAsyncLoadAction_MMAsyncPackageLoad) == 0x000008, "Wrong alignment on MM_BlueprintAsyncLoadAction_MMAsyncPackageLoad");
static_assert(sizeof(MM_BlueprintAsyncLoadAction_MMAsyncPackageLoad) == 0x000020, "Wrong size on MM_BlueprintAsyncLoadAction_MMAsyncPackageLoad");
static_assert(offsetof(MM_BlueprintAsyncLoadAction_MMAsyncPackageLoad, WorldContextObject) == 0x000000, "Member 'MM_BlueprintAsyncLoadAction_MMAsyncPackageLoad::WorldContextObject' has a wrong offset!");
static_assert(offsetof(MM_BlueprintAsyncLoadAction_MMAsyncPackageLoad, AssetPath) == 0x000008, "Member 'MM_BlueprintAsyncLoadAction_MMAsyncPackageLoad::AssetPath' has a wrong offset!");
static_assert(offsetof(MM_BlueprintAsyncLoadAction_MMAsyncPackageLoad, ReturnValue) == 0x000018, "Member 'MM_BlueprintAsyncLoadAction_MMAsyncPackageLoad::ReturnValue' has a wrong offset!");

// Function MirMobile.MM_Costume_Inventory.OnClickSlot
// 0x0008 (0x0008 - 0x0000)
struct MM_Costume_Inventory_OnClickSlot final
{
public:
	ECOSTUME_PARTS                                CostumeParts;                                      // 0x0000(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1[0x3];                                        // 0x0001(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         CostumeID;                                         // 0x0004(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(MM_Costume_Inventory_OnClickSlot) == 0x000004, "Wrong alignment on MM_Costume_Inventory_OnClickSlot");
static_assert(sizeof(MM_Costume_Inventory_OnClickSlot) == 0x000008, "Wrong size on MM_Costume_Inventory_OnClickSlot");
static_assert(offsetof(MM_Costume_Inventory_OnClickSlot, CostumeParts) == 0x000000, "Member 'MM_Costume_Inventory_OnClickSlot::CostumeParts' has a wrong offset!");
static_assert(offsetof(MM_Costume_Inventory_OnClickSlot, CostumeID) == 0x000004, "Member 'MM_Costume_Inventory_OnClickSlot::CostumeID' has a wrong offset!");

// Function MirMobile.MM_BP_Attendance_Reward_Slot.OnClickSlot
// 0x0008 (0x0008 - 0x0000)
struct MM_BP_Attendance_Reward_Slot_OnClickSlot final
{
public:
	class UMM_Slot_Base*                          PSlot;                                             // 0x0000(0x0008)(Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(MM_BP_Attendance_Reward_Slot_OnClickSlot) == 0x000008, "Wrong alignment on MM_BP_Attendance_Reward_Slot_OnClickSlot");
static_assert(sizeof(MM_BP_Attendance_Reward_Slot_OnClickSlot) == 0x000008, "Wrong size on MM_BP_Attendance_Reward_Slot_OnClickSlot");
static_assert(offsetof(MM_BP_Attendance_Reward_Slot_OnClickSlot, PSlot) == 0x000000, "Member 'MM_BP_Attendance_Reward_Slot_OnClickSlot::PSlot' has a wrong offset!");

// Function MirMobile.MM_Popup_Material_Change.OnClickPopup
// 0x0010 (0x0010 - 0x0000)
struct MM_Popup_Material_Change_OnClickPopup final
{
public:
	int64                                         Uid;                                               // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         TID;                                               // 0x0008(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         EquipPosition;                                     // 0x000C(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(MM_Popup_Material_Change_OnClickPopup) == 0x000008, "Wrong alignment on MM_Popup_Material_Change_OnClickPopup");
static_assert(sizeof(MM_Popup_Material_Change_OnClickPopup) == 0x000010, "Wrong size on MM_Popup_Material_Change_OnClickPopup");
static_assert(offsetof(MM_Popup_Material_Change_OnClickPopup, Uid) == 0x000000, "Member 'MM_Popup_Material_Change_OnClickPopup::Uid' has a wrong offset!");
static_assert(offsetof(MM_Popup_Material_Change_OnClickPopup, TID) == 0x000008, "Member 'MM_Popup_Material_Change_OnClickPopup::TID' has a wrong offset!");
static_assert(offsetof(MM_Popup_Material_Change_OnClickPopup, EquipPosition) == 0x00000C, "Member 'MM_Popup_Material_Change_OnClickPopup::EquipPosition' has a wrong offset!");

// Function MirMobile.MM_Popup_Material_Change.OnClickSlot
// 0x0010 (0x0010 - 0x0000)
struct MM_Popup_Material_Change_OnClickSlot final
{
public:
	int64                                         Uid;                                               // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         TID;                                               // 0x0008(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         EquipPosition;                                     // 0x000C(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(MM_Popup_Material_Change_OnClickSlot) == 0x000008, "Wrong alignment on MM_Popup_Material_Change_OnClickSlot");
static_assert(sizeof(MM_Popup_Material_Change_OnClickSlot) == 0x000010, "Wrong size on MM_Popup_Material_Change_OnClickSlot");
static_assert(offsetof(MM_Popup_Material_Change_OnClickSlot, Uid) == 0x000000, "Member 'MM_Popup_Material_Change_OnClickSlot::Uid' has a wrong offset!");
static_assert(offsetof(MM_Popup_Material_Change_OnClickSlot, TID) == 0x000008, "Member 'MM_Popup_Material_Change_OnClickSlot::TID' has a wrong offset!");
static_assert(offsetof(MM_Popup_Material_Change_OnClickSlot, EquipPosition) == 0x00000C, "Member 'MM_Popup_Material_Change_OnClickSlot::EquipPosition' has a wrong offset!");

// Function MirMobile.MM_QuestNormal_Auto_Slot.OnClickCheckBox
// 0x0001 (0x0001 - 0x0000)
struct MM_QuestNormal_Auto_Slot_OnClickCheckBox final
{
public:
	bool                                          bChecked;                                          // 0x0000(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(MM_QuestNormal_Auto_Slot_OnClickCheckBox) == 0x000001, "Wrong alignment on MM_QuestNormal_Auto_Slot_OnClickCheckBox");
static_assert(sizeof(MM_QuestNormal_Auto_Slot_OnClickCheckBox) == 0x000001, "Wrong size on MM_QuestNormal_Auto_Slot_OnClickCheckBox");
static_assert(offsetof(MM_QuestNormal_Auto_Slot_OnClickCheckBox, bChecked) == 0x000000, "Member 'MM_QuestNormal_Auto_Slot_OnClickCheckBox::bChecked' has a wrong offset!");

// Function MirMobile.MM_Ranking_Reward_Popup.OnClickDaily
// 0x0001 (0x0001 - 0x0000)
struct MM_Ranking_Reward_Popup_OnClickDaily final
{
public:
	bool                                          bChecked;                                          // 0x0000(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(MM_Ranking_Reward_Popup_OnClickDaily) == 0x000001, "Wrong alignment on MM_Ranking_Reward_Popup_OnClickDaily");
static_assert(sizeof(MM_Ranking_Reward_Popup_OnClickDaily) == 0x000001, "Wrong size on MM_Ranking_Reward_Popup_OnClickDaily");
static_assert(offsetof(MM_Ranking_Reward_Popup_OnClickDaily, bChecked) == 0x000000, "Member 'MM_Ranking_Reward_Popup_OnClickDaily::bChecked' has a wrong offset!");

// Function MirMobile.MM_Ranking_Reward_Popup.OnClickSeason
// 0x0001 (0x0001 - 0x0000)
struct MM_Ranking_Reward_Popup_OnClickSeason final
{
public:
	bool                                          bChecked;                                          // 0x0000(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(MM_Ranking_Reward_Popup_OnClickSeason) == 0x000001, "Wrong alignment on MM_Ranking_Reward_Popup_OnClickSeason");
static_assert(sizeof(MM_Ranking_Reward_Popup_OnClickSeason) == 0x000001, "Wrong size on MM_Ranking_Reward_Popup_OnClickSeason");
static_assert(offsetof(MM_Ranking_Reward_Popup_OnClickSeason, bChecked) == 0x000000, "Member 'MM_Ranking_Reward_Popup_OnClickSeason::bChecked' has a wrong offset!");

// Function MirMobile.MM_Ranking_Reward_Popup.OnClickWeekly
// 0x0001 (0x0001 - 0x0000)
struct MM_Ranking_Reward_Popup_OnClickWeekly final
{
public:
	bool                                          bChecked;                                          // 0x0000(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(MM_Ranking_Reward_Popup_OnClickWeekly) == 0x000001, "Wrong alignment on MM_Ranking_Reward_Popup_OnClickWeekly");
static_assert(sizeof(MM_Ranking_Reward_Popup_OnClickWeekly) == 0x000001, "Wrong size on MM_Ranking_Reward_Popup_OnClickWeekly");
static_assert(offsetof(MM_Ranking_Reward_Popup_OnClickWeekly, bChecked) == 0x000000, "Member 'MM_Ranking_Reward_Popup_OnClickWeekly::bChecked' has a wrong offset!");

// Function MirMobile.MM_CharAbility.OnClickTab
// 0x0004 (0x0004 - 0x0000)
struct MM_CharAbility_OnClickTab final
{
public:
	int32                                         NKey;                                              // 0x0000(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(MM_CharAbility_OnClickTab) == 0x000004, "Wrong alignment on MM_CharAbility_OnClickTab");
static_assert(sizeof(MM_CharAbility_OnClickTab) == 0x000004, "Wrong size on MM_CharAbility_OnClickTab");
static_assert(offsetof(MM_CharAbility_OnClickTab, NKey) == 0x000000, "Member 'MM_CharAbility_OnClickTab::NKey' has a wrong offset!");

// Function MirMobile.MM_CharAbility.OnClickTopTab0
// 0x0001 (0x0001 - 0x0000)
struct MM_CharAbility_OnClickTopTab0 final
{
public:
	bool                                          Checked;                                           // 0x0000(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(MM_CharAbility_OnClickTopTab0) == 0x000001, "Wrong alignment on MM_CharAbility_OnClickTopTab0");
static_assert(sizeof(MM_CharAbility_OnClickTopTab0) == 0x000001, "Wrong size on MM_CharAbility_OnClickTopTab0");
static_assert(offsetof(MM_CharAbility_OnClickTopTab0, Checked) == 0x000000, "Member 'MM_CharAbility_OnClickTopTab0::Checked' has a wrong offset!");

// Function MirMobile.MM_CharAbility.OnClickTopTab1
// 0x0001 (0x0001 - 0x0000)
struct MM_CharAbility_OnClickTopTab1 final
{
public:
	bool                                          Checked;                                           // 0x0000(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(MM_CharAbility_OnClickTopTab1) == 0x000001, "Wrong alignment on MM_CharAbility_OnClickTopTab1");
static_assert(sizeof(MM_CharAbility_OnClickTopTab1) == 0x000001, "Wrong size on MM_CharAbility_OnClickTopTab1");
static_assert(offsetof(MM_CharAbility_OnClickTopTab1, Checked) == 0x000000, "Member 'MM_CharAbility_OnClickTopTab1::Checked' has a wrong offset!");

// Function MirMobile.MM_CharAbility.OnClickTopTab2
// 0x0001 (0x0001 - 0x0000)
struct MM_CharAbility_OnClickTopTab2 final
{
public:
	bool                                          Checked;                                           // 0x0000(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(MM_CharAbility_OnClickTopTab2) == 0x000001, "Wrong alignment on MM_CharAbility_OnClickTopTab2");
static_assert(sizeof(MM_CharAbility_OnClickTopTab2) == 0x000001, "Wrong size on MM_CharAbility_OnClickTopTab2");
static_assert(offsetof(MM_CharAbility_OnClickTopTab2, Checked) == 0x000000, "Member 'MM_CharAbility_OnClickTopTab2::Checked' has a wrong offset!");

// Function MirMobile.MM_Hud_Chat_Popup.OnToggleMenu
// 0x0001 (0x0001 - 0x0000)
struct MM_Hud_Chat_Popup_OnToggleMenu final
{
public:
	bool                                          Checked;                                           // 0x0000(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(MM_Hud_Chat_Popup_OnToggleMenu) == 0x000001, "Wrong alignment on MM_Hud_Chat_Popup_OnToggleMenu");
static_assert(sizeof(MM_Hud_Chat_Popup_OnToggleMenu) == 0x000001, "Wrong size on MM_Hud_Chat_Popup_OnToggleMenu");
static_assert(offsetof(MM_Hud_Chat_Popup_OnToggleMenu, Checked) == 0x000000, "Member 'MM_Hud_Chat_Popup_OnToggleMenu::Checked' has a wrong offset!");

// Function MirMobile.MM_Hud_Chat_Popup.OnToggleSetting
// 0x0001 (0x0001 - 0x0000)
struct MM_Hud_Chat_Popup_OnToggleSetting final
{
public:
	bool                                          CheckState;                                        // 0x0000(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(MM_Hud_Chat_Popup_OnToggleSetting) == 0x000001, "Wrong alignment on MM_Hud_Chat_Popup_OnToggleSetting");
static_assert(sizeof(MM_Hud_Chat_Popup_OnToggleSetting) == 0x000001, "Wrong size on MM_Hud_Chat_Popup_OnToggleSetting");
static_assert(offsetof(MM_Hud_Chat_Popup_OnToggleSetting, CheckState) == 0x000000, "Member 'MM_Hud_Chat_Popup_OnToggleSetting::CheckState' has a wrong offset!");

// Function MirMobile.MM_Hud_Chat_Popup.OnToggleWhisperChat
// 0x0001 (0x0001 - 0x0000)
struct MM_Hud_Chat_Popup_OnToggleWhisperChat final
{
public:
	bool                                          Checked;                                           // 0x0000(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(MM_Hud_Chat_Popup_OnToggleWhisperChat) == 0x000001, "Wrong alignment on MM_Hud_Chat_Popup_OnToggleWhisperChat");
static_assert(sizeof(MM_Hud_Chat_Popup_OnToggleWhisperChat) == 0x000001, "Wrong size on MM_Hud_Chat_Popup_OnToggleWhisperChat");
static_assert(offsetof(MM_Hud_Chat_Popup_OnToggleWhisperChat, Checked) == 0x000000, "Member 'MM_Hud_Chat_Popup_OnToggleWhisperChat::Checked' has a wrong offset!");

// Function MirMobile.MM_CharInfo.OnClickProfile
// 0x0004 (0x0004 - 0x0000)
struct MM_CharInfo_OnClickProfile final
{
public:
	int32                                         IntProperty_0;                                     // 0x0000(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(MM_CharInfo_OnClickProfile) == 0x000004, "Wrong alignment on MM_CharInfo_OnClickProfile");
static_assert(sizeof(MM_CharInfo_OnClickProfile) == 0x000004, "Wrong size on MM_CharInfo_OnClickProfile");
static_assert(offsetof(MM_CharInfo_OnClickProfile, IntProperty_0) == 0x000000, "Member 'MM_CharInfo_OnClickProfile::IntProperty_0' has a wrong offset!");

// Function MirMobile.MM_CharInfoDetail.OnClickMain_Status
// 0x0010 (0x0010 - 0x0000)
struct MM_CharInfoDetail_OnClickMain_Status final
{
public:
	int32                                         StatusId;                                          // 0x0000(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_4[0x4];                                        // 0x0004(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class UMM_Option_Ability*                     PRefWidget;                                        // 0x0008(0x0008)(Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(MM_CharInfoDetail_OnClickMain_Status) == 0x000008, "Wrong alignment on MM_CharInfoDetail_OnClickMain_Status");
static_assert(sizeof(MM_CharInfoDetail_OnClickMain_Status) == 0x000010, "Wrong size on MM_CharInfoDetail_OnClickMain_Status");
static_assert(offsetof(MM_CharInfoDetail_OnClickMain_Status, StatusId) == 0x000000, "Member 'MM_CharInfoDetail_OnClickMain_Status::StatusId' has a wrong offset!");
static_assert(offsetof(MM_CharInfoDetail_OnClickMain_Status, PRefWidget) == 0x000008, "Member 'MM_CharInfoDetail_OnClickMain_Status::PRefWidget' has a wrong offset!");

// Function MirMobile.MM_CharInfoDetail.OnScrollEvent
// 0x0004 (0x0004 - 0x0000)
struct MM_CharInfoDetail_OnScrollEvent final
{
public:
	float                                         FOffset;                                           // 0x0000(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(MM_CharInfoDetail_OnScrollEvent) == 0x000004, "Wrong alignment on MM_CharInfoDetail_OnScrollEvent");
static_assert(sizeof(MM_CharInfoDetail_OnScrollEvent) == 0x000004, "Wrong size on MM_CharInfoDetail_OnScrollEvent");
static_assert(offsetof(MM_CharInfoDetail_OnScrollEvent, FOffset) == 0x000000, "Member 'MM_CharInfoDetail_OnScrollEvent::FOffset' has a wrong offset!");

// Function MirMobile.MM_Guild_Shop.OnChangeMakeCount
// 0x0008 (0x0008 - 0x0000)
struct MM_Guild_Shop_OnChangeMakeCount final
{
public:
	int64                                         MakeCount;                                         // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(MM_Guild_Shop_OnChangeMakeCount) == 0x000008, "Wrong alignment on MM_Guild_Shop_OnChangeMakeCount");
static_assert(sizeof(MM_Guild_Shop_OnChangeMakeCount) == 0x000008, "Wrong size on MM_Guild_Shop_OnChangeMakeCount");
static_assert(offsetof(MM_Guild_Shop_OnChangeMakeCount, MakeCount) == 0x000000, "Member 'MM_Guild_Shop_OnChangeMakeCount::MakeCount' has a wrong offset!");

// Function MirMobile.MM_CheatGameInstanceSubsystem.AuctionBookMarkFull
// 0x0004 (0x0004 - 0x0000)
struct MM_CheatGameInstanceSubsystem_AuctionBookMarkFull final
{
public:
	int32                                         InBookMarkCnt;                                     // 0x0000(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(MM_CheatGameInstanceSubsystem_AuctionBookMarkFull) == 0x000004, "Wrong alignment on MM_CheatGameInstanceSubsystem_AuctionBookMarkFull");
static_assert(sizeof(MM_CheatGameInstanceSubsystem_AuctionBookMarkFull) == 0x000004, "Wrong size on MM_CheatGameInstanceSubsystem_AuctionBookMarkFull");
static_assert(offsetof(MM_CheatGameInstanceSubsystem_AuctionBookMarkFull, InBookMarkCnt) == 0x000000, "Member 'MM_CheatGameInstanceSubsystem_AuctionBookMarkFull::InBookMarkCnt' has a wrong offset!");

// Function MirMobile.MM_CheatGameInstanceSubsystem.AutoPartyZone
// 0x0004 (0x0004 - 0x0000)
struct MM_CheatGameInstanceSubsystem_AutoPartyZone final
{
public:
	int32                                         IsOn;                                              // 0x0000(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(MM_CheatGameInstanceSubsystem_AutoPartyZone) == 0x000004, "Wrong alignment on MM_CheatGameInstanceSubsystem_AutoPartyZone");
static_assert(sizeof(MM_CheatGameInstanceSubsystem_AutoPartyZone) == 0x000004, "Wrong size on MM_CheatGameInstanceSubsystem_AutoPartyZone");
static_assert(offsetof(MM_CheatGameInstanceSubsystem_AutoPartyZone, IsOn) == 0x000000, "Member 'MM_CheatGameInstanceSubsystem_AutoPartyZone::IsOn' has a wrong offset!");

// Function MirMobile.MM_CheatGameInstanceSubsystem.AutoRebirth
// 0x0004 (0x0004 - 0x0000)
struct MM_CheatGameInstanceSubsystem_AutoRebirth final
{
public:
	int32                                         IsOn;                                              // 0x0000(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(MM_CheatGameInstanceSubsystem_AutoRebirth) == 0x000004, "Wrong alignment on MM_CheatGameInstanceSubsystem_AutoRebirth");
static_assert(sizeof(MM_CheatGameInstanceSubsystem_AutoRebirth) == 0x000004, "Wrong size on MM_CheatGameInstanceSubsystem_AutoRebirth");
static_assert(offsetof(MM_CheatGameInstanceSubsystem_AutoRebirth, IsOn) == 0x000000, "Member 'MM_CheatGameInstanceSubsystem_AutoRebirth::IsOn' has a wrong offset!");

// Function MirMobile.MM_CheatGameInstanceSubsystem.ChangePC
// 0x0004 (0x0004 - 0x0000)
struct MM_CheatGameInstanceSubsystem_ChangePC final
{
public:
	int32                                         Pcindex;                                           // 0x0000(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(MM_CheatGameInstanceSubsystem_ChangePC) == 0x000004, "Wrong alignment on MM_CheatGameInstanceSubsystem_ChangePC");
static_assert(sizeof(MM_CheatGameInstanceSubsystem_ChangePC) == 0x000004, "Wrong size on MM_CheatGameInstanceSubsystem_ChangePC");
static_assert(offsetof(MM_CheatGameInstanceSubsystem_ChangePC, Pcindex) == 0x000000, "Member 'MM_CheatGameInstanceSubsystem_ChangePC::Pcindex' has a wrong offset!");

// Function MirMobile.MM_CheatGameInstanceSubsystem.ChangePCFSM
// 0x0008 (0x0008 - 0x0000)
struct MM_CheatGameInstanceSubsystem_ChangePCFSM final
{
public:
	EFSM_TYPE                                     FSMType;                                           // 0x0000(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1[0x3];                                        // 0x0001(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         Param01;                                           // 0x0004(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(MM_CheatGameInstanceSubsystem_ChangePCFSM) == 0x000004, "Wrong alignment on MM_CheatGameInstanceSubsystem_ChangePCFSM");
static_assert(sizeof(MM_CheatGameInstanceSubsystem_ChangePCFSM) == 0x000008, "Wrong size on MM_CheatGameInstanceSubsystem_ChangePCFSM");
static_assert(offsetof(MM_CheatGameInstanceSubsystem_ChangePCFSM, FSMType) == 0x000000, "Member 'MM_CheatGameInstanceSubsystem_ChangePCFSM::FSMType' has a wrong offset!");
static_assert(offsetof(MM_CheatGameInstanceSubsystem_ChangePCFSM, Param01) == 0x000004, "Member 'MM_CheatGameInstanceSubsystem_ChangePCFSM::Param01' has a wrong offset!");

// Function MirMobile.MM_CheatGameInstanceSubsystem.ChangeServer
// 0x0010 (0x0010 - 0x0000)
struct MM_CheatGameInstanceSubsystem_ChangeServer final
{
public:
	class FString                                 ServiceVersion;                                    // 0x0000(0x0010)(Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(MM_CheatGameInstanceSubsystem_ChangeServer) == 0x000008, "Wrong alignment on MM_CheatGameInstanceSubsystem_ChangeServer");
static_assert(sizeof(MM_CheatGameInstanceSubsystem_ChangeServer) == 0x000010, "Wrong size on MM_CheatGameInstanceSubsystem_ChangeServer");
static_assert(offsetof(MM_CheatGameInstanceSubsystem_ChangeServer, ServiceVersion) == 0x000000, "Member 'MM_CheatGameInstanceSubsystem_ChangeServer::ServiceVersion' has a wrong offset!");

// Function MirMobile.MM_CheatGameInstanceSubsystem.ChangeStoreType
// 0x0010 (0x0010 - 0x0000)
struct MM_CheatGameInstanceSubsystem_ChangeStoreType final
{
public:
	class FString                                 StoreType;                                         // 0x0000(0x0010)(Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(MM_CheatGameInstanceSubsystem_ChangeStoreType) == 0x000008, "Wrong alignment on MM_CheatGameInstanceSubsystem_ChangeStoreType");
static_assert(sizeof(MM_CheatGameInstanceSubsystem_ChangeStoreType) == 0x000010, "Wrong size on MM_CheatGameInstanceSubsystem_ChangeStoreType");
static_assert(offsetof(MM_CheatGameInstanceSubsystem_ChangeStoreType, StoreType) == 0x000000, "Member 'MM_CheatGameInstanceSubsystem_ChangeStoreType::StoreType' has a wrong offset!");

// Function MirMobile.MM_CheatGameInstanceSubsystem.ChangeSyncTime
// 0x0018 (0x0018 - 0x0000)
struct MM_CheatGameInstanceSubsystem_ChangeSyncTime final
{
public:
	int32                                         Year;                                              // 0x0000(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         Mon;                                               // 0x0004(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         Day;                                               // 0x0008(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         Hour;                                              // 0x000C(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         Min;                                               // 0x0010(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         Sec;                                               // 0x0014(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(MM_CheatGameInstanceSubsystem_ChangeSyncTime) == 0x000004, "Wrong alignment on MM_CheatGameInstanceSubsystem_ChangeSyncTime");
static_assert(sizeof(MM_CheatGameInstanceSubsystem_ChangeSyncTime) == 0x000018, "Wrong size on MM_CheatGameInstanceSubsystem_ChangeSyncTime");
static_assert(offsetof(MM_CheatGameInstanceSubsystem_ChangeSyncTime, Year) == 0x000000, "Member 'MM_CheatGameInstanceSubsystem_ChangeSyncTime::Year' has a wrong offset!");
static_assert(offsetof(MM_CheatGameInstanceSubsystem_ChangeSyncTime, Mon) == 0x000004, "Member 'MM_CheatGameInstanceSubsystem_ChangeSyncTime::Mon' has a wrong offset!");
static_assert(offsetof(MM_CheatGameInstanceSubsystem_ChangeSyncTime, Day) == 0x000008, "Member 'MM_CheatGameInstanceSubsystem_ChangeSyncTime::Day' has a wrong offset!");
static_assert(offsetof(MM_CheatGameInstanceSubsystem_ChangeSyncTime, Hour) == 0x00000C, "Member 'MM_CheatGameInstanceSubsystem_ChangeSyncTime::Hour' has a wrong offset!");
static_assert(offsetof(MM_CheatGameInstanceSubsystem_ChangeSyncTime, Min) == 0x000010, "Member 'MM_CheatGameInstanceSubsystem_ChangeSyncTime::Min' has a wrong offset!");
static_assert(offsetof(MM_CheatGameInstanceSubsystem_ChangeSyncTime, Sec) == 0x000014, "Member 'MM_CheatGameInstanceSubsystem_ChangeSyncTime::Sec' has a wrong offset!");

// Function MirMobile.MM_CheatGameInstanceSubsystem.cheatmsg
// 0x0010 (0x0010 - 0x0000)
struct MM_CheatGameInstanceSubsystem_Cheatmsg final
{
public:
	class FString                                 Msg;                                               // 0x0000(0x0010)(Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(MM_CheatGameInstanceSubsystem_Cheatmsg) == 0x000008, "Wrong alignment on MM_CheatGameInstanceSubsystem_Cheatmsg");
static_assert(sizeof(MM_CheatGameInstanceSubsystem_Cheatmsg) == 0x000010, "Wrong size on MM_CheatGameInstanceSubsystem_Cheatmsg");
static_assert(offsetof(MM_CheatGameInstanceSubsystem_Cheatmsg, Msg) == 0x000000, "Member 'MM_CheatGameInstanceSubsystem_Cheatmsg::Msg' has a wrong offset!");

// Function MirMobile.MM_CheatGameInstanceSubsystem.CinematicDialogue
// 0x0004 (0x0004 - 0x0000)
struct MM_CheatGameInstanceSubsystem_CinematicDialogue final
{
public:
	int32                                         DialogueID;                                        // 0x0000(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(MM_CheatGameInstanceSubsystem_CinematicDialogue) == 0x000004, "Wrong alignment on MM_CheatGameInstanceSubsystem_CinematicDialogue");
static_assert(sizeof(MM_CheatGameInstanceSubsystem_CinematicDialogue) == 0x000004, "Wrong size on MM_CheatGameInstanceSubsystem_CinematicDialogue");
static_assert(offsetof(MM_CheatGameInstanceSubsystem_CinematicDialogue, DialogueID) == 0x000000, "Member 'MM_CheatGameInstanceSubsystem_CinematicDialogue::DialogueID' has a wrong offset!");

// Function MirMobile.MM_CheatGameInstanceSubsystem.CinematicDialogueAll
// 0x0004 (0x0004 - 0x0000)
struct MM_CheatGameInstanceSubsystem_CinematicDialogueAll final
{
public:
	int32                                         DialogueID;                                        // 0x0000(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(MM_CheatGameInstanceSubsystem_CinematicDialogueAll) == 0x000004, "Wrong alignment on MM_CheatGameInstanceSubsystem_CinematicDialogueAll");
static_assert(sizeof(MM_CheatGameInstanceSubsystem_CinematicDialogueAll) == 0x000004, "Wrong size on MM_CheatGameInstanceSubsystem_CinematicDialogueAll");
static_assert(offsetof(MM_CheatGameInstanceSubsystem_CinematicDialogueAll, DialogueID) == 0x000000, "Member 'MM_CheatGameInstanceSubsystem_CinematicDialogueAll::DialogueID' has a wrong offset!");

// Function MirMobile.MM_CheatGameInstanceSubsystem.ContentsLock
// 0x000C (0x000C - 0x0000)
struct MM_CheatGameInstanceSubsystem_ContentsLock final
{
public:
	int32                                         IContentsID;                                       // 0x0000(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         ILock;                                             // 0x0004(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         ITableID;                                          // 0x0008(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(MM_CheatGameInstanceSubsystem_ContentsLock) == 0x000004, "Wrong alignment on MM_CheatGameInstanceSubsystem_ContentsLock");
static_assert(sizeof(MM_CheatGameInstanceSubsystem_ContentsLock) == 0x00000C, "Wrong size on MM_CheatGameInstanceSubsystem_ContentsLock");
static_assert(offsetof(MM_CheatGameInstanceSubsystem_ContentsLock, IContentsID) == 0x000000, "Member 'MM_CheatGameInstanceSubsystem_ContentsLock::IContentsID' has a wrong offset!");
static_assert(offsetof(MM_CheatGameInstanceSubsystem_ContentsLock, ILock) == 0x000004, "Member 'MM_CheatGameInstanceSubsystem_ContentsLock::ILock' has a wrong offset!");
static_assert(offsetof(MM_CheatGameInstanceSubsystem_ContentsLock, ITableID) == 0x000008, "Member 'MM_CheatGameInstanceSubsystem_ContentsLock::ITableID' has a wrong offset!");

// Function MirMobile.MM_CheatGameInstanceSubsystem.DisconnectServer
// 0x0004 (0x0004 - 0x0000)
struct MM_CheatGameInstanceSubsystem_DisconnectServer final
{
public:
	int32                                         IDisconnectReason;                                 // 0x0000(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(MM_CheatGameInstanceSubsystem_DisconnectServer) == 0x000004, "Wrong alignment on MM_CheatGameInstanceSubsystem_DisconnectServer");
static_assert(sizeof(MM_CheatGameInstanceSubsystem_DisconnectServer) == 0x000004, "Wrong size on MM_CheatGameInstanceSubsystem_DisconnectServer");
static_assert(offsetof(MM_CheatGameInstanceSubsystem_DisconnectServer, IDisconnectReason) == 0x000000, "Member 'MM_CheatGameInstanceSubsystem_DisconnectServer::IDisconnectReason' has a wrong offset!");

// Function MirMobile.MM_CheatGameInstanceSubsystem.DominionAuthAll
// 0x0001 (0x0001 - 0x0000)
struct MM_CheatGameInstanceSubsystem_DominionAuthAll final
{
public:
	bool                                          bUse;                                              // 0x0000(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(MM_CheatGameInstanceSubsystem_DominionAuthAll) == 0x000001, "Wrong alignment on MM_CheatGameInstanceSubsystem_DominionAuthAll");
static_assert(sizeof(MM_CheatGameInstanceSubsystem_DominionAuthAll) == 0x000001, "Wrong size on MM_CheatGameInstanceSubsystem_DominionAuthAll");
static_assert(offsetof(MM_CheatGameInstanceSubsystem_DominionAuthAll, bUse) == 0x000000, "Member 'MM_CheatGameInstanceSubsystem_DominionAuthAll::bUse' has a wrong offset!");

// Function MirMobile.MM_CheatGameInstanceSubsystem.DrawCircleRange
// 0x0008 (0x0008 - 0x0000)
struct MM_CheatGameInstanceSubsystem_DrawCircleRange final
{
public:
	float                                         DrawRange;                                         // 0x0000(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         DrawTime;                                          // 0x0004(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(MM_CheatGameInstanceSubsystem_DrawCircleRange) == 0x000004, "Wrong alignment on MM_CheatGameInstanceSubsystem_DrawCircleRange");
static_assert(sizeof(MM_CheatGameInstanceSubsystem_DrawCircleRange) == 0x000008, "Wrong size on MM_CheatGameInstanceSubsystem_DrawCircleRange");
static_assert(offsetof(MM_CheatGameInstanceSubsystem_DrawCircleRange, DrawRange) == 0x000000, "Member 'MM_CheatGameInstanceSubsystem_DrawCircleRange::DrawRange' has a wrong offset!");
static_assert(offsetof(MM_CheatGameInstanceSubsystem_DrawCircleRange, DrawTime) == 0x000004, "Member 'MM_CheatGameInstanceSubsystem_DrawCircleRange::DrawTime' has a wrong offset!");

// Function MirMobile.MM_CheatGameInstanceSubsystem.DrawPlayerCircleRange
// 0x0004 (0x0004 - 0x0000)
struct MM_CheatGameInstanceSubsystem_DrawPlayerCircleRange final
{
public:
	float                                         DrawRange;                                         // 0x0000(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(MM_CheatGameInstanceSubsystem_DrawPlayerCircleRange) == 0x000004, "Wrong alignment on MM_CheatGameInstanceSubsystem_DrawPlayerCircleRange");
static_assert(sizeof(MM_CheatGameInstanceSubsystem_DrawPlayerCircleRange) == 0x000004, "Wrong size on MM_CheatGameInstanceSubsystem_DrawPlayerCircleRange");
static_assert(offsetof(MM_CheatGameInstanceSubsystem_DrawPlayerCircleRange, DrawRange) == 0x000000, "Member 'MM_CheatGameInstanceSubsystem_DrawPlayerCircleRange::DrawRange' has a wrong offset!");

// Function MirMobile.MM_CheatGameInstanceSubsystem.DrawPlayerRectangleRange
// 0x0004 (0x0004 - 0x0000)
struct MM_CheatGameInstanceSubsystem_DrawPlayerRectangleRange final
{
public:
	float                                         DrawRange;                                         // 0x0000(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(MM_CheatGameInstanceSubsystem_DrawPlayerRectangleRange) == 0x000004, "Wrong alignment on MM_CheatGameInstanceSubsystem_DrawPlayerRectangleRange");
static_assert(sizeof(MM_CheatGameInstanceSubsystem_DrawPlayerRectangleRange) == 0x000004, "Wrong size on MM_CheatGameInstanceSubsystem_DrawPlayerRectangleRange");
static_assert(offsetof(MM_CheatGameInstanceSubsystem_DrawPlayerRectangleRange, DrawRange) == 0x000000, "Member 'MM_CheatGameInstanceSubsystem_DrawPlayerRectangleRange::DrawRange' has a wrong offset!");

// Function MirMobile.MM_CheatGameInstanceSubsystem.DrawRectangleRange
// 0x0008 (0x0008 - 0x0000)
struct MM_CheatGameInstanceSubsystem_DrawRectangleRange final
{
public:
	float                                         DrawRange;                                         // 0x0000(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         DrawTime;                                          // 0x0004(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(MM_CheatGameInstanceSubsystem_DrawRectangleRange) == 0x000004, "Wrong alignment on MM_CheatGameInstanceSubsystem_DrawRectangleRange");
static_assert(sizeof(MM_CheatGameInstanceSubsystem_DrawRectangleRange) == 0x000008, "Wrong size on MM_CheatGameInstanceSubsystem_DrawRectangleRange");
static_assert(offsetof(MM_CheatGameInstanceSubsystem_DrawRectangleRange, DrawRange) == 0x000000, "Member 'MM_CheatGameInstanceSubsystem_DrawRectangleRange::DrawRange' has a wrong offset!");
static_assert(offsetof(MM_CheatGameInstanceSubsystem_DrawRectangleRange, DrawTime) == 0x000004, "Member 'MM_CheatGameInstanceSubsystem_DrawRectangleRange::DrawTime' has a wrong offset!");

// Function MirMobile.MM_CheatGameInstanceSubsystem.EnableBuildingStepUp
// 0x0001 (0x0001 - 0x0000)
struct MM_CheatGameInstanceSubsystem_EnableBuildingStepUp final
{
public:
	bool                                          State;                                             // 0x0000(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(MM_CheatGameInstanceSubsystem_EnableBuildingStepUp) == 0x000001, "Wrong alignment on MM_CheatGameInstanceSubsystem_EnableBuildingStepUp");
static_assert(sizeof(MM_CheatGameInstanceSubsystem_EnableBuildingStepUp) == 0x000001, "Wrong size on MM_CheatGameInstanceSubsystem_EnableBuildingStepUp");
static_assert(offsetof(MM_CheatGameInstanceSubsystem_EnableBuildingStepUp, State) == 0x000000, "Member 'MM_CheatGameInstanceSubsystem_EnableBuildingStepUp::State' has a wrong offset!");

// Function MirMobile.MM_CheatGameInstanceSubsystem.EnterMagicSquare
// 0x0004 (0x0004 - 0x0000)
struct MM_CheatGameInstanceSubsystem_EnterMagicSquare final
{
public:
	uint32                                        SquareID;                                          // 0x0000(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(MM_CheatGameInstanceSubsystem_EnterMagicSquare) == 0x000004, "Wrong alignment on MM_CheatGameInstanceSubsystem_EnterMagicSquare");
static_assert(sizeof(MM_CheatGameInstanceSubsystem_EnterMagicSquare) == 0x000004, "Wrong size on MM_CheatGameInstanceSubsystem_EnterMagicSquare");
static_assert(offsetof(MM_CheatGameInstanceSubsystem_EnterMagicSquare, SquareID) == 0x000000, "Member 'MM_CheatGameInstanceSubsystem_EnterMagicSquare::SquareID' has a wrong offset!");

// Function MirMobile.MM_CheatGameInstanceSubsystem.FakeObject
// 0x0001 (0x0001 - 0x0000)
struct MM_CheatGameInstanceSubsystem_FakeObject final
{
public:
	bool                                          Show;                                              // 0x0000(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(MM_CheatGameInstanceSubsystem_FakeObject) == 0x000001, "Wrong alignment on MM_CheatGameInstanceSubsystem_FakeObject");
static_assert(sizeof(MM_CheatGameInstanceSubsystem_FakeObject) == 0x000001, "Wrong size on MM_CheatGameInstanceSubsystem_FakeObject");
static_assert(offsetof(MM_CheatGameInstanceSubsystem_FakeObject, Show) == 0x000000, "Member 'MM_CheatGameInstanceSubsystem_FakeObject::Show' has a wrong offset!");

// Function MirMobile.MM_CheatGameInstanceSubsystem.GenBotMon
// 0x000C (0x000C - 0x0000)
struct MM_CheatGameInstanceSubsystem_GenBotMon final
{
public:
	int32                                         ID;                                                // 0x0000(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         NCount;                                            // 0x0004(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         Distance;                                          // 0x0008(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(MM_CheatGameInstanceSubsystem_GenBotMon) == 0x000004, "Wrong alignment on MM_CheatGameInstanceSubsystem_GenBotMon");
static_assert(sizeof(MM_CheatGameInstanceSubsystem_GenBotMon) == 0x00000C, "Wrong size on MM_CheatGameInstanceSubsystem_GenBotMon");
static_assert(offsetof(MM_CheatGameInstanceSubsystem_GenBotMon, ID) == 0x000000, "Member 'MM_CheatGameInstanceSubsystem_GenBotMon::ID' has a wrong offset!");
static_assert(offsetof(MM_CheatGameInstanceSubsystem_GenBotMon, NCount) == 0x000004, "Member 'MM_CheatGameInstanceSubsystem_GenBotMon::NCount' has a wrong offset!");
static_assert(offsetof(MM_CheatGameInstanceSubsystem_GenBotMon, Distance) == 0x000008, "Member 'MM_CheatGameInstanceSubsystem_GenBotMon::Distance' has a wrong offset!");

// Function MirMobile.MM_CheatGameInstanceSubsystem.GenBotNpc
// 0x0008 (0x0008 - 0x0000)
struct MM_CheatGameInstanceSubsystem_GenBotNpc final
{
public:
	int32                                         ID;                                                // 0x0000(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         Distance;                                          // 0x0004(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(MM_CheatGameInstanceSubsystem_GenBotNpc) == 0x000004, "Wrong alignment on MM_CheatGameInstanceSubsystem_GenBotNpc");
static_assert(sizeof(MM_CheatGameInstanceSubsystem_GenBotNpc) == 0x000008, "Wrong size on MM_CheatGameInstanceSubsystem_GenBotNpc");
static_assert(offsetof(MM_CheatGameInstanceSubsystem_GenBotNpc, ID) == 0x000000, "Member 'MM_CheatGameInstanceSubsystem_GenBotNpc::ID' has a wrong offset!");
static_assert(offsetof(MM_CheatGameInstanceSubsystem_GenBotNpc, Distance) == 0x000004, "Member 'MM_CheatGameInstanceSubsystem_GenBotNpc::Distance' has a wrong offset!");

// Function MirMobile.MM_CheatGameInstanceSubsystem.GenBotPC
// 0x0008 (0x0008 - 0x0000)
struct MM_CheatGameInstanceSubsystem_GenBotPC final
{
public:
	int32                                         NCount;                                            // 0x0000(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         Distance;                                          // 0x0004(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(MM_CheatGameInstanceSubsystem_GenBotPC) == 0x000004, "Wrong alignment on MM_CheatGameInstanceSubsystem_GenBotPC");
static_assert(sizeof(MM_CheatGameInstanceSubsystem_GenBotPC) == 0x000008, "Wrong size on MM_CheatGameInstanceSubsystem_GenBotPC");
static_assert(offsetof(MM_CheatGameInstanceSubsystem_GenBotPC, NCount) == 0x000000, "Member 'MM_CheatGameInstanceSubsystem_GenBotPC::NCount' has a wrong offset!");
static_assert(offsetof(MM_CheatGameInstanceSubsystem_GenBotPC, Distance) == 0x000004, "Member 'MM_CheatGameInstanceSubsystem_GenBotPC::Distance' has a wrong offset!");

// Function MirMobile.MM_CheatGameInstanceSubsystem.GenFixedNpc
// 0x0008 (0x0008 - 0x0000)
struct MM_CheatGameInstanceSubsystem_GenFixedNpc final
{
public:
	int32                                         ID;                                                // 0x0000(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         Distance;                                          // 0x0004(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(MM_CheatGameInstanceSubsystem_GenFixedNpc) == 0x000004, "Wrong alignment on MM_CheatGameInstanceSubsystem_GenFixedNpc");
static_assert(sizeof(MM_CheatGameInstanceSubsystem_GenFixedNpc) == 0x000008, "Wrong size on MM_CheatGameInstanceSubsystem_GenFixedNpc");
static_assert(offsetof(MM_CheatGameInstanceSubsystem_GenFixedNpc, ID) == 0x000000, "Member 'MM_CheatGameInstanceSubsystem_GenFixedNpc::ID' has a wrong offset!");
static_assert(offsetof(MM_CheatGameInstanceSubsystem_GenFixedNpc, Distance) == 0x000004, "Member 'MM_CheatGameInstanceSubsystem_GenFixedNpc::Distance' has a wrong offset!");

// Function MirMobile.MM_CheatGameInstanceSubsystem.GenMonster
// 0x0008 (0x0008 - 0x0000)
struct MM_CheatGameInstanceSubsystem_GenMonster final
{
public:
	int32                                         ID;                                                // 0x0000(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         Distance;                                          // 0x0004(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(MM_CheatGameInstanceSubsystem_GenMonster) == 0x000004, "Wrong alignment on MM_CheatGameInstanceSubsystem_GenMonster");
static_assert(sizeof(MM_CheatGameInstanceSubsystem_GenMonster) == 0x000008, "Wrong size on MM_CheatGameInstanceSubsystem_GenMonster");
static_assert(offsetof(MM_CheatGameInstanceSubsystem_GenMonster, ID) == 0x000000, "Member 'MM_CheatGameInstanceSubsystem_GenMonster::ID' has a wrong offset!");
static_assert(offsetof(MM_CheatGameInstanceSubsystem_GenMonster, Distance) == 0x000004, "Member 'MM_CheatGameInstanceSubsystem_GenMonster::Distance' has a wrong offset!");

// Function MirMobile.MM_CheatGameInstanceSubsystem.GenTotem
// 0x0008 (0x0008 - 0x0000)
struct MM_CheatGameInstanceSubsystem_GenTotem final
{
public:
	int32                                         ID;                                                // 0x0000(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         Distance;                                          // 0x0004(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(MM_CheatGameInstanceSubsystem_GenTotem) == 0x000004, "Wrong alignment on MM_CheatGameInstanceSubsystem_GenTotem");
static_assert(sizeof(MM_CheatGameInstanceSubsystem_GenTotem) == 0x000008, "Wrong size on MM_CheatGameInstanceSubsystem_GenTotem");
static_assert(offsetof(MM_CheatGameInstanceSubsystem_GenTotem, ID) == 0x000000, "Member 'MM_CheatGameInstanceSubsystem_GenTotem::ID' has a wrong offset!");
static_assert(offsetof(MM_CheatGameInstanceSubsystem_GenTotem, Distance) == 0x000004, "Member 'MM_CheatGameInstanceSubsystem_GenTotem::Distance' has a wrong offset!");

// Function MirMobile.MM_CheatGameInstanceSubsystem.InitialEntryTutorial
// 0x0004 (0x0004 - 0x0000)
struct MM_CheatGameInstanceSubsystem_InitialEntryTutorial final
{
public:
	int32                                         TutorialGroupId;                                   // 0x0000(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(MM_CheatGameInstanceSubsystem_InitialEntryTutorial) == 0x000004, "Wrong alignment on MM_CheatGameInstanceSubsystem_InitialEntryTutorial");
static_assert(sizeof(MM_CheatGameInstanceSubsystem_InitialEntryTutorial) == 0x000004, "Wrong size on MM_CheatGameInstanceSubsystem_InitialEntryTutorial");
static_assert(offsetof(MM_CheatGameInstanceSubsystem_InitialEntryTutorial, TutorialGroupId) == 0x000000, "Member 'MM_CheatGameInstanceSubsystem_InitialEntryTutorial::TutorialGroupId' has a wrong offset!");

// Function MirMobile.MM_CheatGameInstanceSubsystem.JPRO_CONTENTS_LOCK_TEST
// 0x0008 (0x0008 - 0x0000)
struct MM_CheatGameInstanceSubsystem_JPRO_CONTENTS_LOCK_TEST final
{
public:
	int32                                         IContentsID;                                       // 0x0000(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         ITableID;                                          // 0x0004(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(MM_CheatGameInstanceSubsystem_JPRO_CONTENTS_LOCK_TEST) == 0x000004, "Wrong alignment on MM_CheatGameInstanceSubsystem_JPRO_CONTENTS_LOCK_TEST");
static_assert(sizeof(MM_CheatGameInstanceSubsystem_JPRO_CONTENTS_LOCK_TEST) == 0x000008, "Wrong size on MM_CheatGameInstanceSubsystem_JPRO_CONTENTS_LOCK_TEST");
static_assert(offsetof(MM_CheatGameInstanceSubsystem_JPRO_CONTENTS_LOCK_TEST, IContentsID) == 0x000000, "Member 'MM_CheatGameInstanceSubsystem_JPRO_CONTENTS_LOCK_TEST::IContentsID' has a wrong offset!");
static_assert(offsetof(MM_CheatGameInstanceSubsystem_JPRO_CONTENTS_LOCK_TEST, ITableID) == 0x000004, "Member 'MM_CheatGameInstanceSubsystem_JPRO_CONTENTS_LOCK_TEST::ITableID' has a wrong offset!");

// Function MirMobile.MM_CheatGameInstanceSubsystem.lod
// 0x0004 (0x0004 - 0x0000)
struct MM_CheatGameInstanceSubsystem_Lod final
{
public:
	int32                                         LodStep;                                           // 0x0000(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(MM_CheatGameInstanceSubsystem_Lod) == 0x000004, "Wrong alignment on MM_CheatGameInstanceSubsystem_Lod");
static_assert(sizeof(MM_CheatGameInstanceSubsystem_Lod) == 0x000004, "Wrong size on MM_CheatGameInstanceSubsystem_Lod");
static_assert(offsetof(MM_CheatGameInstanceSubsystem_Lod, LodStep) == 0x000000, "Member 'MM_CheatGameInstanceSubsystem_Lod::LodStep' has a wrong offset!");

// Function MirMobile.MM_CheatGameInstanceSubsystem.MessageShowRequest
// 0x0004 (0x0004 - 0x0000)
struct MM_CheatGameInstanceSubsystem_MessageShowRequest final
{
public:
	int32                                         IMSTR_ID;                                          // 0x0000(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(MM_CheatGameInstanceSubsystem_MessageShowRequest) == 0x000004, "Wrong alignment on MM_CheatGameInstanceSubsystem_MessageShowRequest");
static_assert(sizeof(MM_CheatGameInstanceSubsystem_MessageShowRequest) == 0x000004, "Wrong size on MM_CheatGameInstanceSubsystem_MessageShowRequest");
static_assert(offsetof(MM_CheatGameInstanceSubsystem_MessageShowRequest, IMSTR_ID) == 0x000000, "Member 'MM_CheatGameInstanceSubsystem_MessageShowRequest::IMSTR_ID' has a wrong offset!");

// Function MirMobile.MM_CheatGameInstanceSubsystem.MirScript
// 0x0010 (0x0010 - 0x0000)
struct MM_CheatGameInstanceSubsystem_MirScript final
{
public:
	class FString                                 CommandScript;                                     // 0x0000(0x0010)(Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(MM_CheatGameInstanceSubsystem_MirScript) == 0x000008, "Wrong alignment on MM_CheatGameInstanceSubsystem_MirScript");
static_assert(sizeof(MM_CheatGameInstanceSubsystem_MirScript) == 0x000010, "Wrong size on MM_CheatGameInstanceSubsystem_MirScript");
static_assert(offsetof(MM_CheatGameInstanceSubsystem_MirScript, CommandScript) == 0x000000, "Member 'MM_CheatGameInstanceSubsystem_MirScript::CommandScript' has a wrong offset!");

// Function MirMobile.MM_CheatGameInstanceSubsystem.movebuff
// 0x0004 (0x0004 - 0x0000)
struct MM_CheatGameInstanceSubsystem_Movebuff final
{
public:
	int32                                         BuffValue;                                         // 0x0000(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(MM_CheatGameInstanceSubsystem_Movebuff) == 0x000004, "Wrong alignment on MM_CheatGameInstanceSubsystem_Movebuff");
static_assert(sizeof(MM_CheatGameInstanceSubsystem_Movebuff) == 0x000004, "Wrong size on MM_CheatGameInstanceSubsystem_Movebuff");
static_assert(offsetof(MM_CheatGameInstanceSubsystem_Movebuff, BuffValue) == 0x000000, "Member 'MM_CheatGameInstanceSubsystem_Movebuff::BuffValue' has a wrong offset!");

// Function MirMobile.MM_CheatGameInstanceSubsystem.MOVIEPLAY
// 0x0004 (0x0004 - 0x0000)
struct MM_CheatGameInstanceSubsystem_MOVIEPLAY final
{
public:
	int32                                         ID;                                                // 0x0000(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(MM_CheatGameInstanceSubsystem_MOVIEPLAY) == 0x000004, "Wrong alignment on MM_CheatGameInstanceSubsystem_MOVIEPLAY");
static_assert(sizeof(MM_CheatGameInstanceSubsystem_MOVIEPLAY) == 0x000004, "Wrong size on MM_CheatGameInstanceSubsystem_MOVIEPLAY");
static_assert(offsetof(MM_CheatGameInstanceSubsystem_MOVIEPLAY, ID) == 0x000000, "Member 'MM_CheatGameInstanceSubsystem_MOVIEPLAY::ID' has a wrong offset!");

// Function MirMobile.MM_CheatGameInstanceSubsystem.OnAutoClassPhase
// 0x0004 (0x0004 - 0x0000)
struct MM_CheatGameInstanceSubsystem_OnAutoClassPhase final
{
public:
	int32                                         ITime;                                             // 0x0000(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(MM_CheatGameInstanceSubsystem_OnAutoClassPhase) == 0x000004, "Wrong alignment on MM_CheatGameInstanceSubsystem_OnAutoClassPhase");
static_assert(sizeof(MM_CheatGameInstanceSubsystem_OnAutoClassPhase) == 0x000004, "Wrong size on MM_CheatGameInstanceSubsystem_OnAutoClassPhase");
static_assert(offsetof(MM_CheatGameInstanceSubsystem_OnAutoClassPhase, ITime) == 0x000000, "Member 'MM_CheatGameInstanceSubsystem_OnAutoClassPhase::ITime' has a wrong offset!");

// Function MirMobile.MM_CheatGameInstanceSubsystem.OnLapidifiCation
// 0x0008 (0x0008 - 0x0000)
struct MM_CheatGameInstanceSubsystem_OnLapidifiCation final
{
public:
	int32                                         MaterialType;                                      // 0x0000(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         Time;                                              // 0x0004(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(MM_CheatGameInstanceSubsystem_OnLapidifiCation) == 0x000004, "Wrong alignment on MM_CheatGameInstanceSubsystem_OnLapidifiCation");
static_assert(sizeof(MM_CheatGameInstanceSubsystem_OnLapidifiCation) == 0x000008, "Wrong size on MM_CheatGameInstanceSubsystem_OnLapidifiCation");
static_assert(offsetof(MM_CheatGameInstanceSubsystem_OnLapidifiCation, MaterialType) == 0x000000, "Member 'MM_CheatGameInstanceSubsystem_OnLapidifiCation::MaterialType' has a wrong offset!");
static_assert(offsetof(MM_CheatGameInstanceSubsystem_OnLapidifiCation, Time) == 0x000004, "Member 'MM_CheatGameInstanceSubsystem_OnLapidifiCation::Time' has a wrong offset!");

// Function MirMobile.MM_CheatGameInstanceSubsystem.onskill
// 0x0004 (0x0004 - 0x0000)
struct MM_CheatGameInstanceSubsystem_Onskill final
{
public:
	int32                                         SkillId;                                           // 0x0000(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(MM_CheatGameInstanceSubsystem_Onskill) == 0x000004, "Wrong alignment on MM_CheatGameInstanceSubsystem_Onskill");
static_assert(sizeof(MM_CheatGameInstanceSubsystem_Onskill) == 0x000004, "Wrong size on MM_CheatGameInstanceSubsystem_Onskill");
static_assert(offsetof(MM_CheatGameInstanceSubsystem_Onskill, SkillId) == 0x000000, "Member 'MM_CheatGameInstanceSubsystem_Onskill::SkillId' has a wrong offset!");

// Function MirMobile.MM_CheatGameInstanceSubsystem.OpenWebURL
// 0x0010 (0x0010 - 0x0000)
struct MM_CheatGameInstanceSubsystem_OpenWebURL final
{
public:
	class FString                                 StrURL;                                            // 0x0000(0x0010)(Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(MM_CheatGameInstanceSubsystem_OpenWebURL) == 0x000008, "Wrong alignment on MM_CheatGameInstanceSubsystem_OpenWebURL");
static_assert(sizeof(MM_CheatGameInstanceSubsystem_OpenWebURL) == 0x000010, "Wrong size on MM_CheatGameInstanceSubsystem_OpenWebURL");
static_assert(offsetof(MM_CheatGameInstanceSubsystem_OpenWebURL, StrURL) == 0x000000, "Member 'MM_CheatGameInstanceSubsystem_OpenWebURL::StrURL' has a wrong offset!");

// Function MirMobile.MM_CheatGameInstanceSubsystem.PauseAI
// 0x0004 (0x0004 - 0x0000)
struct MM_CheatGameInstanceSubsystem_PauseAI final
{
public:
	int32                                         ID;                                                // 0x0000(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(MM_CheatGameInstanceSubsystem_PauseAI) == 0x000004, "Wrong alignment on MM_CheatGameInstanceSubsystem_PauseAI");
static_assert(sizeof(MM_CheatGameInstanceSubsystem_PauseAI) == 0x000004, "Wrong size on MM_CheatGameInstanceSubsystem_PauseAI");
static_assert(offsetof(MM_CheatGameInstanceSubsystem_PauseAI, ID) == 0x000000, "Member 'MM_CheatGameInstanceSubsystem_PauseAI::ID' has a wrong offset!");

// Function MirMobile.MM_CheatGameInstanceSubsystem.PCTeleport
// 0x000C (0x000C - 0x0000)
struct MM_CheatGameInstanceSubsystem_PCTeleport final
{
public:
	float                                         X;                                                 // 0x0000(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         Y;                                                 // 0x0004(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         Z;                                                 // 0x0008(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(MM_CheatGameInstanceSubsystem_PCTeleport) == 0x000004, "Wrong alignment on MM_CheatGameInstanceSubsystem_PCTeleport");
static_assert(sizeof(MM_CheatGameInstanceSubsystem_PCTeleport) == 0x00000C, "Wrong size on MM_CheatGameInstanceSubsystem_PCTeleport");
static_assert(offsetof(MM_CheatGameInstanceSubsystem_PCTeleport, X) == 0x000000, "Member 'MM_CheatGameInstanceSubsystem_PCTeleport::X' has a wrong offset!");
static_assert(offsetof(MM_CheatGameInstanceSubsystem_PCTeleport, Y) == 0x000004, "Member 'MM_CheatGameInstanceSubsystem_PCTeleport::Y' has a wrong offset!");
static_assert(offsetof(MM_CheatGameInstanceSubsystem_PCTeleport, Z) == 0x000008, "Member 'MM_CheatGameInstanceSubsystem_PCTeleport::Z' has a wrong offset!");

// Function MirMobile.MM_CheatGameInstanceSubsystem.PhaseGod
// 0x0001 (0x0001 - 0x0000)
struct MM_CheatGameInstanceSubsystem_PhaseGod final
{
public:
	bool                                          bGod;                                              // 0x0000(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(MM_CheatGameInstanceSubsystem_PhaseGod) == 0x000001, "Wrong alignment on MM_CheatGameInstanceSubsystem_PhaseGod");
static_assert(sizeof(MM_CheatGameInstanceSubsystem_PhaseGod) == 0x000001, "Wrong size on MM_CheatGameInstanceSubsystem_PhaseGod");
static_assert(offsetof(MM_CheatGameInstanceSubsystem_PhaseGod, bGod) == 0x000000, "Member 'MM_CheatGameInstanceSubsystem_PhaseGod::bGod' has a wrong offset!");

// Function MirMobile.MM_CheatGameInstanceSubsystem.PlayCutscene
// 0x0004 (0x0004 - 0x0000)
struct MM_CheatGameInstanceSubsystem_PlayCutscene final
{
public:
	int32                                         NameId;                                            // 0x0000(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(MM_CheatGameInstanceSubsystem_PlayCutscene) == 0x000004, "Wrong alignment on MM_CheatGameInstanceSubsystem_PlayCutscene");
static_assert(sizeof(MM_CheatGameInstanceSubsystem_PlayCutscene) == 0x000004, "Wrong size on MM_CheatGameInstanceSubsystem_PlayCutscene");
static_assert(offsetof(MM_CheatGameInstanceSubsystem_PlayCutscene, NameId) == 0x000000, "Member 'MM_CheatGameInstanceSubsystem_PlayCutscene::NameId' has a wrong offset!");

// Function MirMobile.MM_CheatGameInstanceSubsystem.questend
// 0x0004 (0x0004 - 0x0000)
struct MM_CheatGameInstanceSubsystem_Questend final
{
public:
	int32                                         ID;                                                // 0x0000(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(MM_CheatGameInstanceSubsystem_Questend) == 0x000004, "Wrong alignment on MM_CheatGameInstanceSubsystem_Questend");
static_assert(sizeof(MM_CheatGameInstanceSubsystem_Questend) == 0x000004, "Wrong size on MM_CheatGameInstanceSubsystem_Questend");
static_assert(offsetof(MM_CheatGameInstanceSubsystem_Questend, ID) == 0x000000, "Member 'MM_CheatGameInstanceSubsystem_Questend::ID' has a wrong offset!");

// Function MirMobile.MM_CheatGameInstanceSubsystem.queststart
// 0x0004 (0x0004 - 0x0000)
struct MM_CheatGameInstanceSubsystem_Queststart final
{
public:
	int32                                         ID;                                                // 0x0000(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(MM_CheatGameInstanceSubsystem_Queststart) == 0x000004, "Wrong alignment on MM_CheatGameInstanceSubsystem_Queststart");
static_assert(sizeof(MM_CheatGameInstanceSubsystem_Queststart) == 0x000004, "Wrong size on MM_CheatGameInstanceSubsystem_Queststart");
static_assert(offsetof(MM_CheatGameInstanceSubsystem_Queststart, ID) == 0x000000, "Member 'MM_CheatGameInstanceSubsystem_Queststart::ID' has a wrong offset!");

// Function MirMobile.MM_CheatGameInstanceSubsystem.RelationScript
// 0x0010 (0x0010 - 0x0000)
struct MM_CheatGameInstanceSubsystem_RelationScript final
{
public:
	class FString                                 CommandScript;                                     // 0x0000(0x0010)(Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(MM_CheatGameInstanceSubsystem_RelationScript) == 0x000008, "Wrong alignment on MM_CheatGameInstanceSubsystem_RelationScript");
static_assert(sizeof(MM_CheatGameInstanceSubsystem_RelationScript) == 0x000010, "Wrong size on MM_CheatGameInstanceSubsystem_RelationScript");
static_assert(offsetof(MM_CheatGameInstanceSubsystem_RelationScript, CommandScript) == 0x000000, "Member 'MM_CheatGameInstanceSubsystem_RelationScript::CommandScript' has a wrong offset!");

// Function MirMobile.MM_CheatGameInstanceSubsystem.ResumeAI
// 0x0004 (0x0004 - 0x0000)
struct MM_CheatGameInstanceSubsystem_ResumeAI final
{
public:
	int32                                         ID;                                                // 0x0000(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(MM_CheatGameInstanceSubsystem_ResumeAI) == 0x000004, "Wrong alignment on MM_CheatGameInstanceSubsystem_ResumeAI");
static_assert(sizeof(MM_CheatGameInstanceSubsystem_ResumeAI) == 0x000004, "Wrong size on MM_CheatGameInstanceSubsystem_ResumeAI");
static_assert(offsetof(MM_CheatGameInstanceSubsystem_ResumeAI, ID) == 0x000000, "Member 'MM_CheatGameInstanceSubsystem_ResumeAI::ID' has a wrong offset!");

// Function MirMobile.MM_CheatGameInstanceSubsystem.RotChar
// 0x0008 (0x0008 - 0x0000)
struct MM_CheatGameInstanceSubsystem_RotChar final
{
public:
	int32                                         ID;                                                // 0x0000(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         NAngle;                                            // 0x0004(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(MM_CheatGameInstanceSubsystem_RotChar) == 0x000004, "Wrong alignment on MM_CheatGameInstanceSubsystem_RotChar");
static_assert(sizeof(MM_CheatGameInstanceSubsystem_RotChar) == 0x000008, "Wrong size on MM_CheatGameInstanceSubsystem_RotChar");
static_assert(offsetof(MM_CheatGameInstanceSubsystem_RotChar, ID) == 0x000000, "Member 'MM_CheatGameInstanceSubsystem_RotChar::ID' has a wrong offset!");
static_assert(offsetof(MM_CheatGameInstanceSubsystem_RotChar, NAngle) == 0x000004, "Member 'MM_CheatGameInstanceSubsystem_RotChar::NAngle' has a wrong offset!");

// Function MirMobile.MM_CheatGameInstanceSubsystem.SetAssassin
// 0x0010 (0x0010 - 0x0000)
struct MM_CheatGameInstanceSubsystem_SetAssassin final
{
public:
	uint64                                        Uid;                                               // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bOn;                                               // 0x0008(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_9[0x7];                                        // 0x0009(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(MM_CheatGameInstanceSubsystem_SetAssassin) == 0x000008, "Wrong alignment on MM_CheatGameInstanceSubsystem_SetAssassin");
static_assert(sizeof(MM_CheatGameInstanceSubsystem_SetAssassin) == 0x000010, "Wrong size on MM_CheatGameInstanceSubsystem_SetAssassin");
static_assert(offsetof(MM_CheatGameInstanceSubsystem_SetAssassin, Uid) == 0x000000, "Member 'MM_CheatGameInstanceSubsystem_SetAssassin::Uid' has a wrong offset!");
static_assert(offsetof(MM_CheatGameInstanceSubsystem_SetAssassin, bOn) == 0x000008, "Member 'MM_CheatGameInstanceSubsystem_SetAssassin::bOn' has a wrong offset!");

// Function MirMobile.MM_CheatGameInstanceSubsystem.SetAttackIndex
// 0x000C (0x000C - 0x0000)
struct MM_CheatGameInstanceSubsystem_SetAttackIndex final
{
public:
	int32                                         Idx;                                               // 0x0000(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         ID;                                                // 0x0004(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bLongAttack;                                       // 0x0008(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_9[0x3];                                        // 0x0009(0x0003)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(MM_CheatGameInstanceSubsystem_SetAttackIndex) == 0x000004, "Wrong alignment on MM_CheatGameInstanceSubsystem_SetAttackIndex");
static_assert(sizeof(MM_CheatGameInstanceSubsystem_SetAttackIndex) == 0x00000C, "Wrong size on MM_CheatGameInstanceSubsystem_SetAttackIndex");
static_assert(offsetof(MM_CheatGameInstanceSubsystem_SetAttackIndex, Idx) == 0x000000, "Member 'MM_CheatGameInstanceSubsystem_SetAttackIndex::Idx' has a wrong offset!");
static_assert(offsetof(MM_CheatGameInstanceSubsystem_SetAttackIndex, ID) == 0x000004, "Member 'MM_CheatGameInstanceSubsystem_SetAttackIndex::ID' has a wrong offset!");
static_assert(offsetof(MM_CheatGameInstanceSubsystem_SetAttackIndex, bLongAttack) == 0x000008, "Member 'MM_CheatGameInstanceSubsystem_SetAttackIndex::bLongAttack' has a wrong offset!");

// Function MirMobile.MM_CheatGameInstanceSubsystem.SetAttackOnce
// 0x0004 (0x0004 - 0x0000)
struct MM_CheatGameInstanceSubsystem_SetAttackOnce final
{
public:
	int32                                         Mode;                                              // 0x0000(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(MM_CheatGameInstanceSubsystem_SetAttackOnce) == 0x000004, "Wrong alignment on MM_CheatGameInstanceSubsystem_SetAttackOnce");
static_assert(sizeof(MM_CheatGameInstanceSubsystem_SetAttackOnce) == 0x000004, "Wrong size on MM_CheatGameInstanceSubsystem_SetAttackOnce");
static_assert(offsetof(MM_CheatGameInstanceSubsystem_SetAttackOnce, Mode) == 0x000000, "Member 'MM_CheatGameInstanceSubsystem_SetAttackOnce::Mode' has a wrong offset!");

// Function MirMobile.MM_CheatGameInstanceSubsystem.SetCustomSafePadding
// 0x0010 (0x0010 - 0x0000)
struct MM_CheatGameInstanceSubsystem_SetCustomSafePadding final
{
public:
	class FString                                 InData;                                            // 0x0000(0x0010)(Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(MM_CheatGameInstanceSubsystem_SetCustomSafePadding) == 0x000008, "Wrong alignment on MM_CheatGameInstanceSubsystem_SetCustomSafePadding");
static_assert(sizeof(MM_CheatGameInstanceSubsystem_SetCustomSafePadding) == 0x000010, "Wrong size on MM_CheatGameInstanceSubsystem_SetCustomSafePadding");
static_assert(offsetof(MM_CheatGameInstanceSubsystem_SetCustomSafePadding, InData) == 0x000000, "Member 'MM_CheatGameInstanceSubsystem_SetCustomSafePadding::InData' has a wrong offset!");

// Function MirMobile.MM_CheatGameInstanceSubsystem.SetHideFlag
// 0x0010 (0x0010 - 0x0000)
struct MM_CheatGameInstanceSubsystem_SetHideFlag final
{
public:
	class FString                                 StrHideType;                                       // 0x0000(0x0010)(Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(MM_CheatGameInstanceSubsystem_SetHideFlag) == 0x000008, "Wrong alignment on MM_CheatGameInstanceSubsystem_SetHideFlag");
static_assert(sizeof(MM_CheatGameInstanceSubsystem_SetHideFlag) == 0x000010, "Wrong size on MM_CheatGameInstanceSubsystem_SetHideFlag");
static_assert(offsetof(MM_CheatGameInstanceSubsystem_SetHideFlag, StrHideType) == 0x000000, "Member 'MM_CheatGameInstanceSubsystem_SetHideFlag::StrHideType' has a wrong offset!");

// Function MirMobile.MM_CheatGameInstanceSubsystem.SetPassiveCoolTime
// 0x0004 (0x0004 - 0x0000)
struct MM_CheatGameInstanceSubsystem_SetPassiveCoolTime final
{
public:
	int32                                         Sec;                                               // 0x0000(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(MM_CheatGameInstanceSubsystem_SetPassiveCoolTime) == 0x000004, "Wrong alignment on MM_CheatGameInstanceSubsystem_SetPassiveCoolTime");
static_assert(sizeof(MM_CheatGameInstanceSubsystem_SetPassiveCoolTime) == 0x000004, "Wrong size on MM_CheatGameInstanceSubsystem_SetPassiveCoolTime");
static_assert(offsetof(MM_CheatGameInstanceSubsystem_SetPassiveCoolTime, Sec) == 0x000000, "Member 'MM_CheatGameInstanceSubsystem_SetPassiveCoolTime::Sec' has a wrong offset!");

// Function MirMobile.MM_CheatGameInstanceSubsystem.SetQuestLog
// 0x0001 (0x0001 - 0x0000)
struct MM_CheatGameInstanceSubsystem_SetQuestLog final
{
public:
	bool                                          State;                                             // 0x0000(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(MM_CheatGameInstanceSubsystem_SetQuestLog) == 0x000001, "Wrong alignment on MM_CheatGameInstanceSubsystem_SetQuestLog");
static_assert(sizeof(MM_CheatGameInstanceSubsystem_SetQuestLog) == 0x000001, "Wrong size on MM_CheatGameInstanceSubsystem_SetQuestLog");
static_assert(offsetof(MM_CheatGameInstanceSubsystem_SetQuestLog, State) == 0x000000, "Member 'MM_CheatGameInstanceSubsystem_SetQuestLog::State' has a wrong offset!");

// Function MirMobile.MM_CheatGameInstanceSubsystem.SetWSEventListSkip
// 0x0001 (0x0001 - 0x0000)
struct MM_CheatGameInstanceSubsystem_SetWSEventListSkip final
{
public:
	bool                                          bUse;                                              // 0x0000(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(MM_CheatGameInstanceSubsystem_SetWSEventListSkip) == 0x000001, "Wrong alignment on MM_CheatGameInstanceSubsystem_SetWSEventListSkip");
static_assert(sizeof(MM_CheatGameInstanceSubsystem_SetWSEventListSkip) == 0x000001, "Wrong size on MM_CheatGameInstanceSubsystem_SetWSEventListSkip");
static_assert(offsetof(MM_CheatGameInstanceSubsystem_SetWSEventListSkip, bUse) == 0x000000, "Member 'MM_CheatGameInstanceSubsystem_SetWSEventListSkip::bUse' has a wrong offset!");

// Function MirMobile.MM_CheatGameInstanceSubsystem.shadow
// 0x0004 (0x0004 - 0x0000)
struct MM_CheatGameInstanceSubsystem_Shadow final
{
public:
	int32                                         ShadowStep;                                        // 0x0000(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(MM_CheatGameInstanceSubsystem_Shadow) == 0x000004, "Wrong alignment on MM_CheatGameInstanceSubsystem_Shadow");
static_assert(sizeof(MM_CheatGameInstanceSubsystem_Shadow) == 0x000004, "Wrong size on MM_CheatGameInstanceSubsystem_Shadow");
static_assert(offsetof(MM_CheatGameInstanceSubsystem_Shadow, ShadowStep) == 0x000000, "Member 'MM_CheatGameInstanceSubsystem_Shadow::ShadowStep' has a wrong offset!");

// Function MirMobile.MM_CheatGameInstanceSubsystem.ShowAllDungeon
// 0x0004 (0x0004 - 0x0000)
struct MM_CheatGameInstanceSubsystem_ShowAllDungeon final
{
public:
	int32                                         Show;                                              // 0x0000(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(MM_CheatGameInstanceSubsystem_ShowAllDungeon) == 0x000004, "Wrong alignment on MM_CheatGameInstanceSubsystem_ShowAllDungeon");
static_assert(sizeof(MM_CheatGameInstanceSubsystem_ShowAllDungeon) == 0x000004, "Wrong size on MM_CheatGameInstanceSubsystem_ShowAllDungeon");
static_assert(offsetof(MM_CheatGameInstanceSubsystem_ShowAllDungeon, Show) == 0x000000, "Member 'MM_CheatGameInstanceSubsystem_ShowAllDungeon::Show' has a wrong offset!");

// Function MirMobile.MM_CheatGameInstanceSubsystem.showattackrange
// 0x0004 (0x0004 - 0x0000)
struct MM_CheatGameInstanceSubsystem_Showattackrange final
{
public:
	int32                                         ID;                                                // 0x0000(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(MM_CheatGameInstanceSubsystem_Showattackrange) == 0x000004, "Wrong alignment on MM_CheatGameInstanceSubsystem_Showattackrange");
static_assert(sizeof(MM_CheatGameInstanceSubsystem_Showattackrange) == 0x000004, "Wrong size on MM_CheatGameInstanceSubsystem_Showattackrange");
static_assert(offsetof(MM_CheatGameInstanceSubsystem_Showattackrange, ID) == 0x000000, "Member 'MM_CheatGameInstanceSubsystem_Showattackrange::ID' has a wrong offset!");

// Function MirMobile.MM_CheatGameInstanceSubsystem.showDamageInfo
// 0x0004 (0x0004 - 0x0000)
struct MM_CheatGameInstanceSubsystem_ShowDamageInfo final
{
public:
	int32                                         MonsterTID;                                        // 0x0000(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(MM_CheatGameInstanceSubsystem_ShowDamageInfo) == 0x000004, "Wrong alignment on MM_CheatGameInstanceSubsystem_ShowDamageInfo");
static_assert(sizeof(MM_CheatGameInstanceSubsystem_ShowDamageInfo) == 0x000004, "Wrong size on MM_CheatGameInstanceSubsystem_ShowDamageInfo");
static_assert(offsetof(MM_CheatGameInstanceSubsystem_ShowDamageInfo, MonsterTID) == 0x000000, "Member 'MM_CheatGameInstanceSubsystem_ShowDamageInfo::MonsterTID' has a wrong offset!");

// Function MirMobile.MM_CheatGameInstanceSubsystem.ShowSmallTalkWidget
// 0x0004 (0x0004 - 0x0000)
struct MM_CheatGameInstanceSubsystem_ShowSmallTalkWidget final
{
public:
	int32                                         IDialogueID;                                       // 0x0000(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(MM_CheatGameInstanceSubsystem_ShowSmallTalkWidget) == 0x000004, "Wrong alignment on MM_CheatGameInstanceSubsystem_ShowSmallTalkWidget");
static_assert(sizeof(MM_CheatGameInstanceSubsystem_ShowSmallTalkWidget) == 0x000004, "Wrong size on MM_CheatGameInstanceSubsystem_ShowSmallTalkWidget");
static_assert(offsetof(MM_CheatGameInstanceSubsystem_ShowSmallTalkWidget, IDialogueID) == 0x000000, "Member 'MM_CheatGameInstanceSubsystem_ShowSmallTalkWidget::IDialogueID' has a wrong offset!");

// Function MirMobile.MM_CheatGameInstanceSubsystem.ShowStat
// 0x0004 (0x0004 - 0x0000)
struct MM_CheatGameInstanceSubsystem_ShowStat final
{
public:
	int32                                         Uid;                                               // 0x0000(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(MM_CheatGameInstanceSubsystem_ShowStat) == 0x000004, "Wrong alignment on MM_CheatGameInstanceSubsystem_ShowStat");
static_assert(sizeof(MM_CheatGameInstanceSubsystem_ShowStat) == 0x000004, "Wrong size on MM_CheatGameInstanceSubsystem_ShowStat");
static_assert(offsetof(MM_CheatGameInstanceSubsystem_ShowStat, Uid) == 0x000000, "Member 'MM_CheatGameInstanceSubsystem_ShowStat::Uid' has a wrong offset!");

// Function MirMobile.MM_CheatGameInstanceSubsystem.SiegeObserver
// 0x0001 (0x0001 - 0x0000)
struct MM_CheatGameInstanceSubsystem_SiegeObserver final
{
public:
	bool                                          IsOn;                                              // 0x0000(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(MM_CheatGameInstanceSubsystem_SiegeObserver) == 0x000001, "Wrong alignment on MM_CheatGameInstanceSubsystem_SiegeObserver");
static_assert(sizeof(MM_CheatGameInstanceSubsystem_SiegeObserver) == 0x000001, "Wrong size on MM_CheatGameInstanceSubsystem_SiegeObserver");
static_assert(offsetof(MM_CheatGameInstanceSubsystem_SiegeObserver, IsOn) == 0x000000, "Member 'MM_CheatGameInstanceSubsystem_SiegeObserver::IsOn' has a wrong offset!");

// Function MirMobile.MM_CheatGameInstanceSubsystem.StrongPointNotice
// 0x0008 (0x0008 - 0x0000)
struct MM_CheatGameInstanceSubsystem_StrongPointNotice final
{
public:
	int32                                         StrongPointTID;                                    // 0x0000(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         NoticeType;                                        // 0x0004(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(MM_CheatGameInstanceSubsystem_StrongPointNotice) == 0x000004, "Wrong alignment on MM_CheatGameInstanceSubsystem_StrongPointNotice");
static_assert(sizeof(MM_CheatGameInstanceSubsystem_StrongPointNotice) == 0x000008, "Wrong size on MM_CheatGameInstanceSubsystem_StrongPointNotice");
static_assert(offsetof(MM_CheatGameInstanceSubsystem_StrongPointNotice, StrongPointTID) == 0x000000, "Member 'MM_CheatGameInstanceSubsystem_StrongPointNotice::StrongPointTID' has a wrong offset!");
static_assert(offsetof(MM_CheatGameInstanceSubsystem_StrongPointNotice, NoticeType) == 0x000004, "Member 'MM_CheatGameInstanceSubsystem_StrongPointNotice::NoticeType' has a wrong offset!");

// Function MirMobile.MM_CheatGameInstanceSubsystem.StunChar
// 0x0008 (0x0008 - 0x0000)
struct MM_CheatGameInstanceSubsystem_StunChar final
{
public:
	int32                                         ID;                                                // 0x0000(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         Time;                                              // 0x0004(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(MM_CheatGameInstanceSubsystem_StunChar) == 0x000004, "Wrong alignment on MM_CheatGameInstanceSubsystem_StunChar");
static_assert(sizeof(MM_CheatGameInstanceSubsystem_StunChar) == 0x000008, "Wrong size on MM_CheatGameInstanceSubsystem_StunChar");
static_assert(offsetof(MM_CheatGameInstanceSubsystem_StunChar, ID) == 0x000000, "Member 'MM_CheatGameInstanceSubsystem_StunChar::ID' has a wrong offset!");
static_assert(offsetof(MM_CheatGameInstanceSubsystem_StunChar, Time) == 0x000004, "Member 'MM_CheatGameInstanceSubsystem_StunChar::Time' has a wrong offset!");

// Function MirMobile.MM_CheatGameInstanceSubsystem.test_gm_msg
// 0x0018 (0x0018 - 0x0000)
struct MM_CheatGameInstanceSubsystem_Test_gm_msg final
{
public:
	class FString                                 StrMsg;                                            // 0x0000(0x0010)(Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         IDuration;                                         // 0x0010(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_14[0x4];                                       // 0x0014(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(MM_CheatGameInstanceSubsystem_Test_gm_msg) == 0x000008, "Wrong alignment on MM_CheatGameInstanceSubsystem_Test_gm_msg");
static_assert(sizeof(MM_CheatGameInstanceSubsystem_Test_gm_msg) == 0x000018, "Wrong size on MM_CheatGameInstanceSubsystem_Test_gm_msg");
static_assert(offsetof(MM_CheatGameInstanceSubsystem_Test_gm_msg, StrMsg) == 0x000000, "Member 'MM_CheatGameInstanceSubsystem_Test_gm_msg::StrMsg' has a wrong offset!");
static_assert(offsetof(MM_CheatGameInstanceSubsystem_Test_gm_msg, IDuration) == 0x000010, "Member 'MM_CheatGameInstanceSubsystem_Test_gm_msg::IDuration' has a wrong offset!");

// Function MirMobile.MM_CheatGameInstanceSubsystem.TestInput
// 0x0004 (0x0004 - 0x0000)
struct MM_CheatGameInstanceSubsystem_TestInput final
{
public:
	int32                                         Index_;                                            // 0x0000(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(MM_CheatGameInstanceSubsystem_TestInput) == 0x000004, "Wrong alignment on MM_CheatGameInstanceSubsystem_TestInput");
static_assert(sizeof(MM_CheatGameInstanceSubsystem_TestInput) == 0x000004, "Wrong size on MM_CheatGameInstanceSubsystem_TestInput");
static_assert(offsetof(MM_CheatGameInstanceSubsystem_TestInput, Index_) == 0x000000, "Member 'MM_CheatGameInstanceSubsystem_TestInput::Index_' has a wrong offset!");

// Function MirMobile.MM_CheatGameInstanceSubsystem.TestSend
// 0x0004 (0x0004 - 0x0000)
struct MM_CheatGameInstanceSubsystem_TestSend final
{
public:
	int32                                         Param;                                             // 0x0000(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(MM_CheatGameInstanceSubsystem_TestSend) == 0x000004, "Wrong alignment on MM_CheatGameInstanceSubsystem_TestSend");
static_assert(sizeof(MM_CheatGameInstanceSubsystem_TestSend) == 0x000004, "Wrong size on MM_CheatGameInstanceSubsystem_TestSend");
static_assert(offsetof(MM_CheatGameInstanceSubsystem_TestSend, Param) == 0x000000, "Member 'MM_CheatGameInstanceSubsystem_TestSend::Param' has a wrong offset!");

// Function MirMobile.MM_CheatGameInstanceSubsystem.TestTutorial
// 0x0004 (0x0004 - 0x0000)
struct MM_CheatGameInstanceSubsystem_TestTutorial final
{
public:
	int32                                         TutorialGroupId;                                   // 0x0000(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(MM_CheatGameInstanceSubsystem_TestTutorial) == 0x000004, "Wrong alignment on MM_CheatGameInstanceSubsystem_TestTutorial");
static_assert(sizeof(MM_CheatGameInstanceSubsystem_TestTutorial) == 0x000004, "Wrong size on MM_CheatGameInstanceSubsystem_TestTutorial");
static_assert(offsetof(MM_CheatGameInstanceSubsystem_TestTutorial, TutorialGroupId) == 0x000000, "Member 'MM_CheatGameInstanceSubsystem_TestTutorial::TutorialGroupId' has a wrong offset!");

// Function MirMobile.MM_CheatGameInstanceSubsystem.TestWarping
// 0x0010 (0x0010 - 0x0000)
struct MM_CheatGameInstanceSubsystem_TestWarping final
{
public:
	int32                                         Stage1;                                            // 0x0000(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         Stage2;                                            // 0x0004(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         Stage3;                                            // 0x0008(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         Stage4;                                            // 0x000C(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(MM_CheatGameInstanceSubsystem_TestWarping) == 0x000004, "Wrong alignment on MM_CheatGameInstanceSubsystem_TestWarping");
static_assert(sizeof(MM_CheatGameInstanceSubsystem_TestWarping) == 0x000010, "Wrong size on MM_CheatGameInstanceSubsystem_TestWarping");
static_assert(offsetof(MM_CheatGameInstanceSubsystem_TestWarping, Stage1) == 0x000000, "Member 'MM_CheatGameInstanceSubsystem_TestWarping::Stage1' has a wrong offset!");
static_assert(offsetof(MM_CheatGameInstanceSubsystem_TestWarping, Stage2) == 0x000004, "Member 'MM_CheatGameInstanceSubsystem_TestWarping::Stage2' has a wrong offset!");
static_assert(offsetof(MM_CheatGameInstanceSubsystem_TestWarping, Stage3) == 0x000008, "Member 'MM_CheatGameInstanceSubsystem_TestWarping::Stage3' has a wrong offset!");
static_assert(offsetof(MM_CheatGameInstanceSubsystem_TestWarping, Stage4) == 0x00000C, "Member 'MM_CheatGameInstanceSubsystem_TestWarping::Stage4' has a wrong offset!");

// Function MirMobile.MM_CheatGameInstanceSubsystem.ToggleAutoRecovery
// 0x0001 (0x0001 - 0x0000)
struct MM_CheatGameInstanceSubsystem_ToggleAutoRecovery final
{
public:
	bool                                          bOn;                                               // 0x0000(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(MM_CheatGameInstanceSubsystem_ToggleAutoRecovery) == 0x000001, "Wrong alignment on MM_CheatGameInstanceSubsystem_ToggleAutoRecovery");
static_assert(sizeof(MM_CheatGameInstanceSubsystem_ToggleAutoRecovery) == 0x000001, "Wrong size on MM_CheatGameInstanceSubsystem_ToggleAutoRecovery");
static_assert(offsetof(MM_CheatGameInstanceSubsystem_ToggleAutoRecovery, bOn) == 0x000000, "Member 'MM_CheatGameInstanceSubsystem_ToggleAutoRecovery::bOn' has a wrong offset!");

// Function MirMobile.MM_CheatGameInstanceSubsystem.ToggleEncrypt
// 0x0004 (0x0004 - 0x0000)
struct MM_CheatGameInstanceSubsystem_ToggleEncrypt final
{
public:
	int32                                         Mode;                                              // 0x0000(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(MM_CheatGameInstanceSubsystem_ToggleEncrypt) == 0x000004, "Wrong alignment on MM_CheatGameInstanceSubsystem_ToggleEncrypt");
static_assert(sizeof(MM_CheatGameInstanceSubsystem_ToggleEncrypt) == 0x000004, "Wrong size on MM_CheatGameInstanceSubsystem_ToggleEncrypt");
static_assert(offsetof(MM_CheatGameInstanceSubsystem_ToggleEncrypt, Mode) == 0x000000, "Member 'MM_CheatGameInstanceSubsystem_ToggleEncrypt::Mode' has a wrong offset!");

// Function MirMobile.MM_CheatGameInstanceSubsystem.ToggleFileLog
// 0x0001 (0x0001 - 0x0000)
struct MM_CheatGameInstanceSubsystem_ToggleFileLog final
{
public:
	bool                                          bOn;                                               // 0x0000(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(MM_CheatGameInstanceSubsystem_ToggleFileLog) == 0x000001, "Wrong alignment on MM_CheatGameInstanceSubsystem_ToggleFileLog");
static_assert(sizeof(MM_CheatGameInstanceSubsystem_ToggleFileLog) == 0x000001, "Wrong size on MM_CheatGameInstanceSubsystem_ToggleFileLog");
static_assert(offsetof(MM_CheatGameInstanceSubsystem_ToggleFileLog, bOn) == 0x000000, "Member 'MM_CheatGameInstanceSubsystem_ToggleFileLog::bOn' has a wrong offset!");

// Function MirMobile.MM_CheatGameInstanceSubsystem.ToggleHud
// 0x0004 (0x0004 - 0x0000)
struct MM_CheatGameInstanceSubsystem_ToggleHud final
{
public:
	int32                                         Hudid;                                             // 0x0000(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(MM_CheatGameInstanceSubsystem_ToggleHud) == 0x000004, "Wrong alignment on MM_CheatGameInstanceSubsystem_ToggleHud");
static_assert(sizeof(MM_CheatGameInstanceSubsystem_ToggleHud) == 0x000004, "Wrong size on MM_CheatGameInstanceSubsystem_ToggleHud");
static_assert(offsetof(MM_CheatGameInstanceSubsystem_ToggleHud, Hudid) == 0x000000, "Member 'MM_CheatGameInstanceSubsystem_ToggleHud::Hudid' has a wrong offset!");

// Function MirMobile.MM_CheatGameInstanceSubsystem.TogglePhaseMode
// 0x0004 (0x0004 - 0x0000)
struct MM_CheatGameInstanceSubsystem_TogglePhaseMode final
{
public:
	int32                                         NPhaseTID;                                         // 0x0000(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(MM_CheatGameInstanceSubsystem_TogglePhaseMode) == 0x000004, "Wrong alignment on MM_CheatGameInstanceSubsystem_TogglePhaseMode");
static_assert(sizeof(MM_CheatGameInstanceSubsystem_TogglePhaseMode) == 0x000004, "Wrong size on MM_CheatGameInstanceSubsystem_TogglePhaseMode");
static_assert(offsetof(MM_CheatGameInstanceSubsystem_TogglePhaseMode, NPhaseTID) == 0x000000, "Member 'MM_CheatGameInstanceSubsystem_TogglePhaseMode::NPhaseTID' has a wrong offset!");

// Function MirMobile.MM_CheatGameInstanceSubsystem.TutorialHighLight
// 0x0008 (0x0008 - 0x0000)
struct MM_CheatGameInstanceSubsystem_TutorialHighLight final
{
public:
	class FName                                   TargetIndex;                                       // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(MM_CheatGameInstanceSubsystem_TutorialHighLight) == 0x000004, "Wrong alignment on MM_CheatGameInstanceSubsystem_TutorialHighLight");
static_assert(sizeof(MM_CheatGameInstanceSubsystem_TutorialHighLight) == 0x000008, "Wrong size on MM_CheatGameInstanceSubsystem_TutorialHighLight");
static_assert(offsetof(MM_CheatGameInstanceSubsystem_TutorialHighLight, TargetIndex) == 0x000000, "Member 'MM_CheatGameInstanceSubsystem_TutorialHighLight::TargetIndex' has a wrong offset!");

// Function MirMobile.MM_CheatGameInstanceSubsystem.unlockcontents
// 0x0004 (0x0004 - 0x0000)
struct MM_CheatGameInstanceSubsystem_Unlockcontents final
{
public:
	int32                                         ContentsId;                                        // 0x0000(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(MM_CheatGameInstanceSubsystem_Unlockcontents) == 0x000004, "Wrong alignment on MM_CheatGameInstanceSubsystem_Unlockcontents");
static_assert(sizeof(MM_CheatGameInstanceSubsystem_Unlockcontents) == 0x000004, "Wrong size on MM_CheatGameInstanceSubsystem_Unlockcontents");
static_assert(offsetof(MM_CheatGameInstanceSubsystem_Unlockcontents, ContentsId) == 0x000000, "Member 'MM_CheatGameInstanceSubsystem_Unlockcontents::ContentsId' has a wrong offset!");

// Function MirMobile.MM_ClassSelect.OnSelectClass
// 0x0004 (0x0004 - 0x0000)
struct MM_ClassSelect_OnSelectClass final
{
public:
	int32                                         ClassID;                                           // 0x0000(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(MM_ClassSelect_OnSelectClass) == 0x000004, "Wrong alignment on MM_ClassSelect_OnSelectClass");
static_assert(sizeof(MM_ClassSelect_OnSelectClass) == 0x000004, "Wrong size on MM_ClassSelect_OnSelectClass");
static_assert(offsetof(MM_ClassSelect_OnSelectClass, ClassID) == 0x000000, "Member 'MM_ClassSelect_OnSelectClass::ClassID' has a wrong offset!");

// Function MirMobile.MM_Hud_Chat_Area.OnTextChanged
// 0x0018 (0x0018 - 0x0000)
struct MM_Hud_Chat_Area_OnTextChanged final
{
public:
	class FText                                   Text;                                              // 0x0000(0x0018)(ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
};
static_assert(alignof(MM_Hud_Chat_Area_OnTextChanged) == 0x000008, "Wrong alignment on MM_Hud_Chat_Area_OnTextChanged");
static_assert(sizeof(MM_Hud_Chat_Area_OnTextChanged) == 0x000018, "Wrong size on MM_Hud_Chat_Area_OnTextChanged");
static_assert(offsetof(MM_Hud_Chat_Area_OnTextChanged, Text) == 0x000000, "Member 'MM_Hud_Chat_Area_OnTextChanged::Text' has a wrong offset!");

// Function MirMobile.MM_Hud_Chat_Area.OnTextCommitted
// 0x0020 (0x0020 - 0x0000)
struct MM_Hud_Chat_Area_OnTextCommitted final
{
public:
	class FText                                   Text;                                              // 0x0000(0x0018)(ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
	ETextCommit                                   CommitMethod;                                      // 0x0018(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_19[0x7];                                       // 0x0019(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(MM_Hud_Chat_Area_OnTextCommitted) == 0x000008, "Wrong alignment on MM_Hud_Chat_Area_OnTextCommitted");
static_assert(sizeof(MM_Hud_Chat_Area_OnTextCommitted) == 0x000020, "Wrong size on MM_Hud_Chat_Area_OnTextCommitted");
static_assert(offsetof(MM_Hud_Chat_Area_OnTextCommitted, Text) == 0x000000, "Member 'MM_Hud_Chat_Area_OnTextCommitted::Text' has a wrong offset!");
static_assert(offsetof(MM_Hud_Chat_Area_OnTextCommitted, CommitMethod) == 0x000018, "Member 'MM_Hud_Chat_Area_OnTextCommitted::CommitMethod' has a wrong offset!");

// Function MirMobile.MM_Hud_Chat_Area.OnToggleMacroChat
// 0x0001 (0x0001 - 0x0000)
struct MM_Hud_Chat_Area_OnToggleMacroChat final
{
public:
	bool                                          CheckState;                                        // 0x0000(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(MM_Hud_Chat_Area_OnToggleMacroChat) == 0x000001, "Wrong alignment on MM_Hud_Chat_Area_OnToggleMacroChat");
static_assert(sizeof(MM_Hud_Chat_Area_OnToggleMacroChat) == 0x000001, "Wrong size on MM_Hud_Chat_Area_OnToggleMacroChat");
static_assert(offsetof(MM_Hud_Chat_Area_OnToggleMacroChat, CheckState) == 0x000000, "Member 'MM_Hud_Chat_Area_OnToggleMacroChat::CheckState' has a wrong offset!");

// Function MirMobile.MM_Hud_Chat_Area.OnToggleVoiceChat
// 0x0001 (0x0001 - 0x0000)
struct MM_Hud_Chat_Area_OnToggleVoiceChat final
{
public:
	bool                                          CheckState;                                        // 0x0000(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(MM_Hud_Chat_Area_OnToggleVoiceChat) == 0x000001, "Wrong alignment on MM_Hud_Chat_Area_OnToggleVoiceChat");
static_assert(sizeof(MM_Hud_Chat_Area_OnToggleVoiceChat) == 0x000001, "Wrong size on MM_Hud_Chat_Area_OnToggleVoiceChat");
static_assert(offsetof(MM_Hud_Chat_Area_OnToggleVoiceChat, CheckState) == 0x000000, "Member 'MM_Hud_Chat_Area_OnToggleVoiceChat::CheckState' has a wrong offset!");

// Function MirMobile.MM_Collect_TierList.OnClickComboList
// 0x0004 (0x0004 - 0x0000)
struct MM_Collect_TierList_OnClickComboList final
{
public:
	int32                                         IIndex;                                            // 0x0000(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(MM_Collect_TierList_OnClickComboList) == 0x000004, "Wrong alignment on MM_Collect_TierList_OnClickComboList");
static_assert(sizeof(MM_Collect_TierList_OnClickComboList) == 0x000004, "Wrong size on MM_Collect_TierList_OnClickComboList");
static_assert(offsetof(MM_Collect_TierList_OnClickComboList, IIndex) == 0x000000, "Member 'MM_Collect_TierList_OnClickComboList::IIndex' has a wrong offset!");

// Function MirMobile.MM_Collect_TierList.OnClickTierSlot
// 0x0008 (0x0008 - 0x0000)
struct MM_Collect_TierList_OnClickTierSlot final
{
public:
	int32                                         IIndex;                                            // 0x0000(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bSlotUpdate;                                       // 0x0004(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_5[0x3];                                        // 0x0005(0x0003)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(MM_Collect_TierList_OnClickTierSlot) == 0x000004, "Wrong alignment on MM_Collect_TierList_OnClickTierSlot");
static_assert(sizeof(MM_Collect_TierList_OnClickTierSlot) == 0x000008, "Wrong size on MM_Collect_TierList_OnClickTierSlot");
static_assert(offsetof(MM_Collect_TierList_OnClickTierSlot, IIndex) == 0x000000, "Member 'MM_Collect_TierList_OnClickTierSlot::IIndex' has a wrong offset!");
static_assert(offsetof(MM_Collect_TierList_OnClickTierSlot, bSlotUpdate) == 0x000004, "Member 'MM_Collect_TierList_OnClickTierSlot::bSlotUpdate' has a wrong offset!");

// Function MirMobile.MM_Hud_Chat_EmperorShout_Slot.OnChangeText
// 0x0018 (0x0018 - 0x0000)
struct MM_Hud_Chat_EmperorShout_Slot_OnChangeText final
{
public:
	class FText                                   Text;                                              // 0x0000(0x0018)(ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
};
static_assert(alignof(MM_Hud_Chat_EmperorShout_Slot_OnChangeText) == 0x000008, "Wrong alignment on MM_Hud_Chat_EmperorShout_Slot_OnChangeText");
static_assert(sizeof(MM_Hud_Chat_EmperorShout_Slot_OnChangeText) == 0x000018, "Wrong size on MM_Hud_Chat_EmperorShout_Slot_OnChangeText");
static_assert(offsetof(MM_Hud_Chat_EmperorShout_Slot_OnChangeText, Text) == 0x000000, "Member 'MM_Hud_Chat_EmperorShout_Slot_OnChangeText::Text' has a wrong offset!");

// Function MirMobile.MM_Popup_CollectItemRegist.OnClickCollectSlot
// 0x0008 (0x0008 - 0x0000)
struct MM_Popup_CollectItemRegist_OnClickCollectSlot final
{
public:
	class UMM_Slot_Collect_Item*                  PSlot;                                             // 0x0000(0x0008)(Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(MM_Popup_CollectItemRegist_OnClickCollectSlot) == 0x000008, "Wrong alignment on MM_Popup_CollectItemRegist_OnClickCollectSlot");
static_assert(sizeof(MM_Popup_CollectItemRegist_OnClickCollectSlot) == 0x000008, "Wrong size on MM_Popup_CollectItemRegist_OnClickCollectSlot");
static_assert(offsetof(MM_Popup_CollectItemRegist_OnClickCollectSlot, PSlot) == 0x000000, "Member 'MM_Popup_CollectItemRegist_OnClickCollectSlot::PSlot' has a wrong offset!");

// Function MirMobile.MM_Common_Popup_Outgame.OnClickMoveChannelOK
// 0x0004 (0x0004 - 0x0000)
struct MM_Common_Popup_Outgame_OnClickMoveChannelOK final
{
public:
	int32                                         ChannelIDX;                                        // 0x0000(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(MM_Common_Popup_Outgame_OnClickMoveChannelOK) == 0x000004, "Wrong alignment on MM_Common_Popup_Outgame_OnClickMoveChannelOK");
static_assert(sizeof(MM_Common_Popup_Outgame_OnClickMoveChannelOK) == 0x000004, "Wrong size on MM_Common_Popup_Outgame_OnClickMoveChannelOK");
static_assert(offsetof(MM_Common_Popup_Outgame_OnClickMoveChannelOK, ChannelIDX) == 0x000000, "Member 'MM_Common_Popup_Outgame_OnClickMoveChannelOK::ChannelIDX' has a wrong offset!");

// Function MirMobile.MM_Common_Popup_StopWatchingToday.OnClickCheckBox
// 0x0001 (0x0001 - 0x0000)
struct MM_Common_Popup_StopWatchingToday_OnClickCheckBox final
{
public:
	bool                                          Checked;                                           // 0x0000(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(MM_Common_Popup_StopWatchingToday_OnClickCheckBox) == 0x000001, "Wrong alignment on MM_Common_Popup_StopWatchingToday_OnClickCheckBox");
static_assert(sizeof(MM_Common_Popup_StopWatchingToday_OnClickCheckBox) == 0x000001, "Wrong size on MM_Common_Popup_StopWatchingToday_OnClickCheckBox");
static_assert(offsetof(MM_Common_Popup_StopWatchingToday_OnClickCheckBox, Checked) == 0x000000, "Member 'MM_Common_Popup_StopWatchingToday_OnClickCheckBox::Checked' has a wrong offset!");

// Function MirMobile.MM_CommonHorizontalTabSet.OnClickTab
// 0x0008 (0x0008 - 0x0000)
struct MM_CommonHorizontalTabSet_OnClickTab final
{
public:
	int32                                         ITabIndex;                                         // 0x0000(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bLocked;                                           // 0x0004(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_5[0x3];                                        // 0x0005(0x0003)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(MM_CommonHorizontalTabSet_OnClickTab) == 0x000004, "Wrong alignment on MM_CommonHorizontalTabSet_OnClickTab");
static_assert(sizeof(MM_CommonHorizontalTabSet_OnClickTab) == 0x000008, "Wrong size on MM_CommonHorizontalTabSet_OnClickTab");
static_assert(offsetof(MM_CommonHorizontalTabSet_OnClickTab, ITabIndex) == 0x000000, "Member 'MM_CommonHorizontalTabSet_OnClickTab::ITabIndex' has a wrong offset!");
static_assert(offsetof(MM_CommonHorizontalTabSet_OnClickTab, bLocked) == 0x000004, "Member 'MM_CommonHorizontalTabSet_OnClickTab::bLocked' has a wrong offset!");

// Function MirMobile.MM_Costume_SlideBar.OnClickSlider
// 0x0004 (0x0004 - 0x0000)
struct MM_Costume_SlideBar_OnClickSlider final
{
public:
	float                                         PosX;                                              // 0x0000(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(MM_Costume_SlideBar_OnClickSlider) == 0x000004, "Wrong alignment on MM_Costume_SlideBar_OnClickSlider");
static_assert(sizeof(MM_Costume_SlideBar_OnClickSlider) == 0x000004, "Wrong size on MM_Costume_SlideBar_OnClickSlider");
static_assert(offsetof(MM_Costume_SlideBar_OnClickSlider, PosX) == 0x000000, "Member 'MM_Costume_SlideBar_OnClickSlider::PosX' has a wrong offset!");

// Function MirMobile.MM_Costume_SlideBar.OnDragControlButton
// 0x0008 (0x0008 - 0x0000)
struct MM_Costume_SlideBar_OnDragControlButton final
{
public:
	struct FVector2D                              DragX;                                             // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(MM_Costume_SlideBar_OnDragControlButton) == 0x000004, "Wrong alignment on MM_Costume_SlideBar_OnDragControlButton");
static_assert(sizeof(MM_Costume_SlideBar_OnDragControlButton) == 0x000008, "Wrong size on MM_Costume_SlideBar_OnDragControlButton");
static_assert(offsetof(MM_Costume_SlideBar_OnDragControlButton, DragX) == 0x000000, "Member 'MM_Costume_SlideBar_OnDragControlButton::DragX' has a wrong offset!");

// Function MirMobile.MM_Costume_SlideBar.OnReleasedControlButton
// 0x0008 (0x0008 - 0x0000)
struct MM_Costume_SlideBar_OnReleasedControlButton final
{
public:
	struct FVector2D                              DragLoc;                                           // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(MM_Costume_SlideBar_OnReleasedControlButton) == 0x000004, "Wrong alignment on MM_Costume_SlideBar_OnReleasedControlButton");
static_assert(sizeof(MM_Costume_SlideBar_OnReleasedControlButton) == 0x000008, "Wrong size on MM_Costume_SlideBar_OnReleasedControlButton");
static_assert(offsetof(MM_Costume_SlideBar_OnReleasedControlButton, DragLoc) == 0x000000, "Member 'MM_Costume_SlideBar_OnReleasedControlButton::DragLoc' has a wrong offset!");

// Function MirMobile.MM_Costume_SlideBar.SetControlSlider_1
// 0x0004 (0x0004 - 0x0000)
struct MM_Costume_SlideBar_SetControlSlider_1 final
{
public:
	float                                         PosX;                                              // 0x0000(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(MM_Costume_SlideBar_SetControlSlider_1) == 0x000004, "Wrong alignment on MM_Costume_SlideBar_SetControlSlider_1");
static_assert(sizeof(MM_Costume_SlideBar_SetControlSlider_1) == 0x000004, "Wrong size on MM_Costume_SlideBar_SetControlSlider_1");
static_assert(offsetof(MM_Costume_SlideBar_SetControlSlider_1, PosX) == 0x000000, "Member 'MM_Costume_SlideBar_SetControlSlider_1::PosX' has a wrong offset!");

// Function MirMobile.MM_Costume_SlideBar.UpdateSliderValue
// 0x0008 (0x0008 - 0x0000)
struct MM_Costume_SlideBar_UpdateSliderValue final
{
public:
	int32                                         SlideBarType;                                      // 0x0000(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         SliderValue;                                       // 0x0004(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(MM_Costume_SlideBar_UpdateSliderValue) == 0x000004, "Wrong alignment on MM_Costume_SlideBar_UpdateSliderValue");
static_assert(sizeof(MM_Costume_SlideBar_UpdateSliderValue) == 0x000008, "Wrong size on MM_Costume_SlideBar_UpdateSliderValue");
static_assert(offsetof(MM_Costume_SlideBar_UpdateSliderValue, SlideBarType) == 0x000000, "Member 'MM_Costume_SlideBar_UpdateSliderValue::SlideBarType' has a wrong offset!");
static_assert(offsetof(MM_Costume_SlideBar_UpdateSliderValue, SliderValue) == 0x000004, "Member 'MM_Costume_SlideBar_UpdateSliderValue::SliderValue' has a wrong offset!");

// Function MirMobile.MM_CostumeDyeingCheatWidget.Change01ColorValue
// 0x0010 (0x0010 - 0x0000)
struct MM_CostumeDyeingCheatWidget_Change01ColorValue final
{
public:
	float                                         Body01_R;                                          // 0x0000(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         Body01_G;                                          // 0x0004(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         Body01_B;                                          // 0x0008(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         Body01_V;                                          // 0x000C(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(MM_CostumeDyeingCheatWidget_Change01ColorValue) == 0x000004, "Wrong alignment on MM_CostumeDyeingCheatWidget_Change01ColorValue");
static_assert(sizeof(MM_CostumeDyeingCheatWidget_Change01ColorValue) == 0x000010, "Wrong size on MM_CostumeDyeingCheatWidget_Change01ColorValue");
static_assert(offsetof(MM_CostumeDyeingCheatWidget_Change01ColorValue, Body01_R) == 0x000000, "Member 'MM_CostumeDyeingCheatWidget_Change01ColorValue::Body01_R' has a wrong offset!");
static_assert(offsetof(MM_CostumeDyeingCheatWidget_Change01ColorValue, Body01_G) == 0x000004, "Member 'MM_CostumeDyeingCheatWidget_Change01ColorValue::Body01_G' has a wrong offset!");
static_assert(offsetof(MM_CostumeDyeingCheatWidget_Change01ColorValue, Body01_B) == 0x000008, "Member 'MM_CostumeDyeingCheatWidget_Change01ColorValue::Body01_B' has a wrong offset!");
static_assert(offsetof(MM_CostumeDyeingCheatWidget_Change01ColorValue, Body01_V) == 0x00000C, "Member 'MM_CostumeDyeingCheatWidget_Change01ColorValue::Body01_V' has a wrong offset!");

// Function MirMobile.MM_CostumeDyeingCheatWidget.Change02ColorValue
// 0x0010 (0x0010 - 0x0000)
struct MM_CostumeDyeingCheatWidget_Change02ColorValue final
{
public:
	float                                         Body02_R;                                          // 0x0000(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         Body02_G;                                          // 0x0004(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         Body02_B;                                          // 0x0008(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         Body02_V;                                          // 0x000C(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(MM_CostumeDyeingCheatWidget_Change02ColorValue) == 0x000004, "Wrong alignment on MM_CostumeDyeingCheatWidget_Change02ColorValue");
static_assert(sizeof(MM_CostumeDyeingCheatWidget_Change02ColorValue) == 0x000010, "Wrong size on MM_CostumeDyeingCheatWidget_Change02ColorValue");
static_assert(offsetof(MM_CostumeDyeingCheatWidget_Change02ColorValue, Body02_R) == 0x000000, "Member 'MM_CostumeDyeingCheatWidget_Change02ColorValue::Body02_R' has a wrong offset!");
static_assert(offsetof(MM_CostumeDyeingCheatWidget_Change02ColorValue, Body02_G) == 0x000004, "Member 'MM_CostumeDyeingCheatWidget_Change02ColorValue::Body02_G' has a wrong offset!");
static_assert(offsetof(MM_CostumeDyeingCheatWidget_Change02ColorValue, Body02_B) == 0x000008, "Member 'MM_CostumeDyeingCheatWidget_Change02ColorValue::Body02_B' has a wrong offset!");
static_assert(offsetof(MM_CostumeDyeingCheatWidget_Change02ColorValue, Body02_V) == 0x00000C, "Member 'MM_CostumeDyeingCheatWidget_Change02ColorValue::Body02_V' has a wrong offset!");

// Function MirMobile.MM_CostumeDyeingCheatWidget.UpdateCostume
// 0x0004 (0x0004 - 0x0000)
struct MM_CostumeDyeingCheatWidget_UpdateCostume final
{
public:
	int32                                         CostumeID;                                         // 0x0000(0x0004)(ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(MM_CostumeDyeingCheatWidget_UpdateCostume) == 0x000004, "Wrong alignment on MM_CostumeDyeingCheatWidget_UpdateCostume");
static_assert(sizeof(MM_CostumeDyeingCheatWidget_UpdateCostume) == 0x000004, "Wrong size on MM_CostumeDyeingCheatWidget_UpdateCostume");
static_assert(offsetof(MM_CostumeDyeingCheatWidget_UpdateCostume, CostumeID) == 0x000000, "Member 'MM_CostumeDyeingCheatWidget_UpdateCostume::CostumeID' has a wrong offset!");

// Function MirMobile.MM_Customizing_Category.OnClickMainCategory
// 0x0004 (0x0004 - 0x0000)
struct MM_Customizing_Category_OnClickMainCategory final
{
public:
	int32                                         CategoryIndex;                                     // 0x0000(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(MM_Customizing_Category_OnClickMainCategory) == 0x000004, "Wrong alignment on MM_Customizing_Category_OnClickMainCategory");
static_assert(sizeof(MM_Customizing_Category_OnClickMainCategory) == 0x000004, "Wrong size on MM_Customizing_Category_OnClickMainCategory");
static_assert(offsetof(MM_Customizing_Category_OnClickMainCategory, CategoryIndex) == 0x000000, "Member 'MM_Customizing_Category_OnClickMainCategory::CategoryIndex' has a wrong offset!");

// Function MirMobile.MM_Customizing_Category.OnClickSubCategory
// 0x0004 (0x0004 - 0x0000)
struct MM_Customizing_Category_OnClickSubCategory final
{
public:
	int32                                         CategoryIndex;                                     // 0x0000(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(MM_Customizing_Category_OnClickSubCategory) == 0x000004, "Wrong alignment on MM_Customizing_Category_OnClickSubCategory");
static_assert(sizeof(MM_Customizing_Category_OnClickSubCategory) == 0x000004, "Wrong size on MM_Customizing_Category_OnClickSubCategory");
static_assert(offsetof(MM_Customizing_Category_OnClickSubCategory, CategoryIndex) == 0x000000, "Member 'MM_Customizing_Category_OnClickSubCategory::CategoryIndex' has a wrong offset!");

// Function MirMobile.MM_Customizing_Category.OnClickTopCategory
// 0x0004 (0x0004 - 0x0000)
struct MM_Customizing_Category_OnClickTopCategory final
{
public:
	int32                                         CategoryIndex;                                     // 0x0000(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(MM_Customizing_Category_OnClickTopCategory) == 0x000004, "Wrong alignment on MM_Customizing_Category_OnClickTopCategory");
static_assert(sizeof(MM_Customizing_Category_OnClickTopCategory) == 0x000004, "Wrong size on MM_Customizing_Category_OnClickTopCategory");
static_assert(offsetof(MM_Customizing_Category_OnClickTopCategory, CategoryIndex) == 0x000000, "Member 'MM_Customizing_Category_OnClickTopCategory::CategoryIndex' has a wrong offset!");

// Function MirMobile.MM_Customizing_Component.SetCategoryID
// 0x0004 (0x0004 - 0x0000)
struct MM_Customizing_Component_SetCategoryID final
{
public:
	int32                                         _CategoryID;                                       // 0x0000(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(MM_Customizing_Component_SetCategoryID) == 0x000004, "Wrong alignment on MM_Customizing_Component_SetCategoryID");
static_assert(sizeof(MM_Customizing_Component_SetCategoryID) == 0x000004, "Wrong size on MM_Customizing_Component_SetCategoryID");
static_assert(offsetof(MM_Customizing_Component_SetCategoryID, _CategoryID) == 0x000000, "Member 'MM_Customizing_Component_SetCategoryID::_CategoryID' has a wrong offset!");

// Function MirMobile.MM_Customizing_My_Costume.CreateCostumeItem
// 0x0018 (0x0018 - 0x0000)
struct MM_Customizing_My_Costume_CreateCostumeItem final
{
public:
	int32                                         Count;                                             // 0x0000(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_4[0x4];                                        // 0x0004(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<class UMM_Customizing_ListItem*>       ReturnValue;                                       // 0x0008(0x0010)(ExportObject, Parm, OutParm, ZeroConstructor, ReturnParm, ContainsInstancedReference, NativeAccessSpecifierPublic)
};
static_assert(alignof(MM_Customizing_My_Costume_CreateCostumeItem) == 0x000008, "Wrong alignment on MM_Customizing_My_Costume_CreateCostumeItem");
static_assert(sizeof(MM_Customizing_My_Costume_CreateCostumeItem) == 0x000018, "Wrong size on MM_Customizing_My_Costume_CreateCostumeItem");
static_assert(offsetof(MM_Customizing_My_Costume_CreateCostumeItem, Count) == 0x000000, "Member 'MM_Customizing_My_Costume_CreateCostumeItem::Count' has a wrong offset!");
static_assert(offsetof(MM_Customizing_My_Costume_CreateCostumeItem, ReturnValue) == 0x000008, "Member 'MM_Customizing_My_Costume_CreateCostumeItem::ReturnValue' has a wrong offset!");

// Function MirMobile.MM_Customizing_My_Costume.OnClickCostumeItemEvent
// 0x0004 (0x0004 - 0x0000)
struct MM_Customizing_My_Costume_OnClickCostumeItemEvent final
{
public:
	int32                                         ListIndex;                                         // 0x0000(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(MM_Customizing_My_Costume_OnClickCostumeItemEvent) == 0x000004, "Wrong alignment on MM_Customizing_My_Costume_OnClickCostumeItemEvent");
static_assert(sizeof(MM_Customizing_My_Costume_OnClickCostumeItemEvent) == 0x000004, "Wrong size on MM_Customizing_My_Costume_OnClickCostumeItemEvent");
static_assert(offsetof(MM_Customizing_My_Costume_OnClickCostumeItemEvent, ListIndex) == 0x000000, "Member 'MM_Customizing_My_Costume_OnClickCostumeItemEvent::ListIndex' has a wrong offset!");

// Function MirMobile.MM_Customizing_Picker.OnClickPicker
// 0x0008 (0x0008 - 0x0000)
struct MM_Customizing_Picker_OnClickPicker final
{
public:
	struct FVector2D                              Loc;                                               // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(MM_Customizing_Picker_OnClickPicker) == 0x000004, "Wrong alignment on MM_Customizing_Picker_OnClickPicker");
static_assert(sizeof(MM_Customizing_Picker_OnClickPicker) == 0x000008, "Wrong size on MM_Customizing_Picker_OnClickPicker");
static_assert(offsetof(MM_Customizing_Picker_OnClickPicker, Loc) == 0x000000, "Member 'MM_Customizing_Picker_OnClickPicker::Loc' has a wrong offset!");

// Function MirMobile.MM_Customizing_Picker.OnClickSubCategoryEvent
// 0x0004 (0x0004 - 0x0000)
struct MM_Customizing_Picker_OnClickSubCategoryEvent final
{
public:
	int32                                         SubCategoryIndex;                                  // 0x0000(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(MM_Customizing_Picker_OnClickSubCategoryEvent) == 0x000004, "Wrong alignment on MM_Customizing_Picker_OnClickSubCategoryEvent");
static_assert(sizeof(MM_Customizing_Picker_OnClickSubCategoryEvent) == 0x000004, "Wrong size on MM_Customizing_Picker_OnClickSubCategoryEvent");
static_assert(offsetof(MM_Customizing_Picker_OnClickSubCategoryEvent, SubCategoryIndex) == 0x000000, "Member 'MM_Customizing_Picker_OnClickSubCategoryEvent::SubCategoryIndex' has a wrong offset!");

// Function MirMobile.MM_Customizing_Picker.OnDragControlButton
// 0x0008 (0x0008 - 0x0000)
struct MM_Customizing_Picker_OnDragControlButton final
{
public:
	struct FVector2D                              DragLoc;                                           // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(MM_Customizing_Picker_OnDragControlButton) == 0x000004, "Wrong alignment on MM_Customizing_Picker_OnDragControlButton");
static_assert(sizeof(MM_Customizing_Picker_OnDragControlButton) == 0x000008, "Wrong size on MM_Customizing_Picker_OnDragControlButton");
static_assert(offsetof(MM_Customizing_Picker_OnDragControlButton, DragLoc) == 0x000000, "Member 'MM_Customizing_Picker_OnDragControlButton::DragLoc' has a wrong offset!");

// Function MirMobile.MM_Customizing_Picker.OnReleasedControlButton
// 0x0008 (0x0008 - 0x0000)
struct MM_Customizing_Picker_OnReleasedControlButton final
{
public:
	struct FVector2D                              DragLoc;                                           // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(MM_Customizing_Picker_OnReleasedControlButton) == 0x000004, "Wrong alignment on MM_Customizing_Picker_OnReleasedControlButton");
static_assert(sizeof(MM_Customizing_Picker_OnReleasedControlButton) == 0x000008, "Wrong size on MM_Customizing_Picker_OnReleasedControlButton");
static_assert(offsetof(MM_Customizing_Picker_OnReleasedControlButton, DragLoc) == 0x000000, "Member 'MM_Customizing_Picker_OnReleasedControlButton::DragLoc' has a wrong offset!");

// Function MirMobile.MM_Customizing_Picker.OnStartControlButton
// 0x0008 (0x0008 - 0x0000)
struct MM_Customizing_Picker_OnStartControlButton final
{
public:
	struct FVector2D                              DragLoc;                                           // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(MM_Customizing_Picker_OnStartControlButton) == 0x000004, "Wrong alignment on MM_Customizing_Picker_OnStartControlButton");
static_assert(sizeof(MM_Customizing_Picker_OnStartControlButton) == 0x000008, "Wrong size on MM_Customizing_Picker_OnStartControlButton");
static_assert(offsetof(MM_Customizing_Picker_OnStartControlButton, DragLoc) == 0x000000, "Member 'MM_Customizing_Picker_OnStartControlButton::DragLoc' has a wrong offset!");

// Function MirMobile.MM_Customizing_Picker.SetControlPos
// 0x0008 (0x0008 - 0x0000)
struct MM_Customizing_Picker_SetControlPos final
{
public:
	struct FVector2D                              Pos;                                               // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(MM_Customizing_Picker_SetControlPos) == 0x000004, "Wrong alignment on MM_Customizing_Picker_SetControlPos");
static_assert(sizeof(MM_Customizing_Picker_SetControlPos) == 0x000008, "Wrong size on MM_Customizing_Picker_SetControlPos");
static_assert(offsetof(MM_Customizing_Picker_SetControlPos, Pos) == 0x000000, "Member 'MM_Customizing_Picker_SetControlPos::Pos' has a wrong offset!");

// Function MirMobile.MM_Customizing_Picker.UpdatePickerValue1
// 0x0004 (0x0004 - 0x0000)
struct MM_Customizing_Picker_UpdatePickerValue1 final
{
public:
	int32                                         PickerValue;                                       // 0x0000(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(MM_Customizing_Picker_UpdatePickerValue1) == 0x000004, "Wrong alignment on MM_Customizing_Picker_UpdatePickerValue1");
static_assert(sizeof(MM_Customizing_Picker_UpdatePickerValue1) == 0x000004, "Wrong size on MM_Customizing_Picker_UpdatePickerValue1");
static_assert(offsetof(MM_Customizing_Picker_UpdatePickerValue1, PickerValue) == 0x000000, "Member 'MM_Customizing_Picker_UpdatePickerValue1::PickerValue' has a wrong offset!");

// Function MirMobile.MM_Customizing_Picker.UpdatePickerValue2
// 0x0004 (0x0004 - 0x0000)
struct MM_Customizing_Picker_UpdatePickerValue2 final
{
public:
	int32                                         PickerValue;                                       // 0x0000(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(MM_Customizing_Picker_UpdatePickerValue2) == 0x000004, "Wrong alignment on MM_Customizing_Picker_UpdatePickerValue2");
static_assert(sizeof(MM_Customizing_Picker_UpdatePickerValue2) == 0x000004, "Wrong size on MM_Customizing_Picker_UpdatePickerValue2");
static_assert(offsetof(MM_Customizing_Picker_UpdatePickerValue2, PickerValue) == 0x000000, "Member 'MM_Customizing_Picker_UpdatePickerValue2::PickerValue' has a wrong offset!");

// Function MirMobile.MM_Customizing_Preset.CreatePresetItem
// 0x0018 (0x0018 - 0x0000)
struct MM_Customizing_Preset_CreatePresetItem final
{
public:
	int32                                         Count;                                             // 0x0000(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_4[0x4];                                        // 0x0004(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<class UMM_Customizing_PresetItem*>     ReturnValue;                                       // 0x0008(0x0010)(ExportObject, Parm, OutParm, ZeroConstructor, ReturnParm, ContainsInstancedReference, NativeAccessSpecifierPublic)
};
static_assert(alignof(MM_Customizing_Preset_CreatePresetItem) == 0x000008, "Wrong alignment on MM_Customizing_Preset_CreatePresetItem");
static_assert(sizeof(MM_Customizing_Preset_CreatePresetItem) == 0x000018, "Wrong size on MM_Customizing_Preset_CreatePresetItem");
static_assert(offsetof(MM_Customizing_Preset_CreatePresetItem, Count) == 0x000000, "Member 'MM_Customizing_Preset_CreatePresetItem::Count' has a wrong offset!");
static_assert(offsetof(MM_Customizing_Preset_CreatePresetItem, ReturnValue) == 0x000008, "Member 'MM_Customizing_Preset_CreatePresetItem::ReturnValue' has a wrong offset!");

// Function MirMobile.MM_Customizing_Preset.OnClickPresetItem
// 0x0004 (0x0004 - 0x0000)
struct MM_Customizing_Preset_OnClickPresetItem final
{
public:
	int32                                         GroupId;                                           // 0x0000(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(MM_Customizing_Preset_OnClickPresetItem) == 0x000004, "Wrong alignment on MM_Customizing_Preset_OnClickPresetItem");
static_assert(sizeof(MM_Customizing_Preset_OnClickPresetItem) == 0x000004, "Wrong size on MM_Customizing_Preset_OnClickPresetItem");
static_assert(offsetof(MM_Customizing_Preset_OnClickPresetItem, GroupId) == 0x000000, "Member 'MM_Customizing_Preset_OnClickPresetItem::GroupId' has a wrong offset!");

// Function MirMobile.MM_Customizing_Preset.UpdatePresetSelectData
// 0x0004 (0x0004 - 0x0000)
struct MM_Customizing_Preset_UpdatePresetSelectData final
{
public:
	int32                                         PresetIndex;                                       // 0x0000(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(MM_Customizing_Preset_UpdatePresetSelectData) == 0x000004, "Wrong alignment on MM_Customizing_Preset_UpdatePresetSelectData");
static_assert(sizeof(MM_Customizing_Preset_UpdatePresetSelectData) == 0x000004, "Wrong size on MM_Customizing_Preset_UpdatePresetSelectData");
static_assert(offsetof(MM_Customizing_Preset_UpdatePresetSelectData, PresetIndex) == 0x000000, "Member 'MM_Customizing_Preset_UpdatePresetSelectData::PresetIndex' has a wrong offset!");

// Function MirMobile.MM_Guild_CoopMission.OnClickTab
// 0x0008 (0x0008 - 0x0000)
struct MM_Guild_CoopMission_OnClickTab final
{
public:
	int32                                         Index_;                                            // 0x0000(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bLocked;                                           // 0x0004(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_5[0x3];                                        // 0x0005(0x0003)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(MM_Guild_CoopMission_OnClickTab) == 0x000004, "Wrong alignment on MM_Guild_CoopMission_OnClickTab");
static_assert(sizeof(MM_Guild_CoopMission_OnClickTab) == 0x000008, "Wrong size on MM_Guild_CoopMission_OnClickTab");
static_assert(offsetof(MM_Guild_CoopMission_OnClickTab, Index_) == 0x000000, "Member 'MM_Guild_CoopMission_OnClickTab::Index_' has a wrong offset!");
static_assert(offsetof(MM_Guild_CoopMission_OnClickTab, bLocked) == 0x000004, "Member 'MM_Guild_CoopMission_OnClickTab::bLocked' has a wrong offset!");

// Function MirMobile.MM_Customizing_Save.CreateSaveSlot
// 0x0018 (0x0018 - 0x0000)
struct MM_Customizing_Save_CreateSaveSlot final
{
public:
	int32                                         Count;                                             // 0x0000(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_4[0x4];                                        // 0x0004(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<class UMM_Customizing_SaveSlot*>       ReturnValue;                                       // 0x0008(0x0010)(ExportObject, Parm, OutParm, ZeroConstructor, ReturnParm, ContainsInstancedReference, NativeAccessSpecifierPublic)
};
static_assert(alignof(MM_Customizing_Save_CreateSaveSlot) == 0x000008, "Wrong alignment on MM_Customizing_Save_CreateSaveSlot");
static_assert(sizeof(MM_Customizing_Save_CreateSaveSlot) == 0x000018, "Wrong size on MM_Customizing_Save_CreateSaveSlot");
static_assert(offsetof(MM_Customizing_Save_CreateSaveSlot, Count) == 0x000000, "Member 'MM_Customizing_Save_CreateSaveSlot::Count' has a wrong offset!");
static_assert(offsetof(MM_Customizing_Save_CreateSaveSlot, ReturnValue) == 0x000008, "Member 'MM_Customizing_Save_CreateSaveSlot::ReturnValue' has a wrong offset!");

// Function MirMobile.MM_Customizing_Save.OnClickAutoCheckBox
// 0x0001 (0x0001 - 0x0000)
struct MM_Customizing_Save_OnClickAutoCheckBox final
{
public:
	bool                                          _Check;                                            // 0x0000(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(MM_Customizing_Save_OnClickAutoCheckBox) == 0x000001, "Wrong alignment on MM_Customizing_Save_OnClickAutoCheckBox");
static_assert(sizeof(MM_Customizing_Save_OnClickAutoCheckBox) == 0x000001, "Wrong size on MM_Customizing_Save_OnClickAutoCheckBox");
static_assert(offsetof(MM_Customizing_Save_OnClickAutoCheckBox, _Check) == 0x000000, "Member 'MM_Customizing_Save_OnClickAutoCheckBox::_Check' has a wrong offset!");

// Function MirMobile.MM_Customizing_Save.OnClickSaveSlot
// 0x0004 (0x0004 - 0x0000)
struct MM_Customizing_Save_OnClickSaveSlot final
{
public:
	int32                                         _Slot;                                             // 0x0000(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(MM_Customizing_Save_OnClickSaveSlot) == 0x000004, "Wrong alignment on MM_Customizing_Save_OnClickSaveSlot");
static_assert(sizeof(MM_Customizing_Save_OnClickSaveSlot) == 0x000004, "Wrong size on MM_Customizing_Save_OnClickSaveSlot");
static_assert(offsetof(MM_Customizing_Save_OnClickSaveSlot, _Slot) == 0x000000, "Member 'MM_Customizing_Save_OnClickSaveSlot::_Slot' has a wrong offset!");

// Function MirMobile.MM_Customizing_Save.UpdateCheckSaveSlot
// 0x0008 (0x0008 - 0x0000)
struct MM_Customizing_Save_UpdateCheckSaveSlot final
{
public:
	int32                                         _Slot;                                             // 0x0000(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          ReturnValue;                                       // 0x0004(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_5[0x3];                                        // 0x0005(0x0003)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(MM_Customizing_Save_UpdateCheckSaveSlot) == 0x000004, "Wrong alignment on MM_Customizing_Save_UpdateCheckSaveSlot");
static_assert(sizeof(MM_Customizing_Save_UpdateCheckSaveSlot) == 0x000008, "Wrong size on MM_Customizing_Save_UpdateCheckSaveSlot");
static_assert(offsetof(MM_Customizing_Save_UpdateCheckSaveSlot, _Slot) == 0x000000, "Member 'MM_Customizing_Save_UpdateCheckSaveSlot::_Slot' has a wrong offset!");
static_assert(offsetof(MM_Customizing_Save_UpdateCheckSaveSlot, ReturnValue) == 0x000004, "Member 'MM_Customizing_Save_UpdateCheckSaveSlot::ReturnValue' has a wrong offset!");

// Function MirMobile.MM_Customizing_Scroll.OnClickScrollSlot
// 0x0004 (0x0004 - 0x0000)
struct MM_Customizing_Scroll_OnClickScrollSlot final
{
public:
	int32                                         NIndex;                                            // 0x0000(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(MM_Customizing_Scroll_OnClickScrollSlot) == 0x000004, "Wrong alignment on MM_Customizing_Scroll_OnClickScrollSlot");
static_assert(sizeof(MM_Customizing_Scroll_OnClickScrollSlot) == 0x000004, "Wrong size on MM_Customizing_Scroll_OnClickScrollSlot");
static_assert(offsetof(MM_Customizing_Scroll_OnClickScrollSlot, NIndex) == 0x000000, "Member 'MM_Customizing_Scroll_OnClickScrollSlot::NIndex' has a wrong offset!");

// Function MirMobile.MM_Customizing_SubCategoryItem.UpdateCustomizingDataEvent
// 0x0004 (0x0004 - 0x0000)
struct MM_Customizing_SubCategoryItem_UpdateCustomizingDataEvent final
{
public:
	int32                                         CustomzingID;                                      // 0x0000(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(MM_Customizing_SubCategoryItem_UpdateCustomizingDataEvent) == 0x000004, "Wrong alignment on MM_Customizing_SubCategoryItem_UpdateCustomizingDataEvent");
static_assert(sizeof(MM_Customizing_SubCategoryItem_UpdateCustomizingDataEvent) == 0x000004, "Wrong size on MM_Customizing_SubCategoryItem_UpdateCustomizingDataEvent");
static_assert(offsetof(MM_Customizing_SubCategoryItem_UpdateCustomizingDataEvent, CustomzingID) == 0x000000, "Member 'MM_Customizing_SubCategoryItem_UpdateCustomizingDataEvent::CustomzingID' has a wrong offset!");

// Function MirMobile.MM_CustomizingAnimInstance.OnLookAtAlpha
// 0x0008 (0x0008 - 0x0000)
struct MM_CustomizingAnimInstance_OnLookAtAlpha final
{
public:
	bool                                          bOnLookAt;                                         // 0x0000(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bImmediately;                                      // 0x0001(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2[0x2];                                        // 0x0002(0x0002)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         InterpSpeed;                                       // 0x0004(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(MM_CustomizingAnimInstance_OnLookAtAlpha) == 0x000004, "Wrong alignment on MM_CustomizingAnimInstance_OnLookAtAlpha");
static_assert(sizeof(MM_CustomizingAnimInstance_OnLookAtAlpha) == 0x000008, "Wrong size on MM_CustomizingAnimInstance_OnLookAtAlpha");
static_assert(offsetof(MM_CustomizingAnimInstance_OnLookAtAlpha, bOnLookAt) == 0x000000, "Member 'MM_CustomizingAnimInstance_OnLookAtAlpha::bOnLookAt' has a wrong offset!");
static_assert(offsetof(MM_CustomizingAnimInstance_OnLookAtAlpha, bImmediately) == 0x000001, "Member 'MM_CustomizingAnimInstance_OnLookAtAlpha::bImmediately' has a wrong offset!");
static_assert(offsetof(MM_CustomizingAnimInstance_OnLookAtAlpha, InterpSpeed) == 0x000004, "Member 'MM_CustomizingAnimInstance_OnLookAtAlpha::InterpSpeed' has a wrong offset!");

// Function MirMobile.MM_CustomizingAnimInstance.SetActorHiddenInGame
// 0x0001 (0x0001 - 0x0000)
struct MM_CustomizingAnimInstance_SetActorHiddenInGame final
{
public:
	bool                                          bNewHidden;                                        // 0x0000(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(MM_CustomizingAnimInstance_SetActorHiddenInGame) == 0x000001, "Wrong alignment on MM_CustomizingAnimInstance_SetActorHiddenInGame");
static_assert(sizeof(MM_CustomizingAnimInstance_SetActorHiddenInGame) == 0x000001, "Wrong size on MM_CustomizingAnimInstance_SetActorHiddenInGame");
static_assert(offsetof(MM_CustomizingAnimInstance_SetActorHiddenInGame, bNewHidden) == 0x000000, "Member 'MM_CustomizingAnimInstance_SetActorHiddenInGame::bNewHidden' has a wrong offset!");

// Function MirMobile.MM_CustomizingAnimInstance.SetCameraUpdateFlag
// 0x0001 (0x0001 - 0x0000)
struct MM_CustomizingAnimInstance_SetCameraUpdateFlag final
{
public:
	bool                                          bUpdate;                                           // 0x0000(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(MM_CustomizingAnimInstance_SetCameraUpdateFlag) == 0x000001, "Wrong alignment on MM_CustomizingAnimInstance_SetCameraUpdateFlag");
static_assert(sizeof(MM_CustomizingAnimInstance_SetCameraUpdateFlag) == 0x000001, "Wrong size on MM_CustomizingAnimInstance_SetCameraUpdateFlag");
static_assert(offsetof(MM_CustomizingAnimInstance_SetCameraUpdateFlag, bUpdate) == 0x000000, "Member 'MM_CustomizingAnimInstance_SetCameraUpdateFlag::bUpdate' has a wrong offset!");

// Function MirMobile.MM_CustomizingAnimInstance.SetMainState
// 0x0004 (0x0004 - 0x0000)
struct MM_CustomizingAnimInstance_SetMainState final
{
public:
	int32                                         NewMainState;                                      // 0x0000(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(MM_CustomizingAnimInstance_SetMainState) == 0x000004, "Wrong alignment on MM_CustomizingAnimInstance_SetMainState");
static_assert(sizeof(MM_CustomizingAnimInstance_SetMainState) == 0x000004, "Wrong size on MM_CustomizingAnimInstance_SetMainState");
static_assert(offsetof(MM_CustomizingAnimInstance_SetMainState, NewMainState) == 0x000000, "Member 'MM_CustomizingAnimInstance_SetMainState::NewMainState' has a wrong offset!");

// Function MirMobile.MM_CustomizingAnimInstance.SetStiffnessAndDamping_Event
// 0x0028 (0x0028 - 0x0000)
struct MM_CustomizingAnimInstance_SetStiffnessAndDamping_Event final
{
public:
	float                                         Stiffness01;                                       // 0x0000(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         Stiffness02;                                       // 0x0004(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         Stiffness03;                                       // 0x0008(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         Stiffness04;                                       // 0x000C(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         Stiffness05;                                       // 0x0010(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         Damping01;                                         // 0x0014(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         Damping02;                                         // 0x0018(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         Damping03;                                         // 0x001C(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         Damping04;                                         // 0x0020(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         Damping05;                                         // 0x0024(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(MM_CustomizingAnimInstance_SetStiffnessAndDamping_Event) == 0x000004, "Wrong alignment on MM_CustomizingAnimInstance_SetStiffnessAndDamping_Event");
static_assert(sizeof(MM_CustomizingAnimInstance_SetStiffnessAndDamping_Event) == 0x000028, "Wrong size on MM_CustomizingAnimInstance_SetStiffnessAndDamping_Event");
static_assert(offsetof(MM_CustomizingAnimInstance_SetStiffnessAndDamping_Event, Stiffness01) == 0x000000, "Member 'MM_CustomizingAnimInstance_SetStiffnessAndDamping_Event::Stiffness01' has a wrong offset!");
static_assert(offsetof(MM_CustomizingAnimInstance_SetStiffnessAndDamping_Event, Stiffness02) == 0x000004, "Member 'MM_CustomizingAnimInstance_SetStiffnessAndDamping_Event::Stiffness02' has a wrong offset!");
static_assert(offsetof(MM_CustomizingAnimInstance_SetStiffnessAndDamping_Event, Stiffness03) == 0x000008, "Member 'MM_CustomizingAnimInstance_SetStiffnessAndDamping_Event::Stiffness03' has a wrong offset!");
static_assert(offsetof(MM_CustomizingAnimInstance_SetStiffnessAndDamping_Event, Stiffness04) == 0x00000C, "Member 'MM_CustomizingAnimInstance_SetStiffnessAndDamping_Event::Stiffness04' has a wrong offset!");
static_assert(offsetof(MM_CustomizingAnimInstance_SetStiffnessAndDamping_Event, Stiffness05) == 0x000010, "Member 'MM_CustomizingAnimInstance_SetStiffnessAndDamping_Event::Stiffness05' has a wrong offset!");
static_assert(offsetof(MM_CustomizingAnimInstance_SetStiffnessAndDamping_Event, Damping01) == 0x000014, "Member 'MM_CustomizingAnimInstance_SetStiffnessAndDamping_Event::Damping01' has a wrong offset!");
static_assert(offsetof(MM_CustomizingAnimInstance_SetStiffnessAndDamping_Event, Damping02) == 0x000018, "Member 'MM_CustomizingAnimInstance_SetStiffnessAndDamping_Event::Damping02' has a wrong offset!");
static_assert(offsetof(MM_CustomizingAnimInstance_SetStiffnessAndDamping_Event, Damping03) == 0x00001C, "Member 'MM_CustomizingAnimInstance_SetStiffnessAndDamping_Event::Damping03' has a wrong offset!");
static_assert(offsetof(MM_CustomizingAnimInstance_SetStiffnessAndDamping_Event, Damping04) == 0x000020, "Member 'MM_CustomizingAnimInstance_SetStiffnessAndDamping_Event::Damping04' has a wrong offset!");
static_assert(offsetof(MM_CustomizingAnimInstance_SetStiffnessAndDamping_Event, Damping05) == 0x000024, "Member 'MM_CustomizingAnimInstance_SetStiffnessAndDamping_Event::Damping05' has a wrong offset!");

// Function MirMobile.MM_CustomizingAnimInstance.SetStiffnessAndDampingData
// 0x0028 (0x0028 - 0x0000)
struct MM_CustomizingAnimInstance_SetStiffnessAndDampingData final
{
public:
	float                                         Stiffness01;                                       // 0x0000(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         Stiffness02;                                       // 0x0004(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         Stiffness03;                                       // 0x0008(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         Stiffness04;                                       // 0x000C(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         Stiffness05;                                       // 0x0010(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         Damping01;                                         // 0x0014(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         Damping02;                                         // 0x0018(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         Damping03;                                         // 0x001C(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         Damping04;                                         // 0x0020(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         Damping05;                                         // 0x0024(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(MM_CustomizingAnimInstance_SetStiffnessAndDampingData) == 0x000004, "Wrong alignment on MM_CustomizingAnimInstance_SetStiffnessAndDampingData");
static_assert(sizeof(MM_CustomizingAnimInstance_SetStiffnessAndDampingData) == 0x000028, "Wrong size on MM_CustomizingAnimInstance_SetStiffnessAndDampingData");
static_assert(offsetof(MM_CustomizingAnimInstance_SetStiffnessAndDampingData, Stiffness01) == 0x000000, "Member 'MM_CustomizingAnimInstance_SetStiffnessAndDampingData::Stiffness01' has a wrong offset!");
static_assert(offsetof(MM_CustomizingAnimInstance_SetStiffnessAndDampingData, Stiffness02) == 0x000004, "Member 'MM_CustomizingAnimInstance_SetStiffnessAndDampingData::Stiffness02' has a wrong offset!");
static_assert(offsetof(MM_CustomizingAnimInstance_SetStiffnessAndDampingData, Stiffness03) == 0x000008, "Member 'MM_CustomizingAnimInstance_SetStiffnessAndDampingData::Stiffness03' has a wrong offset!");
static_assert(offsetof(MM_CustomizingAnimInstance_SetStiffnessAndDampingData, Stiffness04) == 0x00000C, "Member 'MM_CustomizingAnimInstance_SetStiffnessAndDampingData::Stiffness04' has a wrong offset!");
static_assert(offsetof(MM_CustomizingAnimInstance_SetStiffnessAndDampingData, Stiffness05) == 0x000010, "Member 'MM_CustomizingAnimInstance_SetStiffnessAndDampingData::Stiffness05' has a wrong offset!");
static_assert(offsetof(MM_CustomizingAnimInstance_SetStiffnessAndDampingData, Damping01) == 0x000014, "Member 'MM_CustomizingAnimInstance_SetStiffnessAndDampingData::Damping01' has a wrong offset!");
static_assert(offsetof(MM_CustomizingAnimInstance_SetStiffnessAndDampingData, Damping02) == 0x000018, "Member 'MM_CustomizingAnimInstance_SetStiffnessAndDampingData::Damping02' has a wrong offset!");
static_assert(offsetof(MM_CustomizingAnimInstance_SetStiffnessAndDampingData, Damping03) == 0x00001C, "Member 'MM_CustomizingAnimInstance_SetStiffnessAndDampingData::Damping03' has a wrong offset!");
static_assert(offsetof(MM_CustomizingAnimInstance_SetStiffnessAndDampingData, Damping04) == 0x000020, "Member 'MM_CustomizingAnimInstance_SetStiffnessAndDampingData::Damping04' has a wrong offset!");
static_assert(offsetof(MM_CustomizingAnimInstance_SetStiffnessAndDampingData, Damping05) == 0x000024, "Member 'MM_CustomizingAnimInstance_SetStiffnessAndDampingData::Damping05' has a wrong offset!");

// Function MirMobile.MM_CustomizingScreenShot.CreateSubButtonEvent
// 0x0004 (0x0004 - 0x0000)
struct MM_CustomizingScreenShot_CreateSubButtonEvent final
{
public:
	int32                                         CreateCount;                                       // 0x0000(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(MM_CustomizingScreenShot_CreateSubButtonEvent) == 0x000004, "Wrong alignment on MM_CustomizingScreenShot_CreateSubButtonEvent");
static_assert(sizeof(MM_CustomizingScreenShot_CreateSubButtonEvent) == 0x000004, "Wrong size on MM_CustomizingScreenShot_CreateSubButtonEvent");
static_assert(offsetof(MM_CustomizingScreenShot_CreateSubButtonEvent, CreateCount) == 0x000000, "Member 'MM_CustomizingScreenShot_CreateSubButtonEvent::CreateCount' has a wrong offset!");

// Function MirMobile.MM_CustomizingScreenShot.OnCameraMoveButton
// 0x0002 (0x0002 - 0x0000)
struct MM_CustomizingScreenShot_OnCameraMoveButton final
{
public:
	EPhotoModeCameraMoveButton                    ClickButton;                                       // 0x0000(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bPressed;                                          // 0x0001(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(MM_CustomizingScreenShot_OnCameraMoveButton) == 0x000001, "Wrong alignment on MM_CustomizingScreenShot_OnCameraMoveButton");
static_assert(sizeof(MM_CustomizingScreenShot_OnCameraMoveButton) == 0x000002, "Wrong size on MM_CustomizingScreenShot_OnCameraMoveButton");
static_assert(offsetof(MM_CustomizingScreenShot_OnCameraMoveButton, ClickButton) == 0x000000, "Member 'MM_CustomizingScreenShot_OnCameraMoveButton::ClickButton' has a wrong offset!");
static_assert(offsetof(MM_CustomizingScreenShot_OnCameraMoveButton, bPressed) == 0x000001, "Member 'MM_CustomizingScreenShot_OnCameraMoveButton::bPressed' has a wrong offset!");

// Function MirMobile.MM_CustomizingScreenShot.OnChangedSliderValue
// 0x0004 (0x0004 - 0x0000)
struct MM_CustomizingScreenShot_OnChangedSliderValue final
{
public:
	float                                         SliderValue;                                       // 0x0000(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(MM_CustomizingScreenShot_OnChangedSliderValue) == 0x000004, "Wrong alignment on MM_CustomizingScreenShot_OnChangedSliderValue");
static_assert(sizeof(MM_CustomizingScreenShot_OnChangedSliderValue) == 0x000004, "Wrong size on MM_CustomizingScreenShot_OnChangedSliderValue");
static_assert(offsetof(MM_CustomizingScreenShot_OnChangedSliderValue, SliderValue) == 0x000000, "Member 'MM_CustomizingScreenShot_OnChangedSliderValue::SliderValue' has a wrong offset!");

// Function MirMobile.MM_CustomizingScreenShot.OnCheckeOption
// 0x0002 (0x0002 - 0x0000)
struct MM_CustomizingScreenShot_OnCheckeOption final
{
public:
	EPhotoModeOptionType                          CheckOption;                                       // 0x0000(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bChecked;                                          // 0x0001(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(MM_CustomizingScreenShot_OnCheckeOption) == 0x000001, "Wrong alignment on MM_CustomizingScreenShot_OnCheckeOption");
static_assert(sizeof(MM_CustomizingScreenShot_OnCheckeOption) == 0x000002, "Wrong size on MM_CustomizingScreenShot_OnCheckeOption");
static_assert(offsetof(MM_CustomizingScreenShot_OnCheckeOption, CheckOption) == 0x000000, "Member 'MM_CustomizingScreenShot_OnCheckeOption::CheckOption' has a wrong offset!");
static_assert(offsetof(MM_CustomizingScreenShot_OnCheckeOption, bChecked) == 0x000001, "Member 'MM_CustomizingScreenShot_OnCheckeOption::bChecked' has a wrong offset!");

// Function MirMobile.MM_CustomizingScreenShot.OnClickMainButton
// 0x0002 (0x0002 - 0x0000)
struct MM_CustomizingScreenShot_OnClickMainButton final
{
public:
	EPhotoModeType                                ClickPhotoModeState;                               // 0x0000(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bChecked;                                          // 0x0001(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(MM_CustomizingScreenShot_OnClickMainButton) == 0x000001, "Wrong alignment on MM_CustomizingScreenShot_OnClickMainButton");
static_assert(sizeof(MM_CustomizingScreenShot_OnClickMainButton) == 0x000002, "Wrong size on MM_CustomizingScreenShot_OnClickMainButton");
static_assert(offsetof(MM_CustomizingScreenShot_OnClickMainButton, ClickPhotoModeState) == 0x000000, "Member 'MM_CustomizingScreenShot_OnClickMainButton::ClickPhotoModeState' has a wrong offset!");
static_assert(offsetof(MM_CustomizingScreenShot_OnClickMainButton, bChecked) == 0x000001, "Member 'MM_CustomizingScreenShot_OnClickMainButton::bChecked' has a wrong offset!");

// Function MirMobile.MM_CustomizingScreenShot.OnClickOptionSave
// 0x0001 (0x0001 - 0x0000)
struct MM_CustomizingScreenShot_OnClickOptionSave final
{
public:
	bool                                          bSave;                                             // 0x0000(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(MM_CustomizingScreenShot_OnClickOptionSave) == 0x000001, "Wrong alignment on MM_CustomizingScreenShot_OnClickOptionSave");
static_assert(sizeof(MM_CustomizingScreenShot_OnClickOptionSave) == 0x000001, "Wrong size on MM_CustomizingScreenShot_OnClickOptionSave");
static_assert(offsetof(MM_CustomizingScreenShot_OnClickOptionSave, bSave) == 0x000000, "Member 'MM_CustomizingScreenShot_OnClickOptionSave::bSave' has a wrong offset!");

// Function MirMobile.MM_CustomizingScreenShot.OnClickSubButton
// 0x0008 (0x0008 - 0x0000)
struct MM_CustomizingScreenShot_OnClickSubButton final
{
public:
	EPhotoModeType                                PhotoModeState;                                    // 0x0000(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1[0x3];                                        // 0x0001(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         SlotIndex;                                         // 0x0004(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(MM_CustomizingScreenShot_OnClickSubButton) == 0x000004, "Wrong alignment on MM_CustomizingScreenShot_OnClickSubButton");
static_assert(sizeof(MM_CustomizingScreenShot_OnClickSubButton) == 0x000008, "Wrong size on MM_CustomizingScreenShot_OnClickSubButton");
static_assert(offsetof(MM_CustomizingScreenShot_OnClickSubButton, PhotoModeState) == 0x000000, "Member 'MM_CustomizingScreenShot_OnClickSubButton::PhotoModeState' has a wrong offset!");
static_assert(offsetof(MM_CustomizingScreenShot_OnClickSubButton, SlotIndex) == 0x000004, "Member 'MM_CustomizingScreenShot_OnClickSubButton::SlotIndex' has a wrong offset!");

// Function MirMobile.MM_CustomizingScreenShot.ScreenShotCaptured
// 0x0018 (0x0018 - 0x0000)
struct MM_CustomizingScreenShot_ScreenShotCaptured final
{
public:
	int32                                         ScreenWidth;                                       // 0x0000(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         ScreenHeight;                                      // 0x0004(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<struct FColor>                         ScreenColors;                                      // 0x0008(0x0010)(ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, NativeAccessSpecifierPublic)
};
static_assert(alignof(MM_CustomizingScreenShot_ScreenShotCaptured) == 0x000008, "Wrong alignment on MM_CustomizingScreenShot_ScreenShotCaptured");
static_assert(sizeof(MM_CustomizingScreenShot_ScreenShotCaptured) == 0x000018, "Wrong size on MM_CustomizingScreenShot_ScreenShotCaptured");
static_assert(offsetof(MM_CustomizingScreenShot_ScreenShotCaptured, ScreenWidth) == 0x000000, "Member 'MM_CustomizingScreenShot_ScreenShotCaptured::ScreenWidth' has a wrong offset!");
static_assert(offsetof(MM_CustomizingScreenShot_ScreenShotCaptured, ScreenHeight) == 0x000004, "Member 'MM_CustomizingScreenShot_ScreenShotCaptured::ScreenHeight' has a wrong offset!");
static_assert(offsetof(MM_CustomizingScreenShot_ScreenShotCaptured, ScreenColors) == 0x000008, "Member 'MM_CustomizingScreenShot_ScreenShotCaptured::ScreenColors' has a wrong offset!");

// Function MirMobile.MM_CustomizingScreenShot.SetFilterSubButtonEvent
// 0x0020 (0x0020 - 0x0000)
struct MM_CustomizingScreenShot_SetFilterSubButtonEvent final
{
public:
	TArray<struct FColor>                         ColorList;                                         // 0x0000(0x0010)(ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, NativeAccessSpecifierPublic)
	TArray<class FText>                           StringList;                                        // 0x0010(0x0010)(ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, NativeAccessSpecifierPublic)
};
static_assert(alignof(MM_CustomizingScreenShot_SetFilterSubButtonEvent) == 0x000008, "Wrong alignment on MM_CustomizingScreenShot_SetFilterSubButtonEvent");
static_assert(sizeof(MM_CustomizingScreenShot_SetFilterSubButtonEvent) == 0x000020, "Wrong size on MM_CustomizingScreenShot_SetFilterSubButtonEvent");
static_assert(offsetof(MM_CustomizingScreenShot_SetFilterSubButtonEvent, ColorList) == 0x000000, "Member 'MM_CustomizingScreenShot_SetFilterSubButtonEvent::ColorList' has a wrong offset!");
static_assert(offsetof(MM_CustomizingScreenShot_SetFilterSubButtonEvent, StringList) == 0x000010, "Member 'MM_CustomizingScreenShot_SetFilterSubButtonEvent::StringList' has a wrong offset!");

// Function MirMobile.MM_CustomizingScreenShot.SetOptionDataEvent
// 0x0050 (0x0050 - 0x0000)
struct MM_CustomizingScreenShot_SetOptionDataEvent final
{
public:
	TMap<EPhotoModeOptionType, struct FPhotoMode_Option> MapOption;                                         // 0x0000(0x0050)(ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, NativeAccessSpecifierPublic)
};
static_assert(alignof(MM_CustomizingScreenShot_SetOptionDataEvent) == 0x000008, "Wrong alignment on MM_CustomizingScreenShot_SetOptionDataEvent");
static_assert(sizeof(MM_CustomizingScreenShot_SetOptionDataEvent) == 0x000050, "Wrong size on MM_CustomizingScreenShot_SetOptionDataEvent");
static_assert(offsetof(MM_CustomizingScreenShot_SetOptionDataEvent, MapOption) == 0x000000, "Member 'MM_CustomizingScreenShot_SetOptionDataEvent::MapOption' has a wrong offset!");

// Function MirMobile.MM_CustomizingScreenShot.SetPoseSubButtonEvent
// 0x0010 (0x0010 - 0x0000)
struct MM_CustomizingScreenShot_SetPoseSubButtonEvent final
{
public:
	TArray<class FString>                         IconPathList;                                      // 0x0000(0x0010)(ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, NativeAccessSpecifierPublic)
};
static_assert(alignof(MM_CustomizingScreenShot_SetPoseSubButtonEvent) == 0x000008, "Wrong alignment on MM_CustomizingScreenShot_SetPoseSubButtonEvent");
static_assert(sizeof(MM_CustomizingScreenShot_SetPoseSubButtonEvent) == 0x000010, "Wrong size on MM_CustomizingScreenShot_SetPoseSubButtonEvent");
static_assert(offsetof(MM_CustomizingScreenShot_SetPoseSubButtonEvent, IconPathList) == 0x000000, "Member 'MM_CustomizingScreenShot_SetPoseSubButtonEvent::IconPathList' has a wrong offset!");

// Function MirMobile.MM_CustomizingScreenShot.SetSliderDataEvent
// 0x0038 (0x0038 - 0x0000)
struct MM_CustomizingScreenShot_SetSliderDataEvent final
{
public:
	class FText                                   SubTapTitle;                                       // 0x0000(0x0018)(ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
	class FText                                   Text_SliderValue;                                  // 0x0018(0x0018)(ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
	float                                         SlideValue;                                        // 0x0030(0x0004)(ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_34[0x4];                                       // 0x0034(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(MM_CustomizingScreenShot_SetSliderDataEvent) == 0x000008, "Wrong alignment on MM_CustomizingScreenShot_SetSliderDataEvent");
static_assert(sizeof(MM_CustomizingScreenShot_SetSliderDataEvent) == 0x000038, "Wrong size on MM_CustomizingScreenShot_SetSliderDataEvent");
static_assert(offsetof(MM_CustomizingScreenShot_SetSliderDataEvent, SubTapTitle) == 0x000000, "Member 'MM_CustomizingScreenShot_SetSliderDataEvent::SubTapTitle' has a wrong offset!");
static_assert(offsetof(MM_CustomizingScreenShot_SetSliderDataEvent, Text_SliderValue) == 0x000018, "Member 'MM_CustomizingScreenShot_SetSliderDataEvent::Text_SliderValue' has a wrong offset!");
static_assert(offsetof(MM_CustomizingScreenShot_SetSliderDataEvent, SlideValue) == 0x000030, "Member 'MM_CustomizingScreenShot_SetSliderDataEvent::SlideValue' has a wrong offset!");

// Function MirMobile.MM_CustomizingScreenShot.ShowLogoImageEvent
// 0x0001 (0x0001 - 0x0000)
struct MM_CustomizingScreenShot_ShowLogoImageEvent final
{
public:
	bool                                          bShow;                                             // 0x0000(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(MM_CustomizingScreenShot_ShowLogoImageEvent) == 0x000001, "Wrong alignment on MM_CustomizingScreenShot_ShowLogoImageEvent");
static_assert(sizeof(MM_CustomizingScreenShot_ShowLogoImageEvent) == 0x000001, "Wrong size on MM_CustomizingScreenShot_ShowLogoImageEvent");
static_assert(offsetof(MM_CustomizingScreenShot_ShowLogoImageEvent, bShow) == 0x000000, "Member 'MM_CustomizingScreenShot_ShowLogoImageEvent::bShow' has a wrong offset!");

// Function MirMobile.MM_CustomizingScreenShot.ShowSlideControlEvent
// 0x0001 (0x0001 - 0x0000)
struct MM_CustomizingScreenShot_ShowSlideControlEvent final
{
public:
	bool                                          bShow;                                             // 0x0000(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(MM_CustomizingScreenShot_ShowSlideControlEvent) == 0x000001, "Wrong alignment on MM_CustomizingScreenShot_ShowSlideControlEvent");
static_assert(sizeof(MM_CustomizingScreenShot_ShowSlideControlEvent) == 0x000001, "Wrong size on MM_CustomizingScreenShot_ShowSlideControlEvent");
static_assert(offsetof(MM_CustomizingScreenShot_ShowSlideControlEvent, bShow) == 0x000000, "Member 'MM_CustomizingScreenShot_ShowSlideControlEvent::bShow' has a wrong offset!");

// Function MirMobile.MM_CustomizingScreenShot.ShowSubButton
// 0x0028 (0x0028 - 0x0000)
struct MM_CustomizingScreenShot_ShowSubButton final
{
public:
	int32                                         ButtonLength;                                      // 0x0000(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_4[0x4];                                        // 0x0004(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<class UWidget*>                        ButtonArray;                                       // 0x0008(0x0010)(Parm, ZeroConstructor, ContainsInstancedReference, NativeAccessSpecifierPublic)
	TArray<class UWidget*>                        ReturnValue;                                       // 0x0018(0x0010)(ExportObject, Parm, OutParm, ZeroConstructor, ReturnParm, ContainsInstancedReference, NativeAccessSpecifierPublic)
};
static_assert(alignof(MM_CustomizingScreenShot_ShowSubButton) == 0x000008, "Wrong alignment on MM_CustomizingScreenShot_ShowSubButton");
static_assert(sizeof(MM_CustomizingScreenShot_ShowSubButton) == 0x000028, "Wrong size on MM_CustomizingScreenShot_ShowSubButton");
static_assert(offsetof(MM_CustomizingScreenShot_ShowSubButton, ButtonLength) == 0x000000, "Member 'MM_CustomizingScreenShot_ShowSubButton::ButtonLength' has a wrong offset!");
static_assert(offsetof(MM_CustomizingScreenShot_ShowSubButton, ButtonArray) == 0x000008, "Member 'MM_CustomizingScreenShot_ShowSubButton::ButtonArray' has a wrong offset!");
static_assert(offsetof(MM_CustomizingScreenShot_ShowSubButton, ReturnValue) == 0x000018, "Member 'MM_CustomizingScreenShot_ShowSubButton::ReturnValue' has a wrong offset!");

// Function MirMobile.MM_CustomizingScreenShot.ShowSubButtonEvent
// 0x0028 (0x0028 - 0x0000)
struct MM_CustomizingScreenShot_ShowSubButtonEvent final
{
public:
	class FText                                   SubTapTitle;                                       // 0x0000(0x0018)(ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
	EPhotoModeType                                PhotoModeState;                                    // 0x0018(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_19[0x3];                                       // 0x0019(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         SubButtonCount;                                    // 0x001C(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         SelectedButtonIndex;                               // 0x0020(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_24[0x4];                                       // 0x0024(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(MM_CustomizingScreenShot_ShowSubButtonEvent) == 0x000008, "Wrong alignment on MM_CustomizingScreenShot_ShowSubButtonEvent");
static_assert(sizeof(MM_CustomizingScreenShot_ShowSubButtonEvent) == 0x000028, "Wrong size on MM_CustomizingScreenShot_ShowSubButtonEvent");
static_assert(offsetof(MM_CustomizingScreenShot_ShowSubButtonEvent, SubTapTitle) == 0x000000, "Member 'MM_CustomizingScreenShot_ShowSubButtonEvent::SubTapTitle' has a wrong offset!");
static_assert(offsetof(MM_CustomizingScreenShot_ShowSubButtonEvent, PhotoModeState) == 0x000018, "Member 'MM_CustomizingScreenShot_ShowSubButtonEvent::PhotoModeState' has a wrong offset!");
static_assert(offsetof(MM_CustomizingScreenShot_ShowSubButtonEvent, SubButtonCount) == 0x00001C, "Member 'MM_CustomizingScreenShot_ShowSubButtonEvent::SubButtonCount' has a wrong offset!");
static_assert(offsetof(MM_CustomizingScreenShot_ShowSubButtonEvent, SelectedButtonIndex) == 0x000020, "Member 'MM_CustomizingScreenShot_ShowSubButtonEvent::SelectedButtonIndex' has a wrong offset!");

// Function MirMobile.MM_CustomizingScreenShot.ShowSubTapEvent
// 0x0001 (0x0001 - 0x0000)
struct MM_CustomizingScreenShot_ShowSubTapEvent final
{
public:
	bool                                          bShow;                                             // 0x0000(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(MM_CustomizingScreenShot_ShowSubTapEvent) == 0x000001, "Wrong alignment on MM_CustomizingScreenShot_ShowSubTapEvent");
static_assert(sizeof(MM_CustomizingScreenShot_ShowSubTapEvent) == 0x000001, "Wrong size on MM_CustomizingScreenShot_ShowSubTapEvent");
static_assert(offsetof(MM_CustomizingScreenShot_ShowSubTapEvent, bShow) == 0x000000, "Member 'MM_CustomizingScreenShot_ShowSubTapEvent::bShow' has a wrong offset!");

// Function MirMobile.MM_CustomizingScreenShot.UpdateSliderValueEvent
// 0x0018 (0x0018 - 0x0000)
struct MM_CustomizingScreenShot_UpdateSliderValueEvent final
{
public:
	class FText                                   Text_SliderValue;                                  // 0x0000(0x0018)(ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
};
static_assert(alignof(MM_CustomizingScreenShot_UpdateSliderValueEvent) == 0x000008, "Wrong alignment on MM_CustomizingScreenShot_UpdateSliderValueEvent");
static_assert(sizeof(MM_CustomizingScreenShot_UpdateSliderValueEvent) == 0x000018, "Wrong size on MM_CustomizingScreenShot_UpdateSliderValueEvent");
static_assert(offsetof(MM_CustomizingScreenShot_UpdateSliderValueEvent, Text_SliderValue) == 0x000000, "Member 'MM_CustomizingScreenShot_UpdateSliderValueEvent::Text_SliderValue' has a wrong offset!");

// Function MirMobile.MM_CustomTitleSetting.OnChangeText
// 0x0018 (0x0018 - 0x0000)
struct MM_CustomTitleSetting_OnChangeText final
{
public:
	class FText                                   Text;                                              // 0x0000(0x0018)(ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
};
static_assert(alignof(MM_CustomTitleSetting_OnChangeText) == 0x000008, "Wrong alignment on MM_CustomTitleSetting_OnChangeText");
static_assert(sizeof(MM_CustomTitleSetting_OnChangeText) == 0x000018, "Wrong size on MM_CustomTitleSetting_OnChangeText");
static_assert(offsetof(MM_CustomTitleSetting_OnChangeText, Text) == 0x000000, "Member 'MM_CustomTitleSetting_OnChangeText::Text' has a wrong offset!");

// Function MirMobile.MM_CustomTitleSetting.OnTextCommitted
// 0x0020 (0x0020 - 0x0000)
struct MM_CustomTitleSetting_OnTextCommitted final
{
public:
	class FText                                   Text;                                              // 0x0000(0x0018)(ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
	ETextCommit                                   CommitMethod;                                      // 0x0018(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_19[0x7];                                       // 0x0019(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(MM_CustomTitleSetting_OnTextCommitted) == 0x000008, "Wrong alignment on MM_CustomTitleSetting_OnTextCommitted");
static_assert(sizeof(MM_CustomTitleSetting_OnTextCommitted) == 0x000020, "Wrong size on MM_CustomTitleSetting_OnTextCommitted");
static_assert(offsetof(MM_CustomTitleSetting_OnTextCommitted, Text) == 0x000000, "Member 'MM_CustomTitleSetting_OnTextCommitted::Text' has a wrong offset!");
static_assert(offsetof(MM_CustomTitleSetting_OnTextCommitted, CommitMethod) == 0x000018, "Member 'MM_CustomTitleSetting_OnTextCommitted::CommitMethod' has a wrong offset!");

// Function MirMobile.MM_CutscenePreviewGameMode.GetMainQusetPhasingMission
// 0x0038 (0x0038 - 0x0000)
struct MM_CutscenePreviewGameMode_GetMainQusetPhasingMission final
{
public:
	class UDataTable*                             PQuestData;                                        // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   QuestRowName;                                      // 0x0008(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bPhasingMission;                                   // 0x0010(0x0001)(Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_11[0x7];                                       // 0x0011(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<int32>                                 CinematicIDArray;                                  // 0x0018(0x0010)(Parm, OutParm, ZeroConstructor, NativeAccessSpecifierPublic)
	TArray<int32>                                 SequenceIDArray;                                   // 0x0028(0x0010)(Parm, OutParm, ZeroConstructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(MM_CutscenePreviewGameMode_GetMainQusetPhasingMission) == 0x000008, "Wrong alignment on MM_CutscenePreviewGameMode_GetMainQusetPhasingMission");
static_assert(sizeof(MM_CutscenePreviewGameMode_GetMainQusetPhasingMission) == 0x000038, "Wrong size on MM_CutscenePreviewGameMode_GetMainQusetPhasingMission");
static_assert(offsetof(MM_CutscenePreviewGameMode_GetMainQusetPhasingMission, PQuestData) == 0x000000, "Member 'MM_CutscenePreviewGameMode_GetMainQusetPhasingMission::PQuestData' has a wrong offset!");
static_assert(offsetof(MM_CutscenePreviewGameMode_GetMainQusetPhasingMission, QuestRowName) == 0x000008, "Member 'MM_CutscenePreviewGameMode_GetMainQusetPhasingMission::QuestRowName' has a wrong offset!");
static_assert(offsetof(MM_CutscenePreviewGameMode_GetMainQusetPhasingMission, bPhasingMission) == 0x000010, "Member 'MM_CutscenePreviewGameMode_GetMainQusetPhasingMission::bPhasingMission' has a wrong offset!");
static_assert(offsetof(MM_CutscenePreviewGameMode_GetMainQusetPhasingMission, CinematicIDArray) == 0x000018, "Member 'MM_CutscenePreviewGameMode_GetMainQusetPhasingMission::CinematicIDArray' has a wrong offset!");
static_assert(offsetof(MM_CutscenePreviewGameMode_GetMainQusetPhasingMission, SequenceIDArray) == 0x000028, "Member 'MM_CutscenePreviewGameMode_GetMainQusetPhasingMission::SequenceIDArray' has a wrong offset!");

// Function MirMobile.MM_CutscenePreviewGameMode.GetMissionCinematicData
// 0x0040 (0x0040 - 0x0000)
struct MM_CutscenePreviewGameMode_GetMissionCinematicData final
{
public:
	TArray<int32>                                 QuestIDArray;                                      // 0x0000(0x0010)(Parm, OutParm, ZeroConstructor, NativeAccessSpecifierPublic)
	TArray<class FString>                         QuestTitleArray;                                   // 0x0010(0x0010)(Parm, OutParm, ZeroConstructor, NativeAccessSpecifierPublic)
	TArray<int32>                                 StageIDArray;                                      // 0x0020(0x0010)(Parm, OutParm, ZeroConstructor, NativeAccessSpecifierPublic)
	TArray<int32>                                 CinematicIDArray;                                  // 0x0030(0x0010)(Parm, OutParm, ZeroConstructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(MM_CutscenePreviewGameMode_GetMissionCinematicData) == 0x000008, "Wrong alignment on MM_CutscenePreviewGameMode_GetMissionCinematicData");
static_assert(sizeof(MM_CutscenePreviewGameMode_GetMissionCinematicData) == 0x000040, "Wrong size on MM_CutscenePreviewGameMode_GetMissionCinematicData");
static_assert(offsetof(MM_CutscenePreviewGameMode_GetMissionCinematicData, QuestIDArray) == 0x000000, "Member 'MM_CutscenePreviewGameMode_GetMissionCinematicData::QuestIDArray' has a wrong offset!");
static_assert(offsetof(MM_CutscenePreviewGameMode_GetMissionCinematicData, QuestTitleArray) == 0x000010, "Member 'MM_CutscenePreviewGameMode_GetMissionCinematicData::QuestTitleArray' has a wrong offset!");
static_assert(offsetof(MM_CutscenePreviewGameMode_GetMissionCinematicData, StageIDArray) == 0x000020, "Member 'MM_CutscenePreviewGameMode_GetMissionCinematicData::StageIDArray' has a wrong offset!");
static_assert(offsetof(MM_CutscenePreviewGameMode_GetMissionCinematicData, CinematicIDArray) == 0x000030, "Member 'MM_CutscenePreviewGameMode_GetMissionCinematicData::CinematicIDArray' has a wrong offset!");

// Function MirMobile.MM_CutscenePreviewGameMode.GetRelationCinematicData
// 0x0040 (0x0040 - 0x0000)
struct MM_CutscenePreviewGameMode_GetRelationCinematicData final
{
public:
	TArray<int32>                                 QuestIDArray;                                      // 0x0000(0x0010)(Parm, OutParm, ZeroConstructor, NativeAccessSpecifierPublic)
	TArray<class FString>                         QuestTitleArray;                                   // 0x0010(0x0010)(Parm, OutParm, ZeroConstructor, NativeAccessSpecifierPublic)
	TArray<int32>                                 StageIDArray;                                      // 0x0020(0x0010)(Parm, OutParm, ZeroConstructor, NativeAccessSpecifierPublic)
	TArray<int32>                                 CinematicIDArray;                                  // 0x0030(0x0010)(Parm, OutParm, ZeroConstructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(MM_CutscenePreviewGameMode_GetRelationCinematicData) == 0x000008, "Wrong alignment on MM_CutscenePreviewGameMode_GetRelationCinematicData");
static_assert(sizeof(MM_CutscenePreviewGameMode_GetRelationCinematicData) == 0x000040, "Wrong size on MM_CutscenePreviewGameMode_GetRelationCinematicData");
static_assert(offsetof(MM_CutscenePreviewGameMode_GetRelationCinematicData, QuestIDArray) == 0x000000, "Member 'MM_CutscenePreviewGameMode_GetRelationCinematicData::QuestIDArray' has a wrong offset!");
static_assert(offsetof(MM_CutscenePreviewGameMode_GetRelationCinematicData, QuestTitleArray) == 0x000010, "Member 'MM_CutscenePreviewGameMode_GetRelationCinematicData::QuestTitleArray' has a wrong offset!");
static_assert(offsetof(MM_CutscenePreviewGameMode_GetRelationCinematicData, StageIDArray) == 0x000020, "Member 'MM_CutscenePreviewGameMode_GetRelationCinematicData::StageIDArray' has a wrong offset!");
static_assert(offsetof(MM_CutscenePreviewGameMode_GetRelationCinematicData, CinematicIDArray) == 0x000030, "Member 'MM_CutscenePreviewGameMode_GetRelationCinematicData::CinematicIDArray' has a wrong offset!");

// Function MirMobile.MM_CutscenePreviewGameMode.GetRequestQuestCinematicData
// 0x0040 (0x0040 - 0x0000)
struct MM_CutscenePreviewGameMode_GetRequestQuestCinematicData final
{
public:
	TArray<int32>                                 QuestIDArray;                                      // 0x0000(0x0010)(Parm, OutParm, ZeroConstructor, NativeAccessSpecifierPublic)
	TArray<class FString>                         QuestTitleArray;                                   // 0x0010(0x0010)(Parm, OutParm, ZeroConstructor, NativeAccessSpecifierPublic)
	TArray<int32>                                 StageIDArray;                                      // 0x0020(0x0010)(Parm, OutParm, ZeroConstructor, NativeAccessSpecifierPublic)
	TArray<int32>                                 CinematicIDArray;                                  // 0x0030(0x0010)(Parm, OutParm, ZeroConstructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(MM_CutscenePreviewGameMode_GetRequestQuestCinematicData) == 0x000008, "Wrong alignment on MM_CutscenePreviewGameMode_GetRequestQuestCinematicData");
static_assert(sizeof(MM_CutscenePreviewGameMode_GetRequestQuestCinematicData) == 0x000040, "Wrong size on MM_CutscenePreviewGameMode_GetRequestQuestCinematicData");
static_assert(offsetof(MM_CutscenePreviewGameMode_GetRequestQuestCinematicData, QuestIDArray) == 0x000000, "Member 'MM_CutscenePreviewGameMode_GetRequestQuestCinematicData::QuestIDArray' has a wrong offset!");
static_assert(offsetof(MM_CutscenePreviewGameMode_GetRequestQuestCinematicData, QuestTitleArray) == 0x000010, "Member 'MM_CutscenePreviewGameMode_GetRequestQuestCinematicData::QuestTitleArray' has a wrong offset!");
static_assert(offsetof(MM_CutscenePreviewGameMode_GetRequestQuestCinematicData, StageIDArray) == 0x000020, "Member 'MM_CutscenePreviewGameMode_GetRequestQuestCinematicData::StageIDArray' has a wrong offset!");
static_assert(offsetof(MM_CutscenePreviewGameMode_GetRequestQuestCinematicData, CinematicIDArray) == 0x000030, "Member 'MM_CutscenePreviewGameMode_GetRequestQuestCinematicData::CinematicIDArray' has a wrong offset!");

// Function MirMobile.MM_CutscenePreviewGameMode.PlayCutscene
// 0x0008 (0x0008 - 0x0000)
struct MM_CutscenePreviewGameMode_PlayCutscene final
{
public:
	bool                                          bCinematic;                                        // 0x0000(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1[0x3];                                        // 0x0001(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         CutsceneID;                                        // 0x0004(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(MM_CutscenePreviewGameMode_PlayCutscene) == 0x000004, "Wrong alignment on MM_CutscenePreviewGameMode_PlayCutscene");
static_assert(sizeof(MM_CutscenePreviewGameMode_PlayCutscene) == 0x000008, "Wrong size on MM_CutscenePreviewGameMode_PlayCutscene");
static_assert(offsetof(MM_CutscenePreviewGameMode_PlayCutscene, bCinematic) == 0x000000, "Member 'MM_CutscenePreviewGameMode_PlayCutscene::bCinematic' has a wrong offset!");
static_assert(offsetof(MM_CutscenePreviewGameMode_PlayCutscene, CutsceneID) == 0x000004, "Member 'MM_CutscenePreviewGameMode_PlayCutscene::CutsceneID' has a wrong offset!");

// Function MirMobile.MM_CutscenePreviewGameMode.SetTestPlayerClassID
// 0x0004 (0x0004 - 0x0000)
struct MM_CutscenePreviewGameMode_SetTestPlayerClassID final
{
public:
	int32                                         ClassID;                                           // 0x0000(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(MM_CutscenePreviewGameMode_SetTestPlayerClassID) == 0x000004, "Wrong alignment on MM_CutscenePreviewGameMode_SetTestPlayerClassID");
static_assert(sizeof(MM_CutscenePreviewGameMode_SetTestPlayerClassID) == 0x000004, "Wrong size on MM_CutscenePreviewGameMode_SetTestPlayerClassID");
static_assert(offsetof(MM_CutscenePreviewGameMode_SetTestPlayerClassID, ClassID) == 0x000000, "Member 'MM_CutscenePreviewGameMode_SetTestPlayerClassID::ClassID' has a wrong offset!");

// Function MirMobile.MM_Popup_Sabuk_EmperorOrder_Effect.Bind_ClickDelegate
// 0x0010 (0x0010 - 0x0000)
struct MM_Popup_Sabuk_EmperorOrder_Effect_Bind_ClickDelegate final
{
public:
	class UObject*                                PObj;                                              // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   FunctionName;                                      // 0x0008(0x0008)(ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(MM_Popup_Sabuk_EmperorOrder_Effect_Bind_ClickDelegate) == 0x000008, "Wrong alignment on MM_Popup_Sabuk_EmperorOrder_Effect_Bind_ClickDelegate");
static_assert(sizeof(MM_Popup_Sabuk_EmperorOrder_Effect_Bind_ClickDelegate) == 0x000010, "Wrong size on MM_Popup_Sabuk_EmperorOrder_Effect_Bind_ClickDelegate");
static_assert(offsetof(MM_Popup_Sabuk_EmperorOrder_Effect_Bind_ClickDelegate, PObj) == 0x000000, "Member 'MM_Popup_Sabuk_EmperorOrder_Effect_Bind_ClickDelegate::PObj' has a wrong offset!");
static_assert(offsetof(MM_Popup_Sabuk_EmperorOrder_Effect_Bind_ClickDelegate, FunctionName) == 0x000008, "Member 'MM_Popup_Sabuk_EmperorOrder_Effect_Bind_ClickDelegate::FunctionName' has a wrong offset!");

// Function MirMobile.MM_Popup_Sabuk_EmperorOrder_Effect.OnClickSlot
// 0x0004 (0x0004 - 0x0000)
struct MM_Popup_Sabuk_EmperorOrder_Effect_OnClickSlot final
{
public:
	int32                                         IBuffID;                                           // 0x0000(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(MM_Popup_Sabuk_EmperorOrder_Effect_OnClickSlot) == 0x000004, "Wrong alignment on MM_Popup_Sabuk_EmperorOrder_Effect_OnClickSlot");
static_assert(sizeof(MM_Popup_Sabuk_EmperorOrder_Effect_OnClickSlot) == 0x000004, "Wrong size on MM_Popup_Sabuk_EmperorOrder_Effect_OnClickSlot");
static_assert(offsetof(MM_Popup_Sabuk_EmperorOrder_Effect_OnClickSlot, IBuffID) == 0x000000, "Member 'MM_Popup_Sabuk_EmperorOrder_Effect_OnClickSlot::IBuffID' has a wrong offset!");

// Function MirMobile.MM_DailyWork_Progress.OnClickPlusReward1
// 0x0010 (0x0010 - 0x0000)
struct MM_DailyWork_Progress_OnClickPlusReward1 final
{
public:
	int64                                         ItemUID;                                           // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         ItemTID;                                           // 0x0008(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         EquipPosition;                                     // 0x000C(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(MM_DailyWork_Progress_OnClickPlusReward1) == 0x000008, "Wrong alignment on MM_DailyWork_Progress_OnClickPlusReward1");
static_assert(sizeof(MM_DailyWork_Progress_OnClickPlusReward1) == 0x000010, "Wrong size on MM_DailyWork_Progress_OnClickPlusReward1");
static_assert(offsetof(MM_DailyWork_Progress_OnClickPlusReward1, ItemUID) == 0x000000, "Member 'MM_DailyWork_Progress_OnClickPlusReward1::ItemUID' has a wrong offset!");
static_assert(offsetof(MM_DailyWork_Progress_OnClickPlusReward1, ItemTID) == 0x000008, "Member 'MM_DailyWork_Progress_OnClickPlusReward1::ItemTID' has a wrong offset!");
static_assert(offsetof(MM_DailyWork_Progress_OnClickPlusReward1, EquipPosition) == 0x00000C, "Member 'MM_DailyWork_Progress_OnClickPlusReward1::EquipPosition' has a wrong offset!");

// Function MirMobile.MM_DailyWork_Progress.OnClickPlusReward2
// 0x0010 (0x0010 - 0x0000)
struct MM_DailyWork_Progress_OnClickPlusReward2 final
{
public:
	int64                                         ItemUID;                                           // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         ItemTID;                                           // 0x0008(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         EquipPosition;                                     // 0x000C(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(MM_DailyWork_Progress_OnClickPlusReward2) == 0x000008, "Wrong alignment on MM_DailyWork_Progress_OnClickPlusReward2");
static_assert(sizeof(MM_DailyWork_Progress_OnClickPlusReward2) == 0x000010, "Wrong size on MM_DailyWork_Progress_OnClickPlusReward2");
static_assert(offsetof(MM_DailyWork_Progress_OnClickPlusReward2, ItemUID) == 0x000000, "Member 'MM_DailyWork_Progress_OnClickPlusReward2::ItemUID' has a wrong offset!");
static_assert(offsetof(MM_DailyWork_Progress_OnClickPlusReward2, ItemTID) == 0x000008, "Member 'MM_DailyWork_Progress_OnClickPlusReward2::ItemTID' has a wrong offset!");
static_assert(offsetof(MM_DailyWork_Progress_OnClickPlusReward2, EquipPosition) == 0x00000C, "Member 'MM_DailyWork_Progress_OnClickPlusReward2::EquipPosition' has a wrong offset!");

// Function MirMobile.MM_Popup_DominionPrizeSlot.Bind_ClickDelegate
// 0x0018 (0x0018 - 0x0000)
struct MM_Popup_DominionPrizeSlot_Bind_ClickDelegate final
{
public:
	int32                                         IIndex;                                            // 0x0000(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_4[0x4];                                        // 0x0004(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class UObject*                                PObj;                                              // 0x0008(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   FunctionName;                                      // 0x0010(0x0008)(ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(MM_Popup_DominionPrizeSlot_Bind_ClickDelegate) == 0x000008, "Wrong alignment on MM_Popup_DominionPrizeSlot_Bind_ClickDelegate");
static_assert(sizeof(MM_Popup_DominionPrizeSlot_Bind_ClickDelegate) == 0x000018, "Wrong size on MM_Popup_DominionPrizeSlot_Bind_ClickDelegate");
static_assert(offsetof(MM_Popup_DominionPrizeSlot_Bind_ClickDelegate, IIndex) == 0x000000, "Member 'MM_Popup_DominionPrizeSlot_Bind_ClickDelegate::IIndex' has a wrong offset!");
static_assert(offsetof(MM_Popup_DominionPrizeSlot_Bind_ClickDelegate, PObj) == 0x000008, "Member 'MM_Popup_DominionPrizeSlot_Bind_ClickDelegate::PObj' has a wrong offset!");
static_assert(offsetof(MM_Popup_DominionPrizeSlot_Bind_ClickDelegate, FunctionName) == 0x000010, "Member 'MM_Popup_DominionPrizeSlot_Bind_ClickDelegate::FunctionName' has a wrong offset!");

// Function MirMobile.MM_Popup_DominionGuildMemberSlot.Bind_ClickDelegate
// 0x0010 (0x0010 - 0x0000)
struct MM_Popup_DominionGuildMemberSlot_Bind_ClickDelegate final
{
public:
	class UObject*                                PObj;                                              // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   FunctionName;                                      // 0x0008(0x0008)(ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(MM_Popup_DominionGuildMemberSlot_Bind_ClickDelegate) == 0x000008, "Wrong alignment on MM_Popup_DominionGuildMemberSlot_Bind_ClickDelegate");
static_assert(sizeof(MM_Popup_DominionGuildMemberSlot_Bind_ClickDelegate) == 0x000010, "Wrong size on MM_Popup_DominionGuildMemberSlot_Bind_ClickDelegate");
static_assert(offsetof(MM_Popup_DominionGuildMemberSlot_Bind_ClickDelegate, PObj) == 0x000000, "Member 'MM_Popup_DominionGuildMemberSlot_Bind_ClickDelegate::PObj' has a wrong offset!");
static_assert(offsetof(MM_Popup_DominionGuildMemberSlot_Bind_ClickDelegate, FunctionName) == 0x000008, "Member 'MM_Popup_DominionGuildMemberSlot_Bind_ClickDelegate::FunctionName' has a wrong offset!");

// Function MirMobile.MM_DebugWidgetManager.GetMainPCStat
// 0x0040 (0x0040 - 0x0000)
struct MM_DebugWidgetManager_GetMainPCStat final
{
public:
	class FString                                 PhysicalAttack;                                    // 0x0000(0x0010)(Parm, OutParm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 MagicAttack;                                       // 0x0010(0x0010)(Parm, OutParm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 Physicaldefense;                                   // 0x0020(0x0010)(Parm, OutParm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 Magicdefense;                                      // 0x0030(0x0010)(Parm, OutParm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(MM_DebugWidgetManager_GetMainPCStat) == 0x000008, "Wrong alignment on MM_DebugWidgetManager_GetMainPCStat");
static_assert(sizeof(MM_DebugWidgetManager_GetMainPCStat) == 0x000040, "Wrong size on MM_DebugWidgetManager_GetMainPCStat");
static_assert(offsetof(MM_DebugWidgetManager_GetMainPCStat, PhysicalAttack) == 0x000000, "Member 'MM_DebugWidgetManager_GetMainPCStat::PhysicalAttack' has a wrong offset!");
static_assert(offsetof(MM_DebugWidgetManager_GetMainPCStat, MagicAttack) == 0x000010, "Member 'MM_DebugWidgetManager_GetMainPCStat::MagicAttack' has a wrong offset!");
static_assert(offsetof(MM_DebugWidgetManager_GetMainPCStat, Physicaldefense) == 0x000020, "Member 'MM_DebugWidgetManager_GetMainPCStat::Physicaldefense' has a wrong offset!");
static_assert(offsetof(MM_DebugWidgetManager_GetMainPCStat, Magicdefense) == 0x000030, "Member 'MM_DebugWidgetManager_GetMainPCStat::Magicdefense' has a wrong offset!");

// Function MirMobile.MM_DebugWidgetManager.GetMainpcState
// 0x0028 (0x0028 - 0x0000)
struct MM_DebugWidgetManager_GetMainpcState final
{
public:
	struct FVector                                Loc;                                               // 0x0000(0x000C)(Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bRide;                                             // 0x000C(0x0001)(Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_D[0x3];                                        // 0x000D(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	class FString                                 CurrentFSM;                                        // 0x0010(0x0010)(Parm, OutParm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         MoveSpeed;                                         // 0x0020(0x0004)(Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_24[0x4];                                       // 0x0024(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(MM_DebugWidgetManager_GetMainpcState) == 0x000008, "Wrong alignment on MM_DebugWidgetManager_GetMainpcState");
static_assert(sizeof(MM_DebugWidgetManager_GetMainpcState) == 0x000028, "Wrong size on MM_DebugWidgetManager_GetMainpcState");
static_assert(offsetof(MM_DebugWidgetManager_GetMainpcState, Loc) == 0x000000, "Member 'MM_DebugWidgetManager_GetMainpcState::Loc' has a wrong offset!");
static_assert(offsetof(MM_DebugWidgetManager_GetMainpcState, bRide) == 0x00000C, "Member 'MM_DebugWidgetManager_GetMainpcState::bRide' has a wrong offset!");
static_assert(offsetof(MM_DebugWidgetManager_GetMainpcState, CurrentFSM) == 0x000010, "Member 'MM_DebugWidgetManager_GetMainpcState::CurrentFSM' has a wrong offset!");
static_assert(offsetof(MM_DebugWidgetManager_GetMainpcState, MoveSpeed) == 0x000020, "Member 'MM_DebugWidgetManager_GetMainpcState::MoveSpeed' has a wrong offset!");

// Function MirMobile.MM_DebugWidgetManager.GetMonsterSimpleState
// 0x0048 (0x0048 - 0x0000)
struct MM_DebugWidgetManager_GetMonsterSimpleState final
{
public:
	class AMM_Monster*                            PMonster;                                          // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 PhysicalAttack;                                    // 0x0008(0x0010)(Parm, OutParm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 MagicAttack;                                       // 0x0018(0x0010)(Parm, OutParm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 Physicaldefense;                                   // 0x0028(0x0010)(Parm, OutParm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 Magicdefense;                                      // 0x0038(0x0010)(Parm, OutParm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(MM_DebugWidgetManager_GetMonsterSimpleState) == 0x000008, "Wrong alignment on MM_DebugWidgetManager_GetMonsterSimpleState");
static_assert(sizeof(MM_DebugWidgetManager_GetMonsterSimpleState) == 0x000048, "Wrong size on MM_DebugWidgetManager_GetMonsterSimpleState");
static_assert(offsetof(MM_DebugWidgetManager_GetMonsterSimpleState, PMonster) == 0x000000, "Member 'MM_DebugWidgetManager_GetMonsterSimpleState::PMonster' has a wrong offset!");
static_assert(offsetof(MM_DebugWidgetManager_GetMonsterSimpleState, PhysicalAttack) == 0x000008, "Member 'MM_DebugWidgetManager_GetMonsterSimpleState::PhysicalAttack' has a wrong offset!");
static_assert(offsetof(MM_DebugWidgetManager_GetMonsterSimpleState, MagicAttack) == 0x000018, "Member 'MM_DebugWidgetManager_GetMonsterSimpleState::MagicAttack' has a wrong offset!");
static_assert(offsetof(MM_DebugWidgetManager_GetMonsterSimpleState, Physicaldefense) == 0x000028, "Member 'MM_DebugWidgetManager_GetMonsterSimpleState::Physicaldefense' has a wrong offset!");
static_assert(offsetof(MM_DebugWidgetManager_GetMonsterSimpleState, Magicdefense) == 0x000038, "Member 'MM_DebugWidgetManager_GetMonsterSimpleState::Magicdefense' has a wrong offset!");

// Function MirMobile.MM_DebugWidgetManager.GetMonsterState
// 0x00B8 (0x00B8 - 0x0000)
struct MM_DebugWidgetManager_GetMonsterState final
{
public:
	class AMM_Monster*                            PMonster;                                          // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 Uid;                                               // 0x0008(0x0010)(Parm, OutParm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 TID;                                               // 0x0018(0x0010)(Parm, OutParm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 Grade;                                             // 0x0028(0x0010)(Parm, OutParm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 CP;                                                // 0x0038(0x0010)(Parm, OutParm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 HP;                                                // 0x0048(0x0010)(Parm, OutParm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 Att;                                               // 0x0058(0x0010)(Parm, OutParm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 Def;                                               // 0x0068(0x0010)(Parm, OutParm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 Accm;                                              // 0x0078(0x0010)(Parm, OutParm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 BT;                                                // 0x0088(0x0010)(Parm, OutParm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 CurrentFSM;                                        // 0x0098(0x0010)(Parm, OutParm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 PrevFSM;                                           // 0x00A8(0x0010)(Parm, OutParm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(MM_DebugWidgetManager_GetMonsterState) == 0x000008, "Wrong alignment on MM_DebugWidgetManager_GetMonsterState");
static_assert(sizeof(MM_DebugWidgetManager_GetMonsterState) == 0x0000B8, "Wrong size on MM_DebugWidgetManager_GetMonsterState");
static_assert(offsetof(MM_DebugWidgetManager_GetMonsterState, PMonster) == 0x000000, "Member 'MM_DebugWidgetManager_GetMonsterState::PMonster' has a wrong offset!");
static_assert(offsetof(MM_DebugWidgetManager_GetMonsterState, Uid) == 0x000008, "Member 'MM_DebugWidgetManager_GetMonsterState::Uid' has a wrong offset!");
static_assert(offsetof(MM_DebugWidgetManager_GetMonsterState, TID) == 0x000018, "Member 'MM_DebugWidgetManager_GetMonsterState::TID' has a wrong offset!");
static_assert(offsetof(MM_DebugWidgetManager_GetMonsterState, Grade) == 0x000028, "Member 'MM_DebugWidgetManager_GetMonsterState::Grade' has a wrong offset!");
static_assert(offsetof(MM_DebugWidgetManager_GetMonsterState, CP) == 0x000038, "Member 'MM_DebugWidgetManager_GetMonsterState::CP' has a wrong offset!");
static_assert(offsetof(MM_DebugWidgetManager_GetMonsterState, HP) == 0x000048, "Member 'MM_DebugWidgetManager_GetMonsterState::HP' has a wrong offset!");
static_assert(offsetof(MM_DebugWidgetManager_GetMonsterState, Att) == 0x000058, "Member 'MM_DebugWidgetManager_GetMonsterState::Att' has a wrong offset!");
static_assert(offsetof(MM_DebugWidgetManager_GetMonsterState, Def) == 0x000068, "Member 'MM_DebugWidgetManager_GetMonsterState::Def' has a wrong offset!");
static_assert(offsetof(MM_DebugWidgetManager_GetMonsterState, Accm) == 0x000078, "Member 'MM_DebugWidgetManager_GetMonsterState::Accm' has a wrong offset!");
static_assert(offsetof(MM_DebugWidgetManager_GetMonsterState, BT) == 0x000088, "Member 'MM_DebugWidgetManager_GetMonsterState::BT' has a wrong offset!");
static_assert(offsetof(MM_DebugWidgetManager_GetMonsterState, CurrentFSM) == 0x000098, "Member 'MM_DebugWidgetManager_GetMonsterState::CurrentFSM' has a wrong offset!");
static_assert(offsetof(MM_DebugWidgetManager_GetMonsterState, PrevFSM) == 0x0000A8, "Member 'MM_DebugWidgetManager_GetMonsterState::PrevFSM' has a wrong offset!");

// Function MirMobile.MM_DebugWidgetManager.GetNpcState
// 0x0038 (0x0038 - 0x0000)
struct MM_DebugWidgetManager_GetNpcState final
{
public:
	class AMM_NetPC*                              PNetPC;                                            // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         Uid;                                               // 0x0008(0x0004)(Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         HP;                                                // 0x000C(0x0004)(Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         VehicleId;                                         // 0x0010(0x0004)(Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bRide;                                             // 0x0014(0x0001)(Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_15[0x3];                                       // 0x0015(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	class FString                                 CurrentFSM;                                        // 0x0018(0x0010)(Parm, OutParm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         MoveSpeed;                                         // 0x0028(0x0004)(Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                Loc;                                               // 0x002C(0x000C)(Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(MM_DebugWidgetManager_GetNpcState) == 0x000008, "Wrong alignment on MM_DebugWidgetManager_GetNpcState");
static_assert(sizeof(MM_DebugWidgetManager_GetNpcState) == 0x000038, "Wrong size on MM_DebugWidgetManager_GetNpcState");
static_assert(offsetof(MM_DebugWidgetManager_GetNpcState, PNetPC) == 0x000000, "Member 'MM_DebugWidgetManager_GetNpcState::PNetPC' has a wrong offset!");
static_assert(offsetof(MM_DebugWidgetManager_GetNpcState, Uid) == 0x000008, "Member 'MM_DebugWidgetManager_GetNpcState::Uid' has a wrong offset!");
static_assert(offsetof(MM_DebugWidgetManager_GetNpcState, HP) == 0x00000C, "Member 'MM_DebugWidgetManager_GetNpcState::HP' has a wrong offset!");
static_assert(offsetof(MM_DebugWidgetManager_GetNpcState, VehicleId) == 0x000010, "Member 'MM_DebugWidgetManager_GetNpcState::VehicleId' has a wrong offset!");
static_assert(offsetof(MM_DebugWidgetManager_GetNpcState, bRide) == 0x000014, "Member 'MM_DebugWidgetManager_GetNpcState::bRide' has a wrong offset!");
static_assert(offsetof(MM_DebugWidgetManager_GetNpcState, CurrentFSM) == 0x000018, "Member 'MM_DebugWidgetManager_GetNpcState::CurrentFSM' has a wrong offset!");
static_assert(offsetof(MM_DebugWidgetManager_GetNpcState, MoveSpeed) == 0x000028, "Member 'MM_DebugWidgetManager_GetNpcState::MoveSpeed' has a wrong offset!");
static_assert(offsetof(MM_DebugWidgetManager_GetNpcState, Loc) == 0x00002C, "Member 'MM_DebugWidgetManager_GetNpcState::Loc' has a wrong offset!");

// Function MirMobile.MM_Dominion_Base_StrongPoint.OnChangeNotice
// 0x0018 (0x0018 - 0x0000)
struct MM_Dominion_Base_StrongPoint_OnChangeNotice final
{
public:
	class FText                                   Text;                                              // 0x0000(0x0018)(ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
};
static_assert(alignof(MM_Dominion_Base_StrongPoint_OnChangeNotice) == 0x000008, "Wrong alignment on MM_Dominion_Base_StrongPoint_OnChangeNotice");
static_assert(sizeof(MM_Dominion_Base_StrongPoint_OnChangeNotice) == 0x000018, "Wrong size on MM_Dominion_Base_StrongPoint_OnChangeNotice");
static_assert(offsetof(MM_Dominion_Base_StrongPoint_OnChangeNotice, Text) == 0x000000, "Member 'MM_Dominion_Base_StrongPoint_OnChangeNotice::Text' has a wrong offset!");

// Function MirMobile.MM_Popup_Auto_OptionChange.OnChangeCount
// 0x0008 (0x0008 - 0x0000)
struct MM_Popup_Auto_OptionChange_OnChangeCount final
{
public:
	int64                                         Count;                                             // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(MM_Popup_Auto_OptionChange_OnChangeCount) == 0x000008, "Wrong alignment on MM_Popup_Auto_OptionChange_OnChangeCount");
static_assert(sizeof(MM_Popup_Auto_OptionChange_OnChangeCount) == 0x000008, "Wrong size on MM_Popup_Auto_OptionChange_OnChangeCount");
static_assert(offsetof(MM_Popup_Auto_OptionChange_OnChangeCount, Count) == 0x000000, "Member 'MM_Popup_Auto_OptionChange_OnChangeCount::Count' has a wrong offset!");

// Function MirMobile.MM_GachaInteractionObjectActor.OnTouchDragPosition
// 0x0008 (0x0008 - 0x0000)
struct MM_GachaInteractionObjectActor_OnTouchDragPosition final
{
public:
	struct FVector2D                              DragPosition;                                      // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(MM_GachaInteractionObjectActor_OnTouchDragPosition) == 0x000004, "Wrong alignment on MM_GachaInteractionObjectActor_OnTouchDragPosition");
static_assert(sizeof(MM_GachaInteractionObjectActor_OnTouchDragPosition) == 0x000008, "Wrong size on MM_GachaInteractionObjectActor_OnTouchDragPosition");
static_assert(offsetof(MM_GachaInteractionObjectActor_OnTouchDragPosition, DragPosition) == 0x000000, "Member 'MM_GachaInteractionObjectActor_OnTouchDragPosition::DragPosition' has a wrong offset!");

// Function MirMobile.MM_GachaInteractionObjectActor.OnTouchStartPosition
// 0x0008 (0x0008 - 0x0000)
struct MM_GachaInteractionObjectActor_OnTouchStartPosition final
{
public:
	struct FVector2D                              StartPosition;                                     // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(MM_GachaInteractionObjectActor_OnTouchStartPosition) == 0x000004, "Wrong alignment on MM_GachaInteractionObjectActor_OnTouchStartPosition");
static_assert(sizeof(MM_GachaInteractionObjectActor_OnTouchStartPosition) == 0x000008, "Wrong size on MM_GachaInteractionObjectActor_OnTouchStartPosition");
static_assert(offsetof(MM_GachaInteractionObjectActor_OnTouchStartPosition, StartPosition) == 0x000000, "Member 'MM_GachaInteractionObjectActor_OnTouchStartPosition::StartPosition' has a wrong offset!");

// Function MirMobile.MM_GachaInteractionObjectActor.SetDragCameraShakeScaleEvent
// 0x0004 (0x0004 - 0x0000)
struct MM_GachaInteractionObjectActor_SetDragCameraShakeScaleEvent final
{
public:
	float                                         ShakeScale;                                        // 0x0000(0x0004)(ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(MM_GachaInteractionObjectActor_SetDragCameraShakeScaleEvent) == 0x000004, "Wrong alignment on MM_GachaInteractionObjectActor_SetDragCameraShakeScaleEvent");
static_assert(sizeof(MM_GachaInteractionObjectActor_SetDragCameraShakeScaleEvent) == 0x000004, "Wrong size on MM_GachaInteractionObjectActor_SetDragCameraShakeScaleEvent");
static_assert(offsetof(MM_GachaInteractionObjectActor_SetDragCameraShakeScaleEvent, ShakeScale) == 0x000000, "Member 'MM_GachaInteractionObjectActor_SetDragCameraShakeScaleEvent::ShakeScale' has a wrong offset!");

// Function MirMobile.MM_GachaInteractionObjectActor.SpawnDragParticle
// 0x0008 (0x0008 - 0x0000)
struct MM_GachaInteractionObjectActor_SpawnDragParticle final
{
public:
	class UParticleSystem*                        PParticle;                                         // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(MM_GachaInteractionObjectActor_SpawnDragParticle) == 0x000008, "Wrong alignment on MM_GachaInteractionObjectActor_SpawnDragParticle");
static_assert(sizeof(MM_GachaInteractionObjectActor_SpawnDragParticle) == 0x000008, "Wrong size on MM_GachaInteractionObjectActor_SpawnDragParticle");
static_assert(offsetof(MM_GachaInteractionObjectActor_SpawnDragParticle, PParticle) == 0x000000, "Member 'MM_GachaInteractionObjectActor_SpawnDragParticle::PParticle' has a wrong offset!");

// Function MirMobile.MM_GachaInteractionObjectActor.StartResultSequenceEvent
// 0x0018 (0x0018 - 0x0000)
struct MM_GachaInteractionObjectActor_StartResultSequenceEvent final
{
public:
	class FString                                 ResultName;                                        // 0x0000(0x0010)(Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EGachaBoxType                                 GachaResultType;                                   // 0x0010(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_11[0x3];                                       // 0x0011(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         ItemGrade;                                         // 0x0014(0x0004)(ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(MM_GachaInteractionObjectActor_StartResultSequenceEvent) == 0x000008, "Wrong alignment on MM_GachaInteractionObjectActor_StartResultSequenceEvent");
static_assert(sizeof(MM_GachaInteractionObjectActor_StartResultSequenceEvent) == 0x000018, "Wrong size on MM_GachaInteractionObjectActor_StartResultSequenceEvent");
static_assert(offsetof(MM_GachaInteractionObjectActor_StartResultSequenceEvent, ResultName) == 0x000000, "Member 'MM_GachaInteractionObjectActor_StartResultSequenceEvent::ResultName' has a wrong offset!");
static_assert(offsetof(MM_GachaInteractionObjectActor_StartResultSequenceEvent, GachaResultType) == 0x000010, "Member 'MM_GachaInteractionObjectActor_StartResultSequenceEvent::GachaResultType' has a wrong offset!");
static_assert(offsetof(MM_GachaInteractionObjectActor_StartResultSequenceEvent, ItemGrade) == 0x000014, "Member 'MM_GachaInteractionObjectActor_StartResultSequenceEvent::ItemGrade' has a wrong offset!");

// Function MirMobile.MM_Dominion_Castle_Log.OnSetTaxRate
// 0x0008 (0x0008 - 0x0000)
struct MM_Dominion_Castle_Log_OnSetTaxRate final
{
public:
	int64                                         ITaxRate;                                          // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(MM_Dominion_Castle_Log_OnSetTaxRate) == 0x000008, "Wrong alignment on MM_Dominion_Castle_Log_OnSetTaxRate");
static_assert(sizeof(MM_Dominion_Castle_Log_OnSetTaxRate) == 0x000008, "Wrong size on MM_Dominion_Castle_Log_OnSetTaxRate");
static_assert(offsetof(MM_Dominion_Castle_Log_OnSetTaxRate, ITaxRate) == 0x000000, "Member 'MM_Dominion_Castle_Log_OnSetTaxRate::ITaxRate' has a wrong offset!");

// Function MirMobile.MM_Dominion_Castle_Tax.OnSetTaxRate
// 0x0008 (0x0008 - 0x0000)
struct MM_Dominion_Castle_Tax_OnSetTaxRate final
{
public:
	int64                                         ITaxRate;                                          // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(MM_Dominion_Castle_Tax_OnSetTaxRate) == 0x000008, "Wrong alignment on MM_Dominion_Castle_Tax_OnSetTaxRate");
static_assert(sizeof(MM_Dominion_Castle_Tax_OnSetTaxRate) == 0x000008, "Wrong size on MM_Dominion_Castle_Tax_OnSetTaxRate");
static_assert(offsetof(MM_Dominion_Castle_Tax_OnSetTaxRate, ITaxRate) == 0x000000, "Member 'MM_Dominion_Castle_Tax_OnSetTaxRate::ITaxRate' has a wrong offset!");

// Function MirMobile.MM_Popup_Auction_RegistInfo.OnSliderMax
// 0x0001 (0x0001 - 0x0000)
struct MM_Popup_Auction_RegistInfo_OnSliderMax final
{
public:
	bool                                          BMax;                                              // 0x0000(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(MM_Popup_Auction_RegistInfo_OnSliderMax) == 0x000001, "Wrong alignment on MM_Popup_Auction_RegistInfo_OnSliderMax");
static_assert(sizeof(MM_Popup_Auction_RegistInfo_OnSliderMax) == 0x000001, "Wrong size on MM_Popup_Auction_RegistInfo_OnSliderMax");
static_assert(offsetof(MM_Popup_Auction_RegistInfo_OnSliderMax, BMax) == 0x000000, "Member 'MM_Popup_Auction_RegistInfo_OnSliderMax::BMax' has a wrong offset!");

// Function MirMobile.MM_Popup_Auction_RegistInfo.OnSliderSellCount
// 0x0008 (0x0008 - 0x0000)
struct MM_Popup_Auction_RegistInfo_OnSliderSellCount final
{
public:
	int64                                         ISellCount;                                        // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(MM_Popup_Auction_RegistInfo_OnSliderSellCount) == 0x000008, "Wrong alignment on MM_Popup_Auction_RegistInfo_OnSliderSellCount");
static_assert(sizeof(MM_Popup_Auction_RegistInfo_OnSliderSellCount) == 0x000008, "Wrong size on MM_Popup_Auction_RegistInfo_OnSliderSellCount");
static_assert(offsetof(MM_Popup_Auction_RegistInfo_OnSliderSellCount, ISellCount) == 0x000000, "Member 'MM_Popup_Auction_RegistInfo_OnSliderSellCount::ISellCount' has a wrong offset!");

// Function MirMobile.MM_Popup_Auction_RegistInfo.OnSliderSellPrice
// 0x0008 (0x0008 - 0x0000)
struct MM_Popup_Auction_RegistInfo_OnSliderSellPrice final
{
public:
	int64                                         ISellPrice;                                        // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(MM_Popup_Auction_RegistInfo_OnSliderSellPrice) == 0x000008, "Wrong alignment on MM_Popup_Auction_RegistInfo_OnSliderSellPrice");
static_assert(sizeof(MM_Popup_Auction_RegistInfo_OnSliderSellPrice) == 0x000008, "Wrong size on MM_Popup_Auction_RegistInfo_OnSliderSellPrice");
static_assert(offsetof(MM_Popup_Auction_RegistInfo_OnSliderSellPrice, ISellPrice) == 0x000000, "Member 'MM_Popup_Auction_RegistInfo_OnSliderSellPrice::ISellPrice' has a wrong offset!");

// Function MirMobile.MM_ItemSynthesis_List.OnClickSlot
// 0x0008 (0x0008 - 0x0000)
struct MM_ItemSynthesis_List_OnClickSlot final
{
public:
	class UMM_Slot_Base*                          PSlot;                                             // 0x0000(0x0008)(Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(MM_ItemSynthesis_List_OnClickSlot) == 0x000008, "Wrong alignment on MM_ItemSynthesis_List_OnClickSlot");
static_assert(sizeof(MM_ItemSynthesis_List_OnClickSlot) == 0x000008, "Wrong size on MM_ItemSynthesis_List_OnClickSlot");
static_assert(offsetof(MM_ItemSynthesis_List_OnClickSlot, PSlot) == 0x000000, "Member 'MM_ItemSynthesis_List_OnClickSlot::PSlot' has a wrong offset!");

// Function MirMobile.MM_Dominion_Occupation.OnClickGuildMember
// 0x0008 (0x0008 - 0x0000)
struct MM_Dominion_Occupation_OnClickGuildMember final
{
public:
	int64                                         IGuildMemberUID;                                   // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(MM_Dominion_Occupation_OnClickGuildMember) == 0x000008, "Wrong alignment on MM_Dominion_Occupation_OnClickGuildMember");
static_assert(sizeof(MM_Dominion_Occupation_OnClickGuildMember) == 0x000008, "Wrong size on MM_Dominion_Occupation_OnClickGuildMember");
static_assert(offsetof(MM_Dominion_Occupation_OnClickGuildMember, IGuildMemberUID) == 0x000000, "Member 'MM_Dominion_Occupation_OnClickGuildMember::IGuildMemberUID' has a wrong offset!");

// Function MirMobile.MM_Dominion_Occupation.OnSelectDelegate
// 0x0004 (0x0004 - 0x0000)
struct MM_Dominion_Occupation_OnSelectDelegate final
{
public:
	int32                                         IPBS_ID;                                           // 0x0000(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(MM_Dominion_Occupation_OnSelectDelegate) == 0x000004, "Wrong alignment on MM_Dominion_Occupation_OnSelectDelegate");
static_assert(sizeof(MM_Dominion_Occupation_OnSelectDelegate) == 0x000004, "Wrong size on MM_Dominion_Occupation_OnSelectDelegate");
static_assert(offsetof(MM_Dominion_Occupation_OnSelectDelegate, IPBS_ID) == 0x000000, "Member 'MM_Dominion_Occupation_OnSelectDelegate::IPBS_ID' has a wrong offset!");

// Function MirMobile.MM_Guild_ShopList.OnClickInvenSlot
// 0x0004 (0x0004 - 0x0000)
struct MM_Guild_ShopList_OnClickInvenSlot final
{
public:
	int32                                         IGuildShopID;                                      // 0x0000(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(MM_Guild_ShopList_OnClickInvenSlot) == 0x000004, "Wrong alignment on MM_Guild_ShopList_OnClickInvenSlot");
static_assert(sizeof(MM_Guild_ShopList_OnClickInvenSlot) == 0x000004, "Wrong size on MM_Guild_ShopList_OnClickInvenSlot");
static_assert(offsetof(MM_Guild_ShopList_OnClickInvenSlot, IGuildShopID) == 0x000000, "Member 'MM_Guild_ShopList_OnClickInvenSlot::IGuildShopID' has a wrong offset!");

// Function MirMobile.ProjectileBase.OnBeginOverlap
// 0x00A8 (0x00A8 - 0x0000)
struct ProjectileBase_OnBeginOverlap final
{
public:
	class UPrimitiveComponent*                    OverlappedComponent;                               // 0x0000(0x0008)(Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class AActor*                                 POtherActor;                                       // 0x0008(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UPrimitiveComponent*                    OtherComponent;                                    // 0x0010(0x0008)(Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         OtherBodyIndex;                                    // 0x0018(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bFromSweep;                                        // 0x001C(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1D[0x3];                                       // 0x001D(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	struct FHitResult                             SweepResult;                                       // 0x0020(0x0088)(ConstParm, Parm, OutParm, ReferenceParm, IsPlainOldData, NoDestructor, ContainsInstancedReference, NativeAccessSpecifierPublic)
};
static_assert(alignof(ProjectileBase_OnBeginOverlap) == 0x000008, "Wrong alignment on ProjectileBase_OnBeginOverlap");
static_assert(sizeof(ProjectileBase_OnBeginOverlap) == 0x0000A8, "Wrong size on ProjectileBase_OnBeginOverlap");
static_assert(offsetof(ProjectileBase_OnBeginOverlap, OverlappedComponent) == 0x000000, "Member 'ProjectileBase_OnBeginOverlap::OverlappedComponent' has a wrong offset!");
static_assert(offsetof(ProjectileBase_OnBeginOverlap, POtherActor) == 0x000008, "Member 'ProjectileBase_OnBeginOverlap::POtherActor' has a wrong offset!");
static_assert(offsetof(ProjectileBase_OnBeginOverlap, OtherComponent) == 0x000010, "Member 'ProjectileBase_OnBeginOverlap::OtherComponent' has a wrong offset!");
static_assert(offsetof(ProjectileBase_OnBeginOverlap, OtherBodyIndex) == 0x000018, "Member 'ProjectileBase_OnBeginOverlap::OtherBodyIndex' has a wrong offset!");
static_assert(offsetof(ProjectileBase_OnBeginOverlap, bFromSweep) == 0x00001C, "Member 'ProjectileBase_OnBeginOverlap::bFromSweep' has a wrong offset!");
static_assert(offsetof(ProjectileBase_OnBeginOverlap, SweepResult) == 0x000020, "Member 'ProjectileBase_OnBeginOverlap::SweepResult' has a wrong offset!");

// Function MirMobile.ProjectileBase.OnEndOverlap
// 0x0020 (0x0020 - 0x0000)
struct ProjectileBase_OnEndOverlap final
{
public:
	class UPrimitiveComponent*                    OverlappedComponent;                               // 0x0000(0x0008)(Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class AActor*                                 POtherActor;                                       // 0x0008(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UPrimitiveComponent*                    OtherComponent;                                    // 0x0010(0x0008)(Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         OtherBodyIndex;                                    // 0x0018(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1C[0x4];                                       // 0x001C(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(ProjectileBase_OnEndOverlap) == 0x000008, "Wrong alignment on ProjectileBase_OnEndOverlap");
static_assert(sizeof(ProjectileBase_OnEndOverlap) == 0x000020, "Wrong size on ProjectileBase_OnEndOverlap");
static_assert(offsetof(ProjectileBase_OnEndOverlap, OverlappedComponent) == 0x000000, "Member 'ProjectileBase_OnEndOverlap::OverlappedComponent' has a wrong offset!");
static_assert(offsetof(ProjectileBase_OnEndOverlap, POtherActor) == 0x000008, "Member 'ProjectileBase_OnEndOverlap::POtherActor' has a wrong offset!");
static_assert(offsetof(ProjectileBase_OnEndOverlap, OtherComponent) == 0x000010, "Member 'ProjectileBase_OnEndOverlap::OtherComponent' has a wrong offset!");
static_assert(offsetof(ProjectileBase_OnEndOverlap, OtherBodyIndex) == 0x000018, "Member 'ProjectileBase_OnEndOverlap::OtherBodyIndex' has a wrong offset!");

// Function MirMobile.ProjectileBase.OnHit
// 0x00B0 (0x00B0 - 0x0000)
struct ProjectileBase_OnHit final
{
public:
	class UPrimitiveComponent*                    PHitComponent;                                     // 0x0000(0x0008)(Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class AActor*                                 POtherActor;                                       // 0x0008(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UPrimitiveComponent*                    POtherComponent;                                   // 0x0010(0x0008)(Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                VNormalImpulse;                                    // 0x0018(0x000C)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FHitResult                             HitResult;                                         // 0x0024(0x0088)(ConstParm, Parm, OutParm, ReferenceParm, IsPlainOldData, NoDestructor, ContainsInstancedReference, NativeAccessSpecifierPublic)
	uint8                                         Pad_AC[0x4];                                       // 0x00AC(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(ProjectileBase_OnHit) == 0x000008, "Wrong alignment on ProjectileBase_OnHit");
static_assert(sizeof(ProjectileBase_OnHit) == 0x0000B0, "Wrong size on ProjectileBase_OnHit");
static_assert(offsetof(ProjectileBase_OnHit, PHitComponent) == 0x000000, "Member 'ProjectileBase_OnHit::PHitComponent' has a wrong offset!");
static_assert(offsetof(ProjectileBase_OnHit, POtherActor) == 0x000008, "Member 'ProjectileBase_OnHit::POtherActor' has a wrong offset!");
static_assert(offsetof(ProjectileBase_OnHit, POtherComponent) == 0x000010, "Member 'ProjectileBase_OnHit::POtherComponent' has a wrong offset!");
static_assert(offsetof(ProjectileBase_OnHit, VNormalImpulse) == 0x000018, "Member 'ProjectileBase_OnHit::VNormalImpulse' has a wrong offset!");
static_assert(offsetof(ProjectileBase_OnHit, HitResult) == 0x000024, "Member 'ProjectileBase_OnHit::HitResult' has a wrong offset!");

// Function MirMobile.MM_ItemSynthesis_Inven.OnClickSlot
// 0x0008 (0x0008 - 0x0000)
struct MM_ItemSynthesis_Inven_OnClickSlot final
{
public:
	class UMM_Slot_Base*                          PSlot;                                             // 0x0000(0x0008)(Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(MM_ItemSynthesis_Inven_OnClickSlot) == 0x000008, "Wrong alignment on MM_ItemSynthesis_Inven_OnClickSlot");
static_assert(sizeof(MM_ItemSynthesis_Inven_OnClickSlot) == 0x000008, "Wrong size on MM_ItemSynthesis_Inven_OnClickSlot");
static_assert(offsetof(MM_ItemSynthesis_Inven_OnClickSlot, PSlot) == 0x000000, "Member 'MM_ItemSynthesis_Inven_OnClickSlot::PSlot' has a wrong offset!");

// Function MirMobile.MM_Popup_GuestContinueSetting.OnChangeEditPassword
// 0x0018 (0x0018 - 0x0000)
struct MM_Popup_GuestContinueSetting_OnChangeEditPassword final
{
public:
	class FText                                   Text;                                              // 0x0000(0x0018)(ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
};
static_assert(alignof(MM_Popup_GuestContinueSetting_OnChangeEditPassword) == 0x000008, "Wrong alignment on MM_Popup_GuestContinueSetting_OnChangeEditPassword");
static_assert(sizeof(MM_Popup_GuestContinueSetting_OnChangeEditPassword) == 0x000018, "Wrong size on MM_Popup_GuestContinueSetting_OnChangeEditPassword");
static_assert(offsetof(MM_Popup_GuestContinueSetting_OnChangeEditPassword, Text) == 0x000000, "Member 'MM_Popup_GuestContinueSetting_OnChangeEditPassword::Text' has a wrong offset!");

// Function MirMobile.MM_Popup_GuestContinueSetting.OnCommitEditPassword
// 0x0020 (0x0020 - 0x0000)
struct MM_Popup_GuestContinueSetting_OnCommitEditPassword final
{
public:
	class FText                                   Text;                                              // 0x0000(0x0018)(ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
	ETextCommit                                   CommitMethod;                                      // 0x0018(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_19[0x7];                                       // 0x0019(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(MM_Popup_GuestContinueSetting_OnCommitEditPassword) == 0x000008, "Wrong alignment on MM_Popup_GuestContinueSetting_OnCommitEditPassword");
static_assert(sizeof(MM_Popup_GuestContinueSetting_OnCommitEditPassword) == 0x000020, "Wrong size on MM_Popup_GuestContinueSetting_OnCommitEditPassword");
static_assert(offsetof(MM_Popup_GuestContinueSetting_OnCommitEditPassword, Text) == 0x000000, "Member 'MM_Popup_GuestContinueSetting_OnCommitEditPassword::Text' has a wrong offset!");
static_assert(offsetof(MM_Popup_GuestContinueSetting_OnCommitEditPassword, CommitMethod) == 0x000018, "Member 'MM_Popup_GuestContinueSetting_OnCommitEditPassword::CommitMethod' has a wrong offset!");

// Function MirMobile.MM_Popup_GuestContinueSetting.OnPasswordSettingComplete
// 0x0018 (0x0018 - 0x0000)
struct MM_Popup_GuestContinueSetting_OnPasswordSettingComplete final
{
public:
	bool                                          Success;                                           // 0x0000(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1[0x7];                                        // 0x0001(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	class FString                                 Message;                                           // 0x0008(0x0010)(Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(MM_Popup_GuestContinueSetting_OnPasswordSettingComplete) == 0x000008, "Wrong alignment on MM_Popup_GuestContinueSetting_OnPasswordSettingComplete");
static_assert(sizeof(MM_Popup_GuestContinueSetting_OnPasswordSettingComplete) == 0x000018, "Wrong size on MM_Popup_GuestContinueSetting_OnPasswordSettingComplete");
static_assert(offsetof(MM_Popup_GuestContinueSetting_OnPasswordSettingComplete, Success) == 0x000000, "Member 'MM_Popup_GuestContinueSetting_OnPasswordSettingComplete::Success' has a wrong offset!");
static_assert(offsetof(MM_Popup_GuestContinueSetting_OnPasswordSettingComplete, Message) == 0x000008, "Member 'MM_Popup_GuestContinueSetting_OnPasswordSettingComplete::Message' has a wrong offset!");

// Function MirMobile.MM_GuildTournament_GroupTabSlot.OnClickedCheckBox
// 0x0001 (0x0001 - 0x0000)
struct MM_GuildTournament_GroupTabSlot_OnClickedCheckBox final
{
public:
	bool                                          Checked_;                                          // 0x0000(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(MM_GuildTournament_GroupTabSlot_OnClickedCheckBox) == 0x000001, "Wrong alignment on MM_GuildTournament_GroupTabSlot_OnClickedCheckBox");
static_assert(sizeof(MM_GuildTournament_GroupTabSlot_OnClickedCheckBox) == 0x000001, "Wrong size on MM_GuildTournament_GroupTabSlot_OnClickedCheckBox");
static_assert(offsetof(MM_GuildTournament_GroupTabSlot_OnClickedCheckBox, Checked_) == 0x000000, "Member 'MM_GuildTournament_GroupTabSlot_OnClickedCheckBox::Checked_' has a wrong offset!");

// Function MirMobile.MM_Dominion_WithDrawal_OutSlot.OnSetOutValue
// 0x0008 (0x0008 - 0x0000)
struct MM_Dominion_WithDrawal_OutSlot_OnSetOutValue final
{
public:
	int64                                         IValue;                                            // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(MM_Dominion_WithDrawal_OutSlot_OnSetOutValue) == 0x000008, "Wrong alignment on MM_Dominion_WithDrawal_OutSlot_OnSetOutValue");
static_assert(sizeof(MM_Dominion_WithDrawal_OutSlot_OnSetOutValue) == 0x000008, "Wrong size on MM_Dominion_WithDrawal_OutSlot_OnSetOutValue");
static_assert(offsetof(MM_Dominion_WithDrawal_OutSlot_OnSetOutValue, IValue) == 0x000000, "Member 'MM_Dominion_WithDrawal_OutSlot_OnSetOutValue::IValue' has a wrong offset!");

// Function MirMobile.MM_MagicOrbPopupRegisterFilter.OnClickCheckBoxGrade2
// 0x0001 (0x0001 - 0x0000)
struct MM_MagicOrbPopupRegisterFilter_OnClickCheckBoxGrade2 final
{
public:
	bool                                          Check_;                                            // 0x0000(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(MM_MagicOrbPopupRegisterFilter_OnClickCheckBoxGrade2) == 0x000001, "Wrong alignment on MM_MagicOrbPopupRegisterFilter_OnClickCheckBoxGrade2");
static_assert(sizeof(MM_MagicOrbPopupRegisterFilter_OnClickCheckBoxGrade2) == 0x000001, "Wrong size on MM_MagicOrbPopupRegisterFilter_OnClickCheckBoxGrade2");
static_assert(offsetof(MM_MagicOrbPopupRegisterFilter_OnClickCheckBoxGrade2, Check_) == 0x000000, "Member 'MM_MagicOrbPopupRegisterFilter_OnClickCheckBoxGrade2::Check_' has a wrong offset!");

// Function MirMobile.MM_MagicOrbPopupRegisterFilter.OnClickCheckBoxGrade3
// 0x0001 (0x0001 - 0x0000)
struct MM_MagicOrbPopupRegisterFilter_OnClickCheckBoxGrade3 final
{
public:
	bool                                          Check_;                                            // 0x0000(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(MM_MagicOrbPopupRegisterFilter_OnClickCheckBoxGrade3) == 0x000001, "Wrong alignment on MM_MagicOrbPopupRegisterFilter_OnClickCheckBoxGrade3");
static_assert(sizeof(MM_MagicOrbPopupRegisterFilter_OnClickCheckBoxGrade3) == 0x000001, "Wrong size on MM_MagicOrbPopupRegisterFilter_OnClickCheckBoxGrade3");
static_assert(offsetof(MM_MagicOrbPopupRegisterFilter_OnClickCheckBoxGrade3, Check_) == 0x000000, "Member 'MM_MagicOrbPopupRegisterFilter_OnClickCheckBoxGrade3::Check_' has a wrong offset!");

// Function MirMobile.MM_MagicOrbPopupRegisterFilter.OnClickCheckBoxGrade4
// 0x0001 (0x0001 - 0x0000)
struct MM_MagicOrbPopupRegisterFilter_OnClickCheckBoxGrade4 final
{
public:
	bool                                          Check_;                                            // 0x0000(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(MM_MagicOrbPopupRegisterFilter_OnClickCheckBoxGrade4) == 0x000001, "Wrong alignment on MM_MagicOrbPopupRegisterFilter_OnClickCheckBoxGrade4");
static_assert(sizeof(MM_MagicOrbPopupRegisterFilter_OnClickCheckBoxGrade4) == 0x000001, "Wrong size on MM_MagicOrbPopupRegisterFilter_OnClickCheckBoxGrade4");
static_assert(offsetof(MM_MagicOrbPopupRegisterFilter_OnClickCheckBoxGrade4, Check_) == 0x000000, "Member 'MM_MagicOrbPopupRegisterFilter_OnClickCheckBoxGrade4::Check_' has a wrong offset!");

// Function MirMobile.MM_MagicOrbPopupRegisterFilter.OnClickCheckBoxGrade5
// 0x0001 (0x0001 - 0x0000)
struct MM_MagicOrbPopupRegisterFilter_OnClickCheckBoxGrade5 final
{
public:
	bool                                          Check_;                                            // 0x0000(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(MM_MagicOrbPopupRegisterFilter_OnClickCheckBoxGrade5) == 0x000001, "Wrong alignment on MM_MagicOrbPopupRegisterFilter_OnClickCheckBoxGrade5");
static_assert(sizeof(MM_MagicOrbPopupRegisterFilter_OnClickCheckBoxGrade5) == 0x000001, "Wrong size on MM_MagicOrbPopupRegisterFilter_OnClickCheckBoxGrade5");
static_assert(offsetof(MM_MagicOrbPopupRegisterFilter_OnClickCheckBoxGrade5, Check_) == 0x000000, "Member 'MM_MagicOrbPopupRegisterFilter_OnClickCheckBoxGrade5::Check_' has a wrong offset!");

// Function MirMobile.MM_MagicOrbPopupRegisterFilter.OnClickCheckBoxMagicOrbMaterial
// 0x0001 (0x0001 - 0x0000)
struct MM_MagicOrbPopupRegisterFilter_OnClickCheckBoxMagicOrbMaterial final
{
public:
	bool                                          Check_;                                            // 0x0000(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(MM_MagicOrbPopupRegisterFilter_OnClickCheckBoxMagicOrbMaterial) == 0x000001, "Wrong alignment on MM_MagicOrbPopupRegisterFilter_OnClickCheckBoxMagicOrbMaterial");
static_assert(sizeof(MM_MagicOrbPopupRegisterFilter_OnClickCheckBoxMagicOrbMaterial) == 0x000001, "Wrong size on MM_MagicOrbPopupRegisterFilter_OnClickCheckBoxMagicOrbMaterial");
static_assert(offsetof(MM_MagicOrbPopupRegisterFilter_OnClickCheckBoxMagicOrbMaterial, Check_) == 0x000000, "Member 'MM_MagicOrbPopupRegisterFilter_OnClickCheckBoxMagicOrbMaterial::Check_' has a wrong offset!");

// Function MirMobile.MM_MagicOrbPopupRegisterFilter.OnClickCheckBoxPetMaterial
// 0x0001 (0x0001 - 0x0000)
struct MM_MagicOrbPopupRegisterFilter_OnClickCheckBoxPetMaterial final
{
public:
	bool                                          Check_;                                            // 0x0000(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(MM_MagicOrbPopupRegisterFilter_OnClickCheckBoxPetMaterial) == 0x000001, "Wrong alignment on MM_MagicOrbPopupRegisterFilter_OnClickCheckBoxPetMaterial");
static_assert(sizeof(MM_MagicOrbPopupRegisterFilter_OnClickCheckBoxPetMaterial) == 0x000001, "Wrong size on MM_MagicOrbPopupRegisterFilter_OnClickCheckBoxPetMaterial");
static_assert(offsetof(MM_MagicOrbPopupRegisterFilter_OnClickCheckBoxPetMaterial, Check_) == 0x000000, "Member 'MM_MagicOrbPopupRegisterFilter_OnClickCheckBoxPetMaterial::Check_' has a wrong offset!");

// Function MirMobile.MM_DoorObject.DoorOpen_Event
// 0x0002 (0x0002 - 0x0000)
struct MM_DoorObject_DoorOpen_Event final
{
public:
	bool                                          bOpen;                                             // 0x0000(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bImmediately;                                      // 0x0001(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(MM_DoorObject_DoorOpen_Event) == 0x000001, "Wrong alignment on MM_DoorObject_DoorOpen_Event");
static_assert(sizeof(MM_DoorObject_DoorOpen_Event) == 0x000002, "Wrong size on MM_DoorObject_DoorOpen_Event");
static_assert(offsetof(MM_DoorObject_DoorOpen_Event, bOpen) == 0x000000, "Member 'MM_DoorObject_DoorOpen_Event::bOpen' has a wrong offset!");
static_assert(offsetof(MM_DoorObject_DoorOpen_Event, bImmediately) == 0x000001, "Member 'MM_DoorObject_DoorOpen_Event::bImmediately' has a wrong offset!");

// Function MirMobile.MM_DragonicGear_EquipSlot.OnClickEquipSlot
// 0x0010 (0x0010 - 0x0000)
struct MM_DragonicGear_EquipSlot_OnClickEquipSlot final
{
public:
	int64                                         IUID;                                              // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         ITID;                                              // 0x0008(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         IEquipPosition;                                    // 0x000C(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(MM_DragonicGear_EquipSlot_OnClickEquipSlot) == 0x000008, "Wrong alignment on MM_DragonicGear_EquipSlot_OnClickEquipSlot");
static_assert(sizeof(MM_DragonicGear_EquipSlot_OnClickEquipSlot) == 0x000010, "Wrong size on MM_DragonicGear_EquipSlot_OnClickEquipSlot");
static_assert(offsetof(MM_DragonicGear_EquipSlot_OnClickEquipSlot, IUID) == 0x000000, "Member 'MM_DragonicGear_EquipSlot_OnClickEquipSlot::IUID' has a wrong offset!");
static_assert(offsetof(MM_DragonicGear_EquipSlot_OnClickEquipSlot, ITID) == 0x000008, "Member 'MM_DragonicGear_EquipSlot_OnClickEquipSlot::ITID' has a wrong offset!");
static_assert(offsetof(MM_DragonicGear_EquipSlot_OnClickEquipSlot, IEquipPosition) == 0x00000C, "Member 'MM_DragonicGear_EquipSlot_OnClickEquipSlot::IEquipPosition' has a wrong offset!");

// Function MirMobile.SceneCaptureTool_Slider.OnChangedSliderX
// 0x0004 (0x0004 - 0x0000)
struct SceneCaptureTool_Slider_OnChangedSliderX final
{
public:
	float                                         Value;                                             // 0x0000(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(SceneCaptureTool_Slider_OnChangedSliderX) == 0x000004, "Wrong alignment on SceneCaptureTool_Slider_OnChangedSliderX");
static_assert(sizeof(SceneCaptureTool_Slider_OnChangedSliderX) == 0x000004, "Wrong size on SceneCaptureTool_Slider_OnChangedSliderX");
static_assert(offsetof(SceneCaptureTool_Slider_OnChangedSliderX, Value) == 0x000000, "Member 'SceneCaptureTool_Slider_OnChangedSliderX::Value' has a wrong offset!");

// Function MirMobile.SceneCaptureTool_Slider.OnChangedSliderY
// 0x0004 (0x0004 - 0x0000)
struct SceneCaptureTool_Slider_OnChangedSliderY final
{
public:
	float                                         Value;                                             // 0x0000(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(SceneCaptureTool_Slider_OnChangedSliderY) == 0x000004, "Wrong alignment on SceneCaptureTool_Slider_OnChangedSliderY");
static_assert(sizeof(SceneCaptureTool_Slider_OnChangedSliderY) == 0x000004, "Wrong size on SceneCaptureTool_Slider_OnChangedSliderY");
static_assert(offsetof(SceneCaptureTool_Slider_OnChangedSliderY, Value) == 0x000000, "Member 'SceneCaptureTool_Slider_OnChangedSliderY::Value' has a wrong offset!");

// Function MirMobile.SceneCaptureTool_Slider.OnChangedSliderZ
// 0x0004 (0x0004 - 0x0000)
struct SceneCaptureTool_Slider_OnChangedSliderZ final
{
public:
	float                                         Value;                                             // 0x0000(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(SceneCaptureTool_Slider_OnChangedSliderZ) == 0x000004, "Wrong alignment on SceneCaptureTool_Slider_OnChangedSliderZ");
static_assert(sizeof(SceneCaptureTool_Slider_OnChangedSliderZ) == 0x000004, "Wrong size on SceneCaptureTool_Slider_OnChangedSliderZ");
static_assert(offsetof(SceneCaptureTool_Slider_OnChangedSliderZ, Value) == 0x000000, "Member 'SceneCaptureTool_Slider_OnChangedSliderZ::Value' has a wrong offset!");

// Function MirMobile.MM_DragonicGearManagerActor.CreateRenderTarget_BP
// 0x0010 (0x0010 - 0x0000)
struct MM_DragonicGearManagerActor_CreateRenderTarget_BP final
{
public:
	struct FVector2D                              VRenderTargetSize;                                 // 0x0000(0x0008)(Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UCanvasRenderTarget2D*                  ReturnValue;                                       // 0x0008(0x0008)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(MM_DragonicGearManagerActor_CreateRenderTarget_BP) == 0x000008, "Wrong alignment on MM_DragonicGearManagerActor_CreateRenderTarget_BP");
static_assert(sizeof(MM_DragonicGearManagerActor_CreateRenderTarget_BP) == 0x000010, "Wrong size on MM_DragonicGearManagerActor_CreateRenderTarget_BP");
static_assert(offsetof(MM_DragonicGearManagerActor_CreateRenderTarget_BP, VRenderTargetSize) == 0x000000, "Member 'MM_DragonicGearManagerActor_CreateRenderTarget_BP::VRenderTargetSize' has a wrong offset!");
static_assert(offsetof(MM_DragonicGearManagerActor_CreateRenderTarget_BP, ReturnValue) == 0x000008, "Member 'MM_DragonicGearManagerActor_CreateRenderTarget_BP::ReturnValue' has a wrong offset!");

// Function MirMobile.MM_Guild_DevLevelUpResult.PlayEndAnimation
// 0x0004 (0x0004 - 0x0000)
struct MM_Guild_DevLevelUpResult_PlayEndAnimation final
{
public:
	float                                         ReturnValue;                                       // 0x0000(0x0004)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(MM_Guild_DevLevelUpResult_PlayEndAnimation) == 0x000004, "Wrong alignment on MM_Guild_DevLevelUpResult_PlayEndAnimation");
static_assert(sizeof(MM_Guild_DevLevelUpResult_PlayEndAnimation) == 0x000004, "Wrong size on MM_Guild_DevLevelUpResult_PlayEndAnimation");
static_assert(offsetof(MM_Guild_DevLevelUpResult_PlayEndAnimation, ReturnValue) == 0x000000, "Member 'MM_Guild_DevLevelUpResult_PlayEndAnimation::ReturnValue' has a wrong offset!");

// Function MirMobile.MM_Popup_Party_Info.ReturnPassword
// 0x0010 (0x0010 - 0x0000)
struct MM_Popup_Party_Info_ReturnPassword final
{
public:
	class FString                                 StrPassword;                                       // 0x0000(0x0010)(Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(MM_Popup_Party_Info_ReturnPassword) == 0x000008, "Wrong alignment on MM_Popup_Party_Info_ReturnPassword");
static_assert(sizeof(MM_Popup_Party_Info_ReturnPassword) == 0x000010, "Wrong size on MM_Popup_Party_Info_ReturnPassword");
static_assert(offsetof(MM_Popup_Party_Info_ReturnPassword, StrPassword) == 0x000000, "Member 'MM_Popup_Party_Info_ReturnPassword::StrPassword' has a wrong offset!");

// Function MirMobile.MM_Dungeon_List_Slot.OnClickFavoriteCheckBox
// 0x0001 (0x0001 - 0x0000)
struct MM_Dungeon_List_Slot_OnClickFavoriteCheckBox final
{
public:
	bool                                          bChecked;                                          // 0x0000(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(MM_Dungeon_List_Slot_OnClickFavoriteCheckBox) == 0x000001, "Wrong alignment on MM_Dungeon_List_Slot_OnClickFavoriteCheckBox");
static_assert(sizeof(MM_Dungeon_List_Slot_OnClickFavoriteCheckBox) == 0x000001, "Wrong size on MM_Dungeon_List_Slot_OnClickFavoriteCheckBox");
static_assert(offsetof(MM_Dungeon_List_Slot_OnClickFavoriteCheckBox, bChecked) == 0x000000, "Member 'MM_Dungeon_List_Slot_OnClickFavoriteCheckBox::bChecked' has a wrong offset!");

// Function MirMobile.MM_Dungeon_Shop.OnChangeCount
// 0x0008 (0x0008 - 0x0000)
struct MM_Dungeon_Shop_OnChangeCount final
{
public:
	int64                                         ICount;                                            // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(MM_Dungeon_Shop_OnChangeCount) == 0x000008, "Wrong alignment on MM_Dungeon_Shop_OnChangeCount");
static_assert(sizeof(MM_Dungeon_Shop_OnChangeCount) == 0x000008, "Wrong size on MM_Dungeon_Shop_OnChangeCount");
static_assert(offsetof(MM_Dungeon_Shop_OnChangeCount, ICount) == 0x000000, "Member 'MM_Dungeon_Shop_OnChangeCount::ICount' has a wrong offset!");

// Function MirMobile.MM_Dungeon_Shop.OnClickSlot
// 0x0008 (0x0008 - 0x0000)
struct MM_Dungeon_Shop_OnClickSlot final
{
public:
	int32                                         IDungeonShopID;                                    // 0x0000(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          UpdateSlot;                                        // 0x0004(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_5[0x3];                                        // 0x0005(0x0003)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(MM_Dungeon_Shop_OnClickSlot) == 0x000004, "Wrong alignment on MM_Dungeon_Shop_OnClickSlot");
static_assert(sizeof(MM_Dungeon_Shop_OnClickSlot) == 0x000008, "Wrong size on MM_Dungeon_Shop_OnClickSlot");
static_assert(offsetof(MM_Dungeon_Shop_OnClickSlot, IDungeonShopID) == 0x000000, "Member 'MM_Dungeon_Shop_OnClickSlot::IDungeonShopID' has a wrong offset!");
static_assert(offsetof(MM_Dungeon_Shop_OnClickSlot, UpdateSlot) == 0x000004, "Member 'MM_Dungeon_Shop_OnClickSlot::UpdateSlot' has a wrong offset!");

// Function MirMobile.MM_Dungeon_ShopList.OnClickInvenSlot
// 0x0010 (0x0010 - 0x0000)
struct MM_Dungeon_ShopList_OnClickInvenSlot final
{
public:
	int64                                         IItemUID;                                          // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         IItemTID;                                          // 0x0008(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         IEquipID;                                          // 0x000C(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(MM_Dungeon_ShopList_OnClickInvenSlot) == 0x000008, "Wrong alignment on MM_Dungeon_ShopList_OnClickInvenSlot");
static_assert(sizeof(MM_Dungeon_ShopList_OnClickInvenSlot) == 0x000010, "Wrong size on MM_Dungeon_ShopList_OnClickInvenSlot");
static_assert(offsetof(MM_Dungeon_ShopList_OnClickInvenSlot, IItemUID) == 0x000000, "Member 'MM_Dungeon_ShopList_OnClickInvenSlot::IItemUID' has a wrong offset!");
static_assert(offsetof(MM_Dungeon_ShopList_OnClickInvenSlot, IItemTID) == 0x000008, "Member 'MM_Dungeon_ShopList_OnClickInvenSlot::IItemTID' has a wrong offset!");
static_assert(offsetof(MM_Dungeon_ShopList_OnClickInvenSlot, IEquipID) == 0x00000C, "Member 'MM_Dungeon_ShopList_OnClickInvenSlot::IEquipID' has a wrong offset!");

// Function MirMobile.MM_DungeonCommonListSlot.OnClickFavoriteCheckBox
// 0x0001 (0x0001 - 0x0000)
struct MM_DungeonCommonListSlot_OnClickFavoriteCheckBox final
{
public:
	bool                                          bChecked;                                          // 0x0000(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(MM_DungeonCommonListSlot_OnClickFavoriteCheckBox) == 0x000001, "Wrong alignment on MM_DungeonCommonListSlot_OnClickFavoriteCheckBox");
static_assert(sizeof(MM_DungeonCommonListSlot_OnClickFavoriteCheckBox) == 0x000001, "Wrong size on MM_DungeonCommonListSlot_OnClickFavoriteCheckBox");
static_assert(offsetof(MM_DungeonCommonListSlot_OnClickFavoriteCheckBox, bChecked) == 0x000000, "Member 'MM_DungeonCommonListSlot_OnClickFavoriteCheckBox::bChecked' has a wrong offset!");

// Function MirMobile.MM_GameOption_Account.OnLinkIDPComplete
// 0x0018 (0x0018 - 0x0000)
struct MM_GameOption_Account_OnLinkIDPComplete final
{
public:
	bool                                          bSuccess;                                          // 0x0000(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1[0x7];                                        // 0x0001(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	class FString                                 StrResMsg;                                         // 0x0008(0x0010)(Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(MM_GameOption_Account_OnLinkIDPComplete) == 0x000008, "Wrong alignment on MM_GameOption_Account_OnLinkIDPComplete");
static_assert(sizeof(MM_GameOption_Account_OnLinkIDPComplete) == 0x000018, "Wrong size on MM_GameOption_Account_OnLinkIDPComplete");
static_assert(offsetof(MM_GameOption_Account_OnLinkIDPComplete, bSuccess) == 0x000000, "Member 'MM_GameOption_Account_OnLinkIDPComplete::bSuccess' has a wrong offset!");
static_assert(offsetof(MM_GameOption_Account_OnLinkIDPComplete, StrResMsg) == 0x000008, "Member 'MM_GameOption_Account_OnLinkIDPComplete::StrResMsg' has a wrong offset!");

// Function MirMobile.MM_EffectManager.OnChildActorFinished
// 0x0008 (0x0008 - 0x0000)
struct MM_EffectManager_OnChildActorFinished final
{
public:
	class ASkeletalEffect*                        FinishedActor;                                     // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(MM_EffectManager_OnChildActorFinished) == 0x000008, "Wrong alignment on MM_EffectManager_OnChildActorFinished");
static_assert(sizeof(MM_EffectManager_OnChildActorFinished) == 0x000008, "Wrong size on MM_EffectManager_OnChildActorFinished");
static_assert(offsetof(MM_EffectManager_OnChildActorFinished, FinishedActor) == 0x000000, "Member 'MM_EffectManager_OnChildActorFinished::FinishedActor' has a wrong offset!");

// Function MirMobile.MM_EffectManager.OnPartilceSystemFinished
// 0x0008 (0x0008 - 0x0000)
struct MM_EffectManager_OnPartilceSystemFinished final
{
public:
	class UParticleSystemComponent*               FinishedComponent;                                 // 0x0000(0x0008)(Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(MM_EffectManager_OnPartilceSystemFinished) == 0x000008, "Wrong alignment on MM_EffectManager_OnPartilceSystemFinished");
static_assert(sizeof(MM_EffectManager_OnPartilceSystemFinished) == 0x000008, "Wrong size on MM_EffectManager_OnPartilceSystemFinished");
static_assert(offsetof(MM_EffectManager_OnPartilceSystemFinished, FinishedComponent) == 0x000000, "Member 'MM_EffectManager_OnPartilceSystemFinished::FinishedComponent' has a wrong offset!");

// Function MirMobile.MM_EmotesWidget.CreateEmotesSlot
// 0x0010 (0x0010 - 0x0000)
struct MM_EmotesWidget_CreateEmotesSlot final
{
public:
	TArray<struct FEmoteSlotInfo>                 EmoteInfoArray;                                    // 0x0000(0x0010)(ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, NativeAccessSpecifierPublic)
};
static_assert(alignof(MM_EmotesWidget_CreateEmotesSlot) == 0x000008, "Wrong alignment on MM_EmotesWidget_CreateEmotesSlot");
static_assert(sizeof(MM_EmotesWidget_CreateEmotesSlot) == 0x000010, "Wrong size on MM_EmotesWidget_CreateEmotesSlot");
static_assert(offsetof(MM_EmotesWidget_CreateEmotesSlot, EmoteInfoArray) == 0x000000, "Member 'MM_EmotesWidget_CreateEmotesSlot::EmoteInfoArray' has a wrong offset!");

// Function MirMobile.MM_EmotesWidget.OnClickEmoteButton
// 0x0004 (0x0004 - 0x0000)
struct MM_EmotesWidget_OnClickEmoteButton final
{
public:
	int32                                         EmoteID;                                           // 0x0000(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(MM_EmotesWidget_OnClickEmoteButton) == 0x000004, "Wrong alignment on MM_EmotesWidget_OnClickEmoteButton");
static_assert(sizeof(MM_EmotesWidget_OnClickEmoteButton) == 0x000004, "Wrong size on MM_EmotesWidget_OnClickEmoteButton");
static_assert(offsetof(MM_EmotesWidget_OnClickEmoteButton, EmoteID) == 0x000000, "Member 'MM_EmotesWidget_OnClickEmoteButton::EmoteID' has a wrong offset!");

// Function MirMobile.MM_EmotesWidget.UpdateEmotionSlotText
// 0x0020 (0x0020 - 0x0000)
struct MM_EmotesWidget_UpdateEmotionSlotText final
{
public:
	class UWidget*                                EmoteSlot;                                         // 0x0000(0x0008)(Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FText                                   NameText;                                          // 0x0008(0x0018)(ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
};
static_assert(alignof(MM_EmotesWidget_UpdateEmotionSlotText) == 0x000008, "Wrong alignment on MM_EmotesWidget_UpdateEmotionSlotText");
static_assert(sizeof(MM_EmotesWidget_UpdateEmotionSlotText) == 0x000020, "Wrong size on MM_EmotesWidget_UpdateEmotionSlotText");
static_assert(offsetof(MM_EmotesWidget_UpdateEmotionSlotText, EmoteSlot) == 0x000000, "Member 'MM_EmotesWidget_UpdateEmotionSlotText::EmoteSlot' has a wrong offset!");
static_assert(offsetof(MM_EmotesWidget_UpdateEmotionSlotText, NameText) == 0x000008, "Member 'MM_EmotesWidget_UpdateEmotionSlotText::NameText' has a wrong offset!");

// Function MirMobile.MM_EntityObject.ChangeCurrentFSM
// 0x0001 (0x0001 - 0x0000)
struct MM_EntityObject_ChangeCurrentFSM final
{
public:
	EFSM_TYPE                                     NewFSM;                                            // 0x0000(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(MM_EntityObject_ChangeCurrentFSM) == 0x000001, "Wrong alignment on MM_EntityObject_ChangeCurrentFSM");
static_assert(sizeof(MM_EntityObject_ChangeCurrentFSM) == 0x000001, "Wrong size on MM_EntityObject_ChangeCurrentFSM");
static_assert(offsetof(MM_EntityObject_ChangeCurrentFSM, NewFSM) == 0x000000, "Member 'MM_EntityObject_ChangeCurrentFSM::NewFSM' has a wrong offset!");

// Function MirMobile.MM_EntityObject.GetCurrentFSM
// 0x0001 (0x0001 - 0x0000)
struct MM_EntityObject_GetCurrentFSM final
{
public:
	EFSM_TYPE                                     ReturnValue;                                       // 0x0000(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(MM_EntityObject_GetCurrentFSM) == 0x000001, "Wrong alignment on MM_EntityObject_GetCurrentFSM");
static_assert(sizeof(MM_EntityObject_GetCurrentFSM) == 0x000001, "Wrong size on MM_EntityObject_GetCurrentFSM");
static_assert(offsetof(MM_EntityObject_GetCurrentFSM, ReturnValue) == 0x000000, "Member 'MM_EntityObject_GetCurrentFSM::ReturnValue' has a wrong offset!");

// Function MirMobile.MM_PopUp_EquipAuto.OnClickInvenSlot
// 0x0008 (0x0008 - 0x0000)
struct MM_PopUp_EquipAuto_OnClickInvenSlot final
{
public:
	int64                                         ItemUID;                                           // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(MM_PopUp_EquipAuto_OnClickInvenSlot) == 0x000008, "Wrong alignment on MM_PopUp_EquipAuto_OnClickInvenSlot");
static_assert(sizeof(MM_PopUp_EquipAuto_OnClickInvenSlot) == 0x000008, "Wrong size on MM_PopUp_EquipAuto_OnClickInvenSlot");
static_assert(offsetof(MM_PopUp_EquipAuto_OnClickInvenSlot, ItemUID) == 0x000000, "Member 'MM_PopUp_EquipAuto_OnClickInvenSlot::ItemUID' has a wrong offset!");

// Function MirMobile.MM_GameOption_PC.OnClickTab
// 0x0008 (0x0008 - 0x0000)
struct MM_GameOption_PC_OnClickTab final
{
public:
	int32                                         TabIndex;                                          // 0x0000(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bLocked;                                           // 0x0004(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_5[0x3];                                        // 0x0005(0x0003)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(MM_GameOption_PC_OnClickTab) == 0x000004, "Wrong alignment on MM_GameOption_PC_OnClickTab");
static_assert(sizeof(MM_GameOption_PC_OnClickTab) == 0x000008, "Wrong size on MM_GameOption_PC_OnClickTab");
static_assert(offsetof(MM_GameOption_PC_OnClickTab, TabIndex) == 0x000000, "Member 'MM_GameOption_PC_OnClickTab::TabIndex' has a wrong offset!");
static_assert(offsetof(MM_GameOption_PC_OnClickTab, bLocked) == 0x000004, "Member 'MM_GameOption_PC_OnClickTab::bLocked' has a wrong offset!");

// Function MirMobile.MM_Popup_Durability.PlayEndAnimation
// 0x0004 (0x0004 - 0x0000)
struct MM_Popup_Durability_PlayEndAnimation final
{
public:
	float                                         ReturnValue;                                       // 0x0000(0x0004)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(MM_Popup_Durability_PlayEndAnimation) == 0x000004, "Wrong alignment on MM_Popup_Durability_PlayEndAnimation");
static_assert(sizeof(MM_Popup_Durability_PlayEndAnimation) == 0x000004, "Wrong size on MM_Popup_Durability_PlayEndAnimation");
static_assert(offsetof(MM_Popup_Durability_PlayEndAnimation, ReturnValue) == 0x000000, "Member 'MM_Popup_Durability_PlayEndAnimation::ReturnValue' has a wrong offset!");

// Function MirMobile.MM_Popup_Durability.PlayStartAnimation
// 0x0004 (0x0004 - 0x0000)
struct MM_Popup_Durability_PlayStartAnimation final
{
public:
	float                                         ReturnValue;                                       // 0x0000(0x0004)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(MM_Popup_Durability_PlayStartAnimation) == 0x000004, "Wrong alignment on MM_Popup_Durability_PlayStartAnimation");
static_assert(sizeof(MM_Popup_Durability_PlayStartAnimation) == 0x000004, "Wrong size on MM_Popup_Durability_PlayStartAnimation");
static_assert(offsetof(MM_Popup_Durability_PlayStartAnimation, ReturnValue) == 0x000000, "Member 'MM_Popup_Durability_PlayStartAnimation::ReturnValue' has a wrong offset!");

// Function MirMobile.MM_Guild_Diplomacy.OnChangedWorld
// 0x0010 (0x0010 - 0x0000)
struct MM_Guild_Diplomacy_OnChangedWorld final
{
public:
	class FString                                 World_name_;                                       // 0x0000(0x0010)(Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(MM_Guild_Diplomacy_OnChangedWorld) == 0x000008, "Wrong alignment on MM_Guild_Diplomacy_OnChangedWorld");
static_assert(sizeof(MM_Guild_Diplomacy_OnChangedWorld) == 0x000010, "Wrong size on MM_Guild_Diplomacy_OnChangedWorld");
static_assert(offsetof(MM_Guild_Diplomacy_OnChangedWorld, World_name_) == 0x000000, "Member 'MM_Guild_Diplomacy_OnChangedWorld::World_name_' has a wrong offset!");

// Function MirMobile.MM_Guild_Diplomacy.OnClickedVerticalTab
// 0x0008 (0x0008 - 0x0000)
struct MM_Guild_Diplomacy_OnClickedVerticalTab final
{
public:
	int32                                         Index_0;                                           // 0x0000(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bLocked;                                           // 0x0004(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_5[0x3];                                        // 0x0005(0x0003)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(MM_Guild_Diplomacy_OnClickedVerticalTab) == 0x000004, "Wrong alignment on MM_Guild_Diplomacy_OnClickedVerticalTab");
static_assert(sizeof(MM_Guild_Diplomacy_OnClickedVerticalTab) == 0x000008, "Wrong size on MM_Guild_Diplomacy_OnClickedVerticalTab");
static_assert(offsetof(MM_Guild_Diplomacy_OnClickedVerticalTab, Index_0) == 0x000000, "Member 'MM_Guild_Diplomacy_OnClickedVerticalTab::Index_0' has a wrong offset!");
static_assert(offsetof(MM_Guild_Diplomacy_OnClickedVerticalTab, bLocked) == 0x000004, "Member 'MM_Guild_Diplomacy_OnClickedVerticalTab::bLocked' has a wrong offset!");

// Function MirMobile.MM_FirstTutorialScript.ShowVirtualJoyStickTutorial
// 0x0001 (0x0001 - 0x0000)
struct MM_FirstTutorialScript_ShowVirtualJoyStickTutorial final
{
public:
	bool                                          bShow;                                             // 0x0000(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(MM_FirstTutorialScript_ShowVirtualJoyStickTutorial) == 0x000001, "Wrong alignment on MM_FirstTutorialScript_ShowVirtualJoyStickTutorial");
static_assert(sizeof(MM_FirstTutorialScript_ShowVirtualJoyStickTutorial) == 0x000001, "Wrong size on MM_FirstTutorialScript_ShowVirtualJoyStickTutorial");
static_assert(offsetof(MM_FirstTutorialScript_ShowVirtualJoyStickTutorial, bShow) == 0x000000, "Member 'MM_FirstTutorialScript_ShowVirtualJoyStickTutorial::bShow' has a wrong offset!");

// Function MirMobile.MM_GuildMemberSlotByGrade.OnClickCheckBox
// 0x0001 (0x0001 - 0x0000)
struct MM_GuildMemberSlotByGrade_OnClickCheckBox final
{
public:
	bool                                          Check_state_;                                      // 0x0000(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(MM_GuildMemberSlotByGrade_OnClickCheckBox) == 0x000001, "Wrong alignment on MM_GuildMemberSlotByGrade_OnClickCheckBox");
static_assert(sizeof(MM_GuildMemberSlotByGrade_OnClickCheckBox) == 0x000001, "Wrong size on MM_GuildMemberSlotByGrade_OnClickCheckBox");
static_assert(offsetof(MM_GuildMemberSlotByGrade_OnClickCheckBox, Check_state_) == 0x000000, "Member 'MM_GuildMemberSlotByGrade_OnClickCheckBox::Check_state_' has a wrong offset!");

// Function MirMobile.MM_NPCBase.OnInteractionBeginOverlap
// 0x00A8 (0x00A8 - 0x0000)
struct MM_NPCBase_OnInteractionBeginOverlap final
{
public:
	class UPrimitiveComponent*                    OverlappedComponent;                               // 0x0000(0x0008)(Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class AActor*                                 POtherActor;                                       // 0x0008(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UPrimitiveComponent*                    OtherComponent;                                    // 0x0010(0x0008)(Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         OtherBodyIndex;                                    // 0x0018(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bFromSweep;                                        // 0x001C(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1D[0x3];                                       // 0x001D(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	struct FHitResult                             SweepResult;                                       // 0x0020(0x0088)(ConstParm, Parm, OutParm, ReferenceParm, IsPlainOldData, NoDestructor, ContainsInstancedReference, NativeAccessSpecifierPublic)
};
static_assert(alignof(MM_NPCBase_OnInteractionBeginOverlap) == 0x000008, "Wrong alignment on MM_NPCBase_OnInteractionBeginOverlap");
static_assert(sizeof(MM_NPCBase_OnInteractionBeginOverlap) == 0x0000A8, "Wrong size on MM_NPCBase_OnInteractionBeginOverlap");
static_assert(offsetof(MM_NPCBase_OnInteractionBeginOverlap, OverlappedComponent) == 0x000000, "Member 'MM_NPCBase_OnInteractionBeginOverlap::OverlappedComponent' has a wrong offset!");
static_assert(offsetof(MM_NPCBase_OnInteractionBeginOverlap, POtherActor) == 0x000008, "Member 'MM_NPCBase_OnInteractionBeginOverlap::POtherActor' has a wrong offset!");
static_assert(offsetof(MM_NPCBase_OnInteractionBeginOverlap, OtherComponent) == 0x000010, "Member 'MM_NPCBase_OnInteractionBeginOverlap::OtherComponent' has a wrong offset!");
static_assert(offsetof(MM_NPCBase_OnInteractionBeginOverlap, OtherBodyIndex) == 0x000018, "Member 'MM_NPCBase_OnInteractionBeginOverlap::OtherBodyIndex' has a wrong offset!");
static_assert(offsetof(MM_NPCBase_OnInteractionBeginOverlap, bFromSweep) == 0x00001C, "Member 'MM_NPCBase_OnInteractionBeginOverlap::bFromSweep' has a wrong offset!");
static_assert(offsetof(MM_NPCBase_OnInteractionBeginOverlap, SweepResult) == 0x000020, "Member 'MM_NPCBase_OnInteractionBeginOverlap::SweepResult' has a wrong offset!");

// Function MirMobile.MM_NPCBase.OnInteractionEndOverlap
// 0x0020 (0x0020 - 0x0000)
struct MM_NPCBase_OnInteractionEndOverlap final
{
public:
	class UPrimitiveComponent*                    OverlappedComponent;                               // 0x0000(0x0008)(Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class AActor*                                 POtherActor;                                       // 0x0008(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UPrimitiveComponent*                    OtherComponent;                                    // 0x0010(0x0008)(Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         OtherBodyIndex;                                    // 0x0018(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1C[0x4];                                       // 0x001C(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(MM_NPCBase_OnInteractionEndOverlap) == 0x000008, "Wrong alignment on MM_NPCBase_OnInteractionEndOverlap");
static_assert(sizeof(MM_NPCBase_OnInteractionEndOverlap) == 0x000020, "Wrong size on MM_NPCBase_OnInteractionEndOverlap");
static_assert(offsetof(MM_NPCBase_OnInteractionEndOverlap, OverlappedComponent) == 0x000000, "Member 'MM_NPCBase_OnInteractionEndOverlap::OverlappedComponent' has a wrong offset!");
static_assert(offsetof(MM_NPCBase_OnInteractionEndOverlap, POtherActor) == 0x000008, "Member 'MM_NPCBase_OnInteractionEndOverlap::POtherActor' has a wrong offset!");
static_assert(offsetof(MM_NPCBase_OnInteractionEndOverlap, OtherComponent) == 0x000010, "Member 'MM_NPCBase_OnInteractionEndOverlap::OtherComponent' has a wrong offset!");
static_assert(offsetof(MM_NPCBase_OnInteractionEndOverlap, OtherBodyIndex) == 0x000018, "Member 'MM_NPCBase_OnInteractionEndOverlap::OtherBodyIndex' has a wrong offset!");

// Function MirMobile.MM_NPCBase.OnSightBeginOverlap
// 0x00A8 (0x00A8 - 0x0000)
struct MM_NPCBase_OnSightBeginOverlap final
{
public:
	class UPrimitiveComponent*                    OverlappedComponent;                               // 0x0000(0x0008)(Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class AActor*                                 POtherActor;                                       // 0x0008(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UPrimitiveComponent*                    OtherComponent;                                    // 0x0010(0x0008)(Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         OtherBodyIndex;                                    // 0x0018(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bFromSweep;                                        // 0x001C(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1D[0x3];                                       // 0x001D(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	struct FHitResult                             SweepResult;                                       // 0x0020(0x0088)(ConstParm, Parm, OutParm, ReferenceParm, IsPlainOldData, NoDestructor, ContainsInstancedReference, NativeAccessSpecifierPublic)
};
static_assert(alignof(MM_NPCBase_OnSightBeginOverlap) == 0x000008, "Wrong alignment on MM_NPCBase_OnSightBeginOverlap");
static_assert(sizeof(MM_NPCBase_OnSightBeginOverlap) == 0x0000A8, "Wrong size on MM_NPCBase_OnSightBeginOverlap");
static_assert(offsetof(MM_NPCBase_OnSightBeginOverlap, OverlappedComponent) == 0x000000, "Member 'MM_NPCBase_OnSightBeginOverlap::OverlappedComponent' has a wrong offset!");
static_assert(offsetof(MM_NPCBase_OnSightBeginOverlap, POtherActor) == 0x000008, "Member 'MM_NPCBase_OnSightBeginOverlap::POtherActor' has a wrong offset!");
static_assert(offsetof(MM_NPCBase_OnSightBeginOverlap, OtherComponent) == 0x000010, "Member 'MM_NPCBase_OnSightBeginOverlap::OtherComponent' has a wrong offset!");
static_assert(offsetof(MM_NPCBase_OnSightBeginOverlap, OtherBodyIndex) == 0x000018, "Member 'MM_NPCBase_OnSightBeginOverlap::OtherBodyIndex' has a wrong offset!");
static_assert(offsetof(MM_NPCBase_OnSightBeginOverlap, bFromSweep) == 0x00001C, "Member 'MM_NPCBase_OnSightBeginOverlap::bFromSweep' has a wrong offset!");
static_assert(offsetof(MM_NPCBase_OnSightBeginOverlap, SweepResult) == 0x000020, "Member 'MM_NPCBase_OnSightBeginOverlap::SweepResult' has a wrong offset!");

// Function MirMobile.MM_NPCBase.OnSightEndOverlap
// 0x0020 (0x0020 - 0x0000)
struct MM_NPCBase_OnSightEndOverlap final
{
public:
	class UPrimitiveComponent*                    OverlappedComponent;                               // 0x0000(0x0008)(Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class AActor*                                 POtherActor;                                       // 0x0008(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UPrimitiveComponent*                    OtherComponent;                                    // 0x0010(0x0008)(Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         OtherBodyIndex;                                    // 0x0018(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1C[0x4];                                       // 0x001C(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(MM_NPCBase_OnSightEndOverlap) == 0x000008, "Wrong alignment on MM_NPCBase_OnSightEndOverlap");
static_assert(sizeof(MM_NPCBase_OnSightEndOverlap) == 0x000020, "Wrong size on MM_NPCBase_OnSightEndOverlap");
static_assert(offsetof(MM_NPCBase_OnSightEndOverlap, OverlappedComponent) == 0x000000, "Member 'MM_NPCBase_OnSightEndOverlap::OverlappedComponent' has a wrong offset!");
static_assert(offsetof(MM_NPCBase_OnSightEndOverlap, POtherActor) == 0x000008, "Member 'MM_NPCBase_OnSightEndOverlap::POtherActor' has a wrong offset!");
static_assert(offsetof(MM_NPCBase_OnSightEndOverlap, OtherComponent) == 0x000010, "Member 'MM_NPCBase_OnSightEndOverlap::OtherComponent' has a wrong offset!");
static_assert(offsetof(MM_NPCBase_OnSightEndOverlap, OtherBodyIndex) == 0x000018, "Member 'MM_NPCBase_OnSightEndOverlap::OtherBodyIndex' has a wrong offset!");

// Function MirMobile.MM_Friend_ListSlot.OnClickCheckBoxFavorite
// 0x0001 (0x0001 - 0x0000)
struct MM_Friend_ListSlot_OnClickCheckBoxFavorite final
{
public:
	bool                                          bChecked;                                          // 0x0000(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(MM_Friend_ListSlot_OnClickCheckBoxFavorite) == 0x000001, "Wrong alignment on MM_Friend_ListSlot_OnClickCheckBoxFavorite");
static_assert(sizeof(MM_Friend_ListSlot_OnClickCheckBoxFavorite) == 0x000001, "Wrong size on MM_Friend_ListSlot_OnClickCheckBoxFavorite");
static_assert(offsetof(MM_Friend_ListSlot_OnClickCheckBoxFavorite, bChecked) == 0x000000, "Member 'MM_Friend_ListSlot_OnClickCheckBoxFavorite::bChecked' has a wrong offset!");

// Function MirMobile.MM_GachaObjectActor.SetGachaNameTag
// 0x0018 (0x0018 - 0x0000)
struct MM_GachaObjectActor_SetGachaNameTag final
{
public:
	class FString                                 RewardName;                                        // 0x0000(0x0010)(Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         ItemGrade;                                         // 0x0010(0x0004)(ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_14[0x4];                                       // 0x0014(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(MM_GachaObjectActor_SetGachaNameTag) == 0x000008, "Wrong alignment on MM_GachaObjectActor_SetGachaNameTag");
static_assert(sizeof(MM_GachaObjectActor_SetGachaNameTag) == 0x000018, "Wrong size on MM_GachaObjectActor_SetGachaNameTag");
static_assert(offsetof(MM_GachaObjectActor_SetGachaNameTag, RewardName) == 0x000000, "Member 'MM_GachaObjectActor_SetGachaNameTag::RewardName' has a wrong offset!");
static_assert(offsetof(MM_GachaObjectActor_SetGachaNameTag, ItemGrade) == 0x000010, "Member 'MM_GachaObjectActor_SetGachaNameTag::ItemGrade' has a wrong offset!");

// Function MirMobile.MM_GachaObjectActor.SetGachaObjectData
// 0x000C (0x000C - 0x0000)
struct MM_GachaObjectActor_SetGachaObjectData final
{
public:
	EGachaType                                    GachaType;                                         // 0x0000(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EGachaResultType                              GachaResultType;                                   // 0x0001(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2[0x2];                                        // 0x0002(0x0002)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         ItemId;                                            // 0x0004(0x0004)(ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         ItemGrade;                                         // 0x0008(0x0004)(ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(MM_GachaObjectActor_SetGachaObjectData) == 0x000004, "Wrong alignment on MM_GachaObjectActor_SetGachaObjectData");
static_assert(sizeof(MM_GachaObjectActor_SetGachaObjectData) == 0x00000C, "Wrong size on MM_GachaObjectActor_SetGachaObjectData");
static_assert(offsetof(MM_GachaObjectActor_SetGachaObjectData, GachaType) == 0x000000, "Member 'MM_GachaObjectActor_SetGachaObjectData::GachaType' has a wrong offset!");
static_assert(offsetof(MM_GachaObjectActor_SetGachaObjectData, GachaResultType) == 0x000001, "Member 'MM_GachaObjectActor_SetGachaObjectData::GachaResultType' has a wrong offset!");
static_assert(offsetof(MM_GachaObjectActor_SetGachaObjectData, ItemId) == 0x000004, "Member 'MM_GachaObjectActor_SetGachaObjectData::ItemId' has a wrong offset!");
static_assert(offsetof(MM_GachaObjectActor_SetGachaObjectData, ItemGrade) == 0x000008, "Member 'MM_GachaObjectActor_SetGachaObjectData::ItemGrade' has a wrong offset!");

// Function MirMobile.MM_GachaObjectActor.SetGachaSpriteSize
// 0x0001 (0x0001 - 0x0000)
struct MM_GachaObjectActor_SetGachaSpriteSize final
{
public:
	EGachaType                                    GachaType;                                         // 0x0000(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(MM_GachaObjectActor_SetGachaSpriteSize) == 0x000001, "Wrong alignment on MM_GachaObjectActor_SetGachaSpriteSize");
static_assert(sizeof(MM_GachaObjectActor_SetGachaSpriteSize) == 0x000001, "Wrong size on MM_GachaObjectActor_SetGachaSpriteSize");
static_assert(offsetof(MM_GachaObjectActor_SetGachaSpriteSize, GachaType) == 0x000000, "Member 'MM_GachaObjectActor_SetGachaSpriteSize::GachaType' has a wrong offset!");

// Function MirMobile.MM_GachaObjectActor.SpawnGachaOpenParticle
// 0x0008 (0x0008 - 0x0000)
struct MM_GachaObjectActor_SpawnGachaOpenParticle final
{
public:
	class UParticleSystem*                        PParticle;                                         // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(MM_GachaObjectActor_SpawnGachaOpenParticle) == 0x000008, "Wrong alignment on MM_GachaObjectActor_SpawnGachaOpenParticle");
static_assert(sizeof(MM_GachaObjectActor_SpawnGachaOpenParticle) == 0x000008, "Wrong size on MM_GachaObjectActor_SpawnGachaOpenParticle");
static_assert(offsetof(MM_GachaObjectActor_SpawnGachaOpenParticle, PParticle) == 0x000000, "Member 'MM_GachaObjectActor_SpawnGachaOpenParticle::PParticle' has a wrong offset!");

// Function MirMobile.MM_GachaObjectActor.StartMaterialEffectEvent
// 0x0001 (0x0001 - 0x0000)
struct MM_GachaObjectActor_StartMaterialEffectEvent final
{
public:
	bool                                          bLegend;                                           // 0x0000(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(MM_GachaObjectActor_StartMaterialEffectEvent) == 0x000001, "Wrong alignment on MM_GachaObjectActor_StartMaterialEffectEvent");
static_assert(sizeof(MM_GachaObjectActor_StartMaterialEffectEvent) == 0x000001, "Wrong size on MM_GachaObjectActor_StartMaterialEffectEvent");
static_assert(offsetof(MM_GachaObjectActor_StartMaterialEffectEvent, bLegend) == 0x000000, "Member 'MM_GachaObjectActor_StartMaterialEffectEvent::bLegend' has a wrong offset!");

// Function MirMobile.MM_ServerRelocationGroup_Global.OnClickCheckBox
// 0x0001 (0x0001 - 0x0000)
struct MM_ServerRelocationGroup_Global_OnClickCheckBox final
{
public:
	bool                                          bChecked;                                          // 0x0000(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(MM_ServerRelocationGroup_Global_OnClickCheckBox) == 0x000001, "Wrong alignment on MM_ServerRelocationGroup_Global_OnClickCheckBox");
static_assert(sizeof(MM_ServerRelocationGroup_Global_OnClickCheckBox) == 0x000001, "Wrong size on MM_ServerRelocationGroup_Global_OnClickCheckBox");
static_assert(offsetof(MM_ServerRelocationGroup_Global_OnClickCheckBox, bChecked) == 0x000000, "Member 'MM_ServerRelocationGroup_Global_OnClickCheckBox::bChecked' has a wrong offset!");

// Function MirMobile.MM_GameOption_Slider.OnDragSlider
// 0x0004 (0x0004 - 0x0000)
struct MM_GameOption_Slider_OnDragSlider final
{
public:
	float                                         FRatio;                                            // 0x0000(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(MM_GameOption_Slider_OnDragSlider) == 0x000004, "Wrong alignment on MM_GameOption_Slider_OnDragSlider");
static_assert(sizeof(MM_GameOption_Slider_OnDragSlider) == 0x000004, "Wrong size on MM_GameOption_Slider_OnDragSlider");
static_assert(offsetof(MM_GameOption_Slider_OnDragSlider, FRatio) == 0x000000, "Member 'MM_GameOption_Slider_OnDragSlider::FRatio' has a wrong offset!");

// Function MirMobile.MM_GameOption_UI.OnClickGuildMarkOption
// 0x0001 (0x0001 - 0x0000)
struct MM_GameOption_UI_OnClickGuildMarkOption final
{
public:
	bool                                          bChecked;                                          // 0x0000(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(MM_GameOption_UI_OnClickGuildMarkOption) == 0x000001, "Wrong alignment on MM_GameOption_UI_OnClickGuildMarkOption");
static_assert(sizeof(MM_GameOption_UI_OnClickGuildMarkOption) == 0x000001, "Wrong size on MM_GameOption_UI_OnClickGuildMarkOption");
static_assert(offsetof(MM_GameOption_UI_OnClickGuildMarkOption, bChecked) == 0x000000, "Member 'MM_GameOption_UI_OnClickGuildMarkOption::bChecked' has a wrong offset!");

// Function MirMobile.MM_GameOption_UI.OnClickMonNameOption1
// 0x0001 (0x0001 - 0x0000)
struct MM_GameOption_UI_OnClickMonNameOption1 final
{
public:
	bool                                          bChecked;                                          // 0x0000(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(MM_GameOption_UI_OnClickMonNameOption1) == 0x000001, "Wrong alignment on MM_GameOption_UI_OnClickMonNameOption1");
static_assert(sizeof(MM_GameOption_UI_OnClickMonNameOption1) == 0x000001, "Wrong size on MM_GameOption_UI_OnClickMonNameOption1");
static_assert(offsetof(MM_GameOption_UI_OnClickMonNameOption1, bChecked) == 0x000000, "Member 'MM_GameOption_UI_OnClickMonNameOption1::bChecked' has a wrong offset!");

// Function MirMobile.MM_GameOption_UI.OnClickMonNameOption2
// 0x0001 (0x0001 - 0x0000)
struct MM_GameOption_UI_OnClickMonNameOption2 final
{
public:
	bool                                          bChecked;                                          // 0x0000(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(MM_GameOption_UI_OnClickMonNameOption2) == 0x000001, "Wrong alignment on MM_GameOption_UI_OnClickMonNameOption2");
static_assert(sizeof(MM_GameOption_UI_OnClickMonNameOption2) == 0x000001, "Wrong size on MM_GameOption_UI_OnClickMonNameOption2");
static_assert(offsetof(MM_GameOption_UI_OnClickMonNameOption2, bChecked) == 0x000000, "Member 'MM_GameOption_UI_OnClickMonNameOption2::bChecked' has a wrong offset!");

// Function MirMobile.MM_GameOption_UI.OnClickMonNameOption3
// 0x0001 (0x0001 - 0x0000)
struct MM_GameOption_UI_OnClickMonNameOption3 final
{
public:
	bool                                          bChecked;                                          // 0x0000(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(MM_GameOption_UI_OnClickMonNameOption3) == 0x000001, "Wrong alignment on MM_GameOption_UI_OnClickMonNameOption3");
static_assert(sizeof(MM_GameOption_UI_OnClickMonNameOption3) == 0x000001, "Wrong size on MM_GameOption_UI_OnClickMonNameOption3");
static_assert(offsetof(MM_GameOption_UI_OnClickMonNameOption3, bChecked) == 0x000000, "Member 'MM_GameOption_UI_OnClickMonNameOption3::bChecked' has a wrong offset!");

// Function MirMobile.MM_GameOption_UI.OnClickMyHpBarOption
// 0x0001 (0x0001 - 0x0000)
struct MM_GameOption_UI_OnClickMyHpBarOption final
{
public:
	bool                                          bChecked;                                          // 0x0000(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(MM_GameOption_UI_OnClickMyHpBarOption) == 0x000001, "Wrong alignment on MM_GameOption_UI_OnClickMyHpBarOption");
static_assert(sizeof(MM_GameOption_UI_OnClickMyHpBarOption) == 0x000001, "Wrong size on MM_GameOption_UI_OnClickMyHpBarOption");
static_assert(offsetof(MM_GameOption_UI_OnClickMyHpBarOption, bChecked) == 0x000000, "Member 'MM_GameOption_UI_OnClickMyHpBarOption::bChecked' has a wrong offset!");

// Function MirMobile.MM_GameOption_UI.OnClickMyNameOption1
// 0x0001 (0x0001 - 0x0000)
struct MM_GameOption_UI_OnClickMyNameOption1 final
{
public:
	bool                                          bChecked;                                          // 0x0000(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(MM_GameOption_UI_OnClickMyNameOption1) == 0x000001, "Wrong alignment on MM_GameOption_UI_OnClickMyNameOption1");
static_assert(sizeof(MM_GameOption_UI_OnClickMyNameOption1) == 0x000001, "Wrong size on MM_GameOption_UI_OnClickMyNameOption1");
static_assert(offsetof(MM_GameOption_UI_OnClickMyNameOption1, bChecked) == 0x000000, "Member 'MM_GameOption_UI_OnClickMyNameOption1::bChecked' has a wrong offset!");

// Function MirMobile.MM_GameOption_UI.OnClickMyNameOption2
// 0x0001 (0x0001 - 0x0000)
struct MM_GameOption_UI_OnClickMyNameOption2 final
{
public:
	bool                                          bChecked;                                          // 0x0000(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(MM_GameOption_UI_OnClickMyNameOption2) == 0x000001, "Wrong alignment on MM_GameOption_UI_OnClickMyNameOption2");
static_assert(sizeof(MM_GameOption_UI_OnClickMyNameOption2) == 0x000001, "Wrong size on MM_GameOption_UI_OnClickMyNameOption2");
static_assert(offsetof(MM_GameOption_UI_OnClickMyNameOption2, bChecked) == 0x000000, "Member 'MM_GameOption_UI_OnClickMyNameOption2::bChecked' has a wrong offset!");

// Function MirMobile.MM_GameOption_UI.OnClickMyNameOption3
// 0x0001 (0x0001 - 0x0000)
struct MM_GameOption_UI_OnClickMyNameOption3 final
{
public:
	bool                                          bChecked;                                          // 0x0000(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(MM_GameOption_UI_OnClickMyNameOption3) == 0x000001, "Wrong alignment on MM_GameOption_UI_OnClickMyNameOption3");
static_assert(sizeof(MM_GameOption_UI_OnClickMyNameOption3) == 0x000001, "Wrong size on MM_GameOption_UI_OnClickMyNameOption3");
static_assert(offsetof(MM_GameOption_UI_OnClickMyNameOption3, bChecked) == 0x000000, "Member 'MM_GameOption_UI_OnClickMyNameOption3::bChecked' has a wrong offset!");

// Function MirMobile.MM_GameOption_UI.OnClickUserHpBarOption1
// 0x0001 (0x0001 - 0x0000)
struct MM_GameOption_UI_OnClickUserHpBarOption1 final
{
public:
	bool                                          bChecked;                                          // 0x0000(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(MM_GameOption_UI_OnClickUserHpBarOption1) == 0x000001, "Wrong alignment on MM_GameOption_UI_OnClickUserHpBarOption1");
static_assert(sizeof(MM_GameOption_UI_OnClickUserHpBarOption1) == 0x000001, "Wrong size on MM_GameOption_UI_OnClickUserHpBarOption1");
static_assert(offsetof(MM_GameOption_UI_OnClickUserHpBarOption1, bChecked) == 0x000000, "Member 'MM_GameOption_UI_OnClickUserHpBarOption1::bChecked' has a wrong offset!");

// Function MirMobile.MM_GameOption_UI.OnClickUserHpBarOption2
// 0x0001 (0x0001 - 0x0000)
struct MM_GameOption_UI_OnClickUserHpBarOption2 final
{
public:
	bool                                          bChecked;                                          // 0x0000(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(MM_GameOption_UI_OnClickUserHpBarOption2) == 0x000001, "Wrong alignment on MM_GameOption_UI_OnClickUserHpBarOption2");
static_assert(sizeof(MM_GameOption_UI_OnClickUserHpBarOption2) == 0x000001, "Wrong size on MM_GameOption_UI_OnClickUserHpBarOption2");
static_assert(offsetof(MM_GameOption_UI_OnClickUserHpBarOption2, bChecked) == 0x000000, "Member 'MM_GameOption_UI_OnClickUserHpBarOption2::bChecked' has a wrong offset!");

// Function MirMobile.MM_GameOption_UI.OnClickUserHpBarOption3
// 0x0001 (0x0001 - 0x0000)
struct MM_GameOption_UI_OnClickUserHpBarOption3 final
{
public:
	bool                                          bChecked;                                          // 0x0000(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(MM_GameOption_UI_OnClickUserHpBarOption3) == 0x000001, "Wrong alignment on MM_GameOption_UI_OnClickUserHpBarOption3");
static_assert(sizeof(MM_GameOption_UI_OnClickUserHpBarOption3) == 0x000001, "Wrong size on MM_GameOption_UI_OnClickUserHpBarOption3");
static_assert(offsetof(MM_GameOption_UI_OnClickUserHpBarOption3, bChecked) == 0x000000, "Member 'MM_GameOption_UI_OnClickUserHpBarOption3::bChecked' has a wrong offset!");

// Function MirMobile.MM_GameOption_UI.OnClickUserNameOption1
// 0x0001 (0x0001 - 0x0000)
struct MM_GameOption_UI_OnClickUserNameOption1 final
{
public:
	bool                                          bChecked;                                          // 0x0000(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(MM_GameOption_UI_OnClickUserNameOption1) == 0x000001, "Wrong alignment on MM_GameOption_UI_OnClickUserNameOption1");
static_assert(sizeof(MM_GameOption_UI_OnClickUserNameOption1) == 0x000001, "Wrong size on MM_GameOption_UI_OnClickUserNameOption1");
static_assert(offsetof(MM_GameOption_UI_OnClickUserNameOption1, bChecked) == 0x000000, "Member 'MM_GameOption_UI_OnClickUserNameOption1::bChecked' has a wrong offset!");

// Function MirMobile.MM_GameOption_UI.OnClickUserNameOption2
// 0x0001 (0x0001 - 0x0000)
struct MM_GameOption_UI_OnClickUserNameOption2 final
{
public:
	bool                                          bChecked;                                          // 0x0000(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(MM_GameOption_UI_OnClickUserNameOption2) == 0x000001, "Wrong alignment on MM_GameOption_UI_OnClickUserNameOption2");
static_assert(sizeof(MM_GameOption_UI_OnClickUserNameOption2) == 0x000001, "Wrong size on MM_GameOption_UI_OnClickUserNameOption2");
static_assert(offsetof(MM_GameOption_UI_OnClickUserNameOption2, bChecked) == 0x000000, "Member 'MM_GameOption_UI_OnClickUserNameOption2::bChecked' has a wrong offset!");

// Function MirMobile.MM_GameOption_UI.OnClickUserNameOption3
// 0x0001 (0x0001 - 0x0000)
struct MM_GameOption_UI_OnClickUserNameOption3 final
{
public:
	bool                                          bChecked;                                          // 0x0000(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(MM_GameOption_UI_OnClickUserNameOption3) == 0x000001, "Wrong alignment on MM_GameOption_UI_OnClickUserNameOption3");
static_assert(sizeof(MM_GameOption_UI_OnClickUserNameOption3) == 0x000001, "Wrong size on MM_GameOption_UI_OnClickUserNameOption3");
static_assert(offsetof(MM_GameOption_UI_OnClickUserNameOption3, bChecked) == 0x000000, "Member 'MM_GameOption_UI_OnClickUserNameOption3::bChecked' has a wrong offset!");

// Function MirMobile.MM_GatherObject.SetVisibilityBasedAnimTickOption
// 0x0001 (0x0001 - 0x0000)
struct MM_GatherObject_SetVisibilityBasedAnimTickOption final
{
public:
	EVisibilityBasedAnimTickOption                InTickOption;                                      // 0x0000(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(MM_GatherObject_SetVisibilityBasedAnimTickOption) == 0x000001, "Wrong alignment on MM_GatherObject_SetVisibilityBasedAnimTickOption");
static_assert(sizeof(MM_GatherObject_SetVisibilityBasedAnimTickOption) == 0x000001, "Wrong size on MM_GatherObject_SetVisibilityBasedAnimTickOption");
static_assert(offsetof(MM_GatherObject_SetVisibilityBasedAnimTickOption, InTickOption) == 0x000000, "Member 'MM_GatherObject_SetVisibilityBasedAnimTickOption::InTickOption' has a wrong offset!");

// Function MirMobile.MM_GhostTrailComponent.GetTrailActive
// 0x0001 (0x0001 - 0x0000)
struct MM_GhostTrailComponent_GetTrailActive final
{
public:
	bool                                          ReturnValue;                                       // 0x0000(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(MM_GhostTrailComponent_GetTrailActive) == 0x000001, "Wrong alignment on MM_GhostTrailComponent_GetTrailActive");
static_assert(sizeof(MM_GhostTrailComponent_GetTrailActive) == 0x000001, "Wrong size on MM_GhostTrailComponent_GetTrailActive");
static_assert(offsetof(MM_GhostTrailComponent_GetTrailActive, ReturnValue) == 0x000000, "Member 'MM_GhostTrailComponent_GetTrailActive::ReturnValue' has a wrong offset!");

// Function MirMobile.MM_GhostTrailComponent.SetGhostData
// 0x0010 (0x0010 - 0x0000)
struct MM_GhostTrailComponent_SetGhostData final
{
public:
	float                                         NewDelayTime;                                      // 0x0000(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         NewLifeTime;                                       // 0x0004(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UMaterialInstance*                      NewMaterialInstance;                               // 0x0008(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(MM_GhostTrailComponent_SetGhostData) == 0x000008, "Wrong alignment on MM_GhostTrailComponent_SetGhostData");
static_assert(sizeof(MM_GhostTrailComponent_SetGhostData) == 0x000010, "Wrong size on MM_GhostTrailComponent_SetGhostData");
static_assert(offsetof(MM_GhostTrailComponent_SetGhostData, NewDelayTime) == 0x000000, "Member 'MM_GhostTrailComponent_SetGhostData::NewDelayTime' has a wrong offset!");
static_assert(offsetof(MM_GhostTrailComponent_SetGhostData, NewLifeTime) == 0x000004, "Member 'MM_GhostTrailComponent_SetGhostData::NewLifeTime' has a wrong offset!");
static_assert(offsetof(MM_GhostTrailComponent_SetGhostData, NewMaterialInstance) == 0x000008, "Member 'MM_GhostTrailComponent_SetGhostData::NewMaterialInstance' has a wrong offset!");

// Function MirMobile.MM_GhostTrailComponent.SetTrailActive
// 0x0001 (0x0001 - 0x0000)
struct MM_GhostTrailComponent_SetTrailActive final
{
public:
	bool                                          IsActive_0;                                        // 0x0000(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(MM_GhostTrailComponent_SetTrailActive) == 0x000001, "Wrong alignment on MM_GhostTrailComponent_SetTrailActive");
static_assert(sizeof(MM_GhostTrailComponent_SetTrailActive) == 0x000001, "Wrong size on MM_GhostTrailComponent_SetTrailActive");
static_assert(offsetof(MM_GhostTrailComponent_SetTrailActive, IsActive_0) == 0x000000, "Member 'MM_GhostTrailComponent_SetTrailActive::IsActive_0' has a wrong offset!");

// Function MirMobile.MM_Guild_Dev.OnClickedVerticalTabBtn
// 0x0008 (0x0008 - 0x0000)
struct MM_Guild_Dev_OnClickedVerticalTabBtn final
{
public:
	int32                                         VerticalIndex;                                     // 0x0000(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bLocked;                                           // 0x0004(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_5[0x3];                                        // 0x0005(0x0003)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(MM_Guild_Dev_OnClickedVerticalTabBtn) == 0x000004, "Wrong alignment on MM_Guild_Dev_OnClickedVerticalTabBtn");
static_assert(sizeof(MM_Guild_Dev_OnClickedVerticalTabBtn) == 0x000008, "Wrong size on MM_Guild_Dev_OnClickedVerticalTabBtn");
static_assert(offsetof(MM_Guild_Dev_OnClickedVerticalTabBtn, VerticalIndex) == 0x000000, "Member 'MM_Guild_Dev_OnClickedVerticalTabBtn::VerticalIndex' has a wrong offset!");
static_assert(offsetof(MM_Guild_Dev_OnClickedVerticalTabBtn, bLocked) == 0x000004, "Member 'MM_Guild_Dev_OnClickedVerticalTabBtn::bLocked' has a wrong offset!");

// Function MirMobile.MM_TriggerManager.InitTriggerManager
// 0x0004 (0x0004 - 0x0000)
struct MM_TriggerManager_InitTriggerManager final
{
public:
	int32                                         TriggerGroupID;                                    // 0x0000(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(MM_TriggerManager_InitTriggerManager) == 0x000004, "Wrong alignment on MM_TriggerManager_InitTriggerManager");
static_assert(sizeof(MM_TriggerManager_InitTriggerManager) == 0x000004, "Wrong size on MM_TriggerManager_InitTriggerManager");
static_assert(offsetof(MM_TriggerManager_InitTriggerManager, TriggerGroupID) == 0x000000, "Member 'MM_TriggerManager_InitTriggerManager::TriggerGroupID' has a wrong offset!");

// Function MirMobile.MM_Guild_MainHome.OnChangePR
// 0x0018 (0x0018 - 0x0000)
struct MM_Guild_MainHome_OnChangePR final
{
public:
	class FText                                   Text;                                              // 0x0000(0x0018)(ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
};
static_assert(alignof(MM_Guild_MainHome_OnChangePR) == 0x000008, "Wrong alignment on MM_Guild_MainHome_OnChangePR");
static_assert(sizeof(MM_Guild_MainHome_OnChangePR) == 0x000018, "Wrong size on MM_Guild_MainHome_OnChangePR");
static_assert(offsetof(MM_Guild_MainHome_OnChangePR, Text) == 0x000000, "Member 'MM_Guild_MainHome_OnChangePR::Text' has a wrong offset!");

// Function MirMobile.MM_GuildOption.OnClickCheckBoxAlliance
// 0x0001 (0x0001 - 0x0000)
struct MM_GuildOption_OnClickCheckBoxAlliance final
{
public:
	bool                                          Toggled_;                                          // 0x0000(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(MM_GuildOption_OnClickCheckBoxAlliance) == 0x000001, "Wrong alignment on MM_GuildOption_OnClickCheckBoxAlliance");
static_assert(sizeof(MM_GuildOption_OnClickCheckBoxAlliance) == 0x000001, "Wrong size on MM_GuildOption_OnClickCheckBoxAlliance");
static_assert(offsetof(MM_GuildOption_OnClickCheckBoxAlliance, Toggled_) == 0x000000, "Member 'MM_GuildOption_OnClickCheckBoxAlliance::Toggled_' has a wrong offset!");

// Function MirMobile.MM_GuildOption.OnClickCheckBoxJoin
// 0x0001 (0x0001 - 0x0000)
struct MM_GuildOption_OnClickCheckBoxJoin final
{
public:
	bool                                          Toggled_;                                          // 0x0000(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(MM_GuildOption_OnClickCheckBoxJoin) == 0x000001, "Wrong alignment on MM_GuildOption_OnClickCheckBoxJoin");
static_assert(sizeof(MM_GuildOption_OnClickCheckBoxJoin) == 0x000001, "Wrong size on MM_GuildOption_OnClickCheckBoxJoin");
static_assert(offsetof(MM_GuildOption_OnClickCheckBoxJoin, Toggled_) == 0x000000, "Member 'MM_GuildOption_OnClickCheckBoxJoin::Toggled_' has a wrong offset!");

// Function MirMobile.MM_GuildOption.OnClickHistoryGroup
// 0x0001 (0x0001 - 0x0000)
struct MM_GuildOption_OnClickHistoryGroup final
{
public:
	bool                                          Checked_;                                          // 0x0000(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(MM_GuildOption_OnClickHistoryGroup) == 0x000001, "Wrong alignment on MM_GuildOption_OnClickHistoryGroup");
static_assert(sizeof(MM_GuildOption_OnClickHistoryGroup) == 0x000001, "Wrong size on MM_GuildOption_OnClickHistoryGroup");
static_assert(offsetof(MM_GuildOption_OnClickHistoryGroup, Checked_) == 0x000000, "Member 'MM_GuildOption_OnClickHistoryGroup::Checked_' has a wrong offset!");

// Function MirMobile.MM_GuildOption.OnClickTab
// 0x0008 (0x0008 - 0x0000)
struct MM_GuildOption_OnClickTab final
{
public:
	int32                                         Index_;                                            // 0x0000(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bLocked;                                           // 0x0004(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_5[0x3];                                        // 0x0005(0x0003)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(MM_GuildOption_OnClickTab) == 0x000004, "Wrong alignment on MM_GuildOption_OnClickTab");
static_assert(sizeof(MM_GuildOption_OnClickTab) == 0x000008, "Wrong size on MM_GuildOption_OnClickTab");
static_assert(offsetof(MM_GuildOption_OnClickTab, Index_) == 0x000000, "Member 'MM_GuildOption_OnClickTab::Index_' has a wrong offset!");
static_assert(offsetof(MM_GuildOption_OnClickTab, bLocked) == 0x000004, "Member 'MM_GuildOption_OnClickTab::bLocked' has a wrong offset!");

// Function MirMobile.MM_GuildOption.OnClickToggleBtnFree
// 0x0001 (0x0001 - 0x0000)
struct MM_GuildOption_OnClickToggleBtnFree final
{
public:
	bool                                          Toggled_;                                          // 0x0000(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(MM_GuildOption_OnClickToggleBtnFree) == 0x000001, "Wrong alignment on MM_GuildOption_OnClickToggleBtnFree");
static_assert(sizeof(MM_GuildOption_OnClickToggleBtnFree) == 0x000001, "Wrong size on MM_GuildOption_OnClickToggleBtnFree");
static_assert(offsetof(MM_GuildOption_OnClickToggleBtnFree, Toggled_) == 0x000000, "Member 'MM_GuildOption_OnClickToggleBtnFree::Toggled_' has a wrong offset!");

// Function MirMobile.MM_GuildOption.OnClickToggleBtnPermission
// 0x0001 (0x0001 - 0x0000)
struct MM_GuildOption_OnClickToggleBtnPermission final
{
public:
	bool                                          Toggled_;                                          // 0x0000(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(MM_GuildOption_OnClickToggleBtnPermission) == 0x000001, "Wrong alignment on MM_GuildOption_OnClickToggleBtnPermission");
static_assert(sizeof(MM_GuildOption_OnClickToggleBtnPermission) == 0x000001, "Wrong size on MM_GuildOption_OnClickToggleBtnPermission");
static_assert(offsetof(MM_GuildOption_OnClickToggleBtnPermission, Toggled_) == 0x000000, "Member 'MM_GuildOption_OnClickToggleBtnPermission::Toggled_' has a wrong offset!");

// Function MirMobile.MM_GuildOption.SetValueByKeyPad
// 0x0008 (0x0008 - 0x0000)
struct MM_GuildOption_SetValueByKeyPad final
{
public:
	int64                                         Value_;                                            // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(MM_GuildOption_SetValueByKeyPad) == 0x000008, "Wrong alignment on MM_GuildOption_SetValueByKeyPad");
static_assert(sizeof(MM_GuildOption_SetValueByKeyPad) == 0x000008, "Wrong size on MM_GuildOption_SetValueByKeyPad");
static_assert(offsetof(MM_GuildOption_SetValueByKeyPad, Value_) == 0x000000, "Member 'MM_GuildOption_SetValueByKeyPad::Value_' has a wrong offset!");

// Function MirMobile.MM_GuildPeruseWorld.OnChangedWorld
// 0x0010 (0x0010 - 0x0000)
struct MM_GuildPeruseWorld_OnChangedWorld final
{
public:
	class FString                                 World_name_;                                       // 0x0000(0x0010)(Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(MM_GuildPeruseWorld_OnChangedWorld) == 0x000008, "Wrong alignment on MM_GuildPeruseWorld_OnChangedWorld");
static_assert(sizeof(MM_GuildPeruseWorld_OnChangedWorld) == 0x000010, "Wrong size on MM_GuildPeruseWorld_OnChangedWorld");
static_assert(offsetof(MM_GuildPeruseWorld_OnChangedWorld, World_name_) == 0x000000, "Member 'MM_GuildPeruseWorld_OnChangedWorld::World_name_' has a wrong offset!");

// Function MirMobile.MM_GuildSupport.OnClickTab
// 0x0008 (0x0008 - 0x0000)
struct MM_GuildSupport_OnClickTab final
{
public:
	int32                                         Index_;                                            // 0x0000(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bLocked;                                           // 0x0004(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_5[0x3];                                        // 0x0005(0x0003)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(MM_GuildSupport_OnClickTab) == 0x000004, "Wrong alignment on MM_GuildSupport_OnClickTab");
static_assert(sizeof(MM_GuildSupport_OnClickTab) == 0x000008, "Wrong size on MM_GuildSupport_OnClickTab");
static_assert(offsetof(MM_GuildSupport_OnClickTab, Index_) == 0x000000, "Member 'MM_GuildSupport_OnClickTab::Index_' has a wrong offset!");
static_assert(offsetof(MM_GuildSupport_OnClickTab, bLocked) == 0x000004, "Member 'MM_GuildSupport_OnClickTab::bLocked' has a wrong offset!");

// Function MirMobile.MM_TestCustomizingCameraGameMode.AddCameraValue
// 0x0030 (0x0030 - 0x0000)
struct MM_TestCustomizingCameraGameMode_AddCameraValue final
{
public:
	class FString                                 CameraName;                                        // 0x0000(0x0010)(ConstParm, Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                CamLoc;                                            // 0x0010(0x000C)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FRotator                               CamRot;                                            // 0x001C(0x000C)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	float                                         CamFOV;                                            // 0x0028(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         CharacterYaw;                                      // 0x002C(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(MM_TestCustomizingCameraGameMode_AddCameraValue) == 0x000008, "Wrong alignment on MM_TestCustomizingCameraGameMode_AddCameraValue");
static_assert(sizeof(MM_TestCustomizingCameraGameMode_AddCameraValue) == 0x000030, "Wrong size on MM_TestCustomizingCameraGameMode_AddCameraValue");
static_assert(offsetof(MM_TestCustomizingCameraGameMode_AddCameraValue, CameraName) == 0x000000, "Member 'MM_TestCustomizingCameraGameMode_AddCameraValue::CameraName' has a wrong offset!");
static_assert(offsetof(MM_TestCustomizingCameraGameMode_AddCameraValue, CamLoc) == 0x000010, "Member 'MM_TestCustomizingCameraGameMode_AddCameraValue::CamLoc' has a wrong offset!");
static_assert(offsetof(MM_TestCustomizingCameraGameMode_AddCameraValue, CamRot) == 0x00001C, "Member 'MM_TestCustomizingCameraGameMode_AddCameraValue::CamRot' has a wrong offset!");
static_assert(offsetof(MM_TestCustomizingCameraGameMode_AddCameraValue, CamFOV) == 0x000028, "Member 'MM_TestCustomizingCameraGameMode_AddCameraValue::CamFOV' has a wrong offset!");
static_assert(offsetof(MM_TestCustomizingCameraGameMode_AddCameraValue, CharacterYaw) == 0x00002C, "Member 'MM_TestCustomizingCameraGameMode_AddCameraValue::CharacterYaw' has a wrong offset!");

// Function MirMobile.MM_TestCustomizingCameraGameMode.DeleteCamera
// 0x0010 (0x0010 - 0x0000)
struct MM_TestCustomizingCameraGameMode_DeleteCamera final
{
public:
	class FString                                 CameraName;                                        // 0x0000(0x0010)(ConstParm, Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(MM_TestCustomizingCameraGameMode_DeleteCamera) == 0x000008, "Wrong alignment on MM_TestCustomizingCameraGameMode_DeleteCamera");
static_assert(sizeof(MM_TestCustomizingCameraGameMode_DeleteCamera) == 0x000010, "Wrong size on MM_TestCustomizingCameraGameMode_DeleteCamera");
static_assert(offsetof(MM_TestCustomizingCameraGameMode_DeleteCamera, CameraName) == 0x000000, "Member 'MM_TestCustomizingCameraGameMode_DeleteCamera::CameraName' has a wrong offset!");

// Function MirMobile.MM_TestCustomizingCameraGameMode.GetCameraValue
// 0x0038 (0x0038 - 0x0000)
struct MM_TestCustomizingCameraGameMode_GetCameraValue final
{
public:
	class FString                                 CameraName;                                        // 0x0000(0x0010)(ConstParm, Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bSucess;                                           // 0x0010(0x0001)(Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_11[0x3];                                       // 0x0011(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	struct FVector                                CamLoc;                                            // 0x0014(0x000C)(Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FRotator                               CamRot;                                            // 0x0020(0x000C)(Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	float                                         CamFOV;                                            // 0x002C(0x0004)(Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         CharacterYaw;                                      // 0x0030(0x0004)(Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_34[0x4];                                       // 0x0034(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(MM_TestCustomizingCameraGameMode_GetCameraValue) == 0x000008, "Wrong alignment on MM_TestCustomizingCameraGameMode_GetCameraValue");
static_assert(sizeof(MM_TestCustomizingCameraGameMode_GetCameraValue) == 0x000038, "Wrong size on MM_TestCustomizingCameraGameMode_GetCameraValue");
static_assert(offsetof(MM_TestCustomizingCameraGameMode_GetCameraValue, CameraName) == 0x000000, "Member 'MM_TestCustomizingCameraGameMode_GetCameraValue::CameraName' has a wrong offset!");
static_assert(offsetof(MM_TestCustomizingCameraGameMode_GetCameraValue, bSucess) == 0x000010, "Member 'MM_TestCustomizingCameraGameMode_GetCameraValue::bSucess' has a wrong offset!");
static_assert(offsetof(MM_TestCustomizingCameraGameMode_GetCameraValue, CamLoc) == 0x000014, "Member 'MM_TestCustomizingCameraGameMode_GetCameraValue::CamLoc' has a wrong offset!");
static_assert(offsetof(MM_TestCustomizingCameraGameMode_GetCameraValue, CamRot) == 0x000020, "Member 'MM_TestCustomizingCameraGameMode_GetCameraValue::CamRot' has a wrong offset!");
static_assert(offsetof(MM_TestCustomizingCameraGameMode_GetCameraValue, CamFOV) == 0x00002C, "Member 'MM_TestCustomizingCameraGameMode_GetCameraValue::CamFOV' has a wrong offset!");
static_assert(offsetof(MM_TestCustomizingCameraGameMode_GetCameraValue, CharacterYaw) == 0x000030, "Member 'MM_TestCustomizingCameraGameMode_GetCameraValue::CharacterYaw' has a wrong offset!");

// Function MirMobile.MM_TestCustomizingCameraGameMode.LinkCamera
// 0x0010 (0x0010 - 0x0000)
struct MM_TestCustomizingCameraGameMode_LinkCamera final
{
public:
	class FString                                 CameraName;                                        // 0x0000(0x0010)(ConstParm, Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(MM_TestCustomizingCameraGameMode_LinkCamera) == 0x000008, "Wrong alignment on MM_TestCustomizingCameraGameMode_LinkCamera");
static_assert(sizeof(MM_TestCustomizingCameraGameMode_LinkCamera) == 0x000010, "Wrong size on MM_TestCustomizingCameraGameMode_LinkCamera");
static_assert(offsetof(MM_TestCustomizingCameraGameMode_LinkCamera, CameraName) == 0x000000, "Member 'MM_TestCustomizingCameraGameMode_LinkCamera::CameraName' has a wrong offset!");

// Function MirMobile.MM_TestCustomizingCameraGameMode.RefreshCameraNameComboBox
// 0x0010 (0x0010 - 0x0000)
struct MM_TestCustomizingCameraGameMode_RefreshCameraNameComboBox final
{
public:
	TArray<class FString>                         CameraNameArray;                                   // 0x0000(0x0010)(ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, NativeAccessSpecifierPublic)
};
static_assert(alignof(MM_TestCustomizingCameraGameMode_RefreshCameraNameComboBox) == 0x000008, "Wrong alignment on MM_TestCustomizingCameraGameMode_RefreshCameraNameComboBox");
static_assert(sizeof(MM_TestCustomizingCameraGameMode_RefreshCameraNameComboBox) == 0x000010, "Wrong size on MM_TestCustomizingCameraGameMode_RefreshCameraNameComboBox");
static_assert(offsetof(MM_TestCustomizingCameraGameMode_RefreshCameraNameComboBox, CameraNameArray) == 0x000000, "Member 'MM_TestCustomizingCameraGameMode_RefreshCameraNameComboBox::CameraNameArray' has a wrong offset!");

// Function MirMobile.MM_TestCustomizingCameraGameMode.SetZoomValue
// 0x0004 (0x0004 - 0x0000)
struct MM_TestCustomizingCameraGameMode_SetZoomValue final
{
public:
	float                                         ZoomValue;                                         // 0x0000(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(MM_TestCustomizingCameraGameMode_SetZoomValue) == 0x000004, "Wrong alignment on MM_TestCustomizingCameraGameMode_SetZoomValue");
static_assert(sizeof(MM_TestCustomizingCameraGameMode_SetZoomValue) == 0x000004, "Wrong size on MM_TestCustomizingCameraGameMode_SetZoomValue");
static_assert(offsetof(MM_TestCustomizingCameraGameMode_SetZoomValue, ZoomValue) == 0x000000, "Member 'MM_TestCustomizingCameraGameMode_SetZoomValue::ZoomValue' has a wrong offset!");

// Function MirMobile.MM_PopupEdit.OnTextCommitted
// 0x0020 (0x0020 - 0x0000)
struct MM_PopupEdit_OnTextCommitted final
{
public:
	class FText                                   Text_;                                             // 0x0000(0x0018)(ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
	ETextCommit                                   Commit_method_;                                    // 0x0018(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_19[0x7];                                       // 0x0019(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(MM_PopupEdit_OnTextCommitted) == 0x000008, "Wrong alignment on MM_PopupEdit_OnTextCommitted");
static_assert(sizeof(MM_PopupEdit_OnTextCommitted) == 0x000020, "Wrong size on MM_PopupEdit_OnTextCommitted");
static_assert(offsetof(MM_PopupEdit_OnTextCommitted, Text_) == 0x000000, "Member 'MM_PopupEdit_OnTextCommitted::Text_' has a wrong offset!");
static_assert(offsetof(MM_PopupEdit_OnTextCommitted, Commit_method_) == 0x000018, "Member 'MM_PopupEdit_OnTextCommitted::Commit_method_' has a wrong offset!");

// Function MirMobile.MM_GuildTournament_SkillDeckList.OnClickUseSkill
// 0x0004 (0x0004 - 0x0000)
struct MM_GuildTournament_SkillDeckList_OnClickUseSkill final
{
public:
	int32                                         SkillTID;                                          // 0x0000(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(MM_GuildTournament_SkillDeckList_OnClickUseSkill) == 0x000004, "Wrong alignment on MM_GuildTournament_SkillDeckList_OnClickUseSkill");
static_assert(sizeof(MM_GuildTournament_SkillDeckList_OnClickUseSkill) == 0x000004, "Wrong size on MM_GuildTournament_SkillDeckList_OnClickUseSkill");
static_assert(offsetof(MM_GuildTournament_SkillDeckList_OnClickUseSkill, SkillTID) == 0x000000, "Member 'MM_GuildTournament_SkillDeckList_OnClickUseSkill::SkillTID' has a wrong offset!");

// Function MirMobile.MM_PopupGetItemWidget.OnClickCategorySlot
// 0x0018 (0x0018 - 0x0000)
struct MM_PopupGetItemWidget_OnClickCategorySlot final
{
public:
	int32                                         Type;                                              // 0x0000(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         SubType;                                           // 0x0004(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 StrCategory;                                       // 0x0008(0x0010)(Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(MM_PopupGetItemWidget_OnClickCategorySlot) == 0x000008, "Wrong alignment on MM_PopupGetItemWidget_OnClickCategorySlot");
static_assert(sizeof(MM_PopupGetItemWidget_OnClickCategorySlot) == 0x000018, "Wrong size on MM_PopupGetItemWidget_OnClickCategorySlot");
static_assert(offsetof(MM_PopupGetItemWidget_OnClickCategorySlot, Type) == 0x000000, "Member 'MM_PopupGetItemWidget_OnClickCategorySlot::Type' has a wrong offset!");
static_assert(offsetof(MM_PopupGetItemWidget_OnClickCategorySlot, SubType) == 0x000004, "Member 'MM_PopupGetItemWidget_OnClickCategorySlot::SubType' has a wrong offset!");
static_assert(offsetof(MM_PopupGetItemWidget_OnClickCategorySlot, StrCategory) == 0x000008, "Member 'MM_PopupGetItemWidget_OnClickCategorySlot::StrCategory' has a wrong offset!");

// Function MirMobile.MM_PopupGetItemWidget.OnClickCategorySlot_Cost
// 0x0018 (0x0018 - 0x0000)
struct MM_PopupGetItemWidget_OnClickCategorySlot_Cost final
{
public:
	int32                                         Type;                                              // 0x0000(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         SubType;                                           // 0x0004(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 StrCategory;                                       // 0x0008(0x0010)(Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(MM_PopupGetItemWidget_OnClickCategorySlot_Cost) == 0x000008, "Wrong alignment on MM_PopupGetItemWidget_OnClickCategorySlot_Cost");
static_assert(sizeof(MM_PopupGetItemWidget_OnClickCategorySlot_Cost) == 0x000018, "Wrong size on MM_PopupGetItemWidget_OnClickCategorySlot_Cost");
static_assert(offsetof(MM_PopupGetItemWidget_OnClickCategorySlot_Cost, Type) == 0x000000, "Member 'MM_PopupGetItemWidget_OnClickCategorySlot_Cost::Type' has a wrong offset!");
static_assert(offsetof(MM_PopupGetItemWidget_OnClickCategorySlot_Cost, SubType) == 0x000004, "Member 'MM_PopupGetItemWidget_OnClickCategorySlot_Cost::SubType' has a wrong offset!");
static_assert(offsetof(MM_PopupGetItemWidget_OnClickCategorySlot_Cost, StrCategory) == 0x000008, "Member 'MM_PopupGetItemWidget_OnClickCategorySlot_Cost::StrCategory' has a wrong offset!");

// Function MirMobile.MM_PopupGetItemWidget.OnClickTypeSlot_Cost
// 0x0004 (0x0004 - 0x0000)
struct MM_PopupGetItemWidget_OnClickTypeSlot_Cost final
{
public:
	int32                                         CostType;                                          // 0x0000(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(MM_PopupGetItemWidget_OnClickTypeSlot_Cost) == 0x000004, "Wrong alignment on MM_PopupGetItemWidget_OnClickTypeSlot_Cost");
static_assert(sizeof(MM_PopupGetItemWidget_OnClickTypeSlot_Cost) == 0x000004, "Wrong size on MM_PopupGetItemWidget_OnClickTypeSlot_Cost");
static_assert(offsetof(MM_PopupGetItemWidget_OnClickTypeSlot_Cost, CostType) == 0x000000, "Member 'MM_PopupGetItemWidget_OnClickTypeSlot_Cost::CostType' has a wrong offset!");

// Function MirMobile.MM_PopupGetItemWidget.OnClickTypeSlot_Item
// 0x0004 (0x0004 - 0x0000)
struct MM_PopupGetItemWidget_OnClickTypeSlot_Item final
{
public:
	int32                                         Type;                                              // 0x0000(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(MM_PopupGetItemWidget_OnClickTypeSlot_Item) == 0x000004, "Wrong alignment on MM_PopupGetItemWidget_OnClickTypeSlot_Item");
static_assert(sizeof(MM_PopupGetItemWidget_OnClickTypeSlot_Item) == 0x000004, "Wrong size on MM_PopupGetItemWidget_OnClickTypeSlot_Item");
static_assert(offsetof(MM_PopupGetItemWidget_OnClickTypeSlot_Item, Type) == 0x000000, "Member 'MM_PopupGetItemWidget_OnClickTypeSlot_Item::Type' has a wrong offset!");

// Function MirMobile.MM_PopupGuildGive.OnChangeCount
// 0x0008 (0x0008 - 0x0000)
struct MM_PopupGuildGive_OnChangeCount final
{
public:
	int64                                         Count_;                                            // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(MM_PopupGuildGive_OnChangeCount) == 0x000008, "Wrong alignment on MM_PopupGuildGive_OnChangeCount");
static_assert(sizeof(MM_PopupGuildGive_OnChangeCount) == 0x000008, "Wrong size on MM_PopupGuildGive_OnChangeCount");
static_assert(offsetof(MM_PopupGuildGive_OnChangeCount, Count_) == 0x000000, "Member 'MM_PopupGuildGive_OnChangeCount::Count_' has a wrong offset!");

// Function MirMobile.MM_PopupGuildGiveOtherSlot.OnClickCheckBox
// 0x0001 (0x0001 - 0x0000)
struct MM_PopupGuildGiveOtherSlot_OnClickCheckBox final
{
public:
	bool                                          Check_;                                            // 0x0000(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(MM_PopupGuildGiveOtherSlot_OnClickCheckBox) == 0x000001, "Wrong alignment on MM_PopupGuildGiveOtherSlot_OnClickCheckBox");
static_assert(sizeof(MM_PopupGuildGiveOtherSlot_OnClickCheckBox) == 0x000001, "Wrong size on MM_PopupGuildGiveOtherSlot_OnClickCheckBox");
static_assert(offsetof(MM_PopupGuildGiveOtherSlot_OnClickCheckBox, Check_) == 0x000000, "Member 'MM_PopupGuildGiveOtherSlot_OnClickCheckBox::Check_' has a wrong offset!");

// Function MirMobile.MM_SoundManagerActor.FinishedDialogueSound
// 0x0008 (0x0008 - 0x0000)
struct MM_SoundManagerActor_FinishedDialogueSound final
{
public:
	class UAudioComponent*                        PFinishedComponent;                                // 0x0000(0x0008)(Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(MM_SoundManagerActor_FinishedDialogueSound) == 0x000008, "Wrong alignment on MM_SoundManagerActor_FinishedDialogueSound");
static_assert(sizeof(MM_SoundManagerActor_FinishedDialogueSound) == 0x000008, "Wrong size on MM_SoundManagerActor_FinishedDialogueSound");
static_assert(offsetof(MM_SoundManagerActor_FinishedDialogueSound, PFinishedComponent) == 0x000000, "Member 'MM_SoundManagerActor_FinishedDialogueSound::PFinishedComponent' has a wrong offset!");

// Function MirMobile.MM_SoundManagerActor.FinishedPlaySound
// 0x0008 (0x0008 - 0x0000)
struct MM_SoundManagerActor_FinishedPlaySound final
{
public:
	class UAudioComponent*                        PFinishedComponent;                                // 0x0000(0x0008)(Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(MM_SoundManagerActor_FinishedPlaySound) == 0x000008, "Wrong alignment on MM_SoundManagerActor_FinishedPlaySound");
static_assert(sizeof(MM_SoundManagerActor_FinishedPlaySound) == 0x000008, "Wrong size on MM_SoundManagerActor_FinishedPlaySound");
static_assert(offsetof(MM_SoundManagerActor_FinishedPlaySound, PFinishedComponent) == 0x000000, "Member 'MM_SoundManagerActor_FinishedPlaySound::PFinishedComponent' has a wrong offset!");

// Function MirMobile.MM_SoundManagerActor.SetMediaSoundVolume
// 0x0010 (0x0010 - 0x0000)
struct MM_SoundManagerActor_SetMediaSoundVolume final
{
public:
	class UMediaSoundComponent*                   PMediaSoundComponent;                              // 0x0000(0x0008)(Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         FVolume;                                           // 0x0008(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_C[0x4];                                        // 0x000C(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(MM_SoundManagerActor_SetMediaSoundVolume) == 0x000008, "Wrong alignment on MM_SoundManagerActor_SetMediaSoundVolume");
static_assert(sizeof(MM_SoundManagerActor_SetMediaSoundVolume) == 0x000010, "Wrong size on MM_SoundManagerActor_SetMediaSoundVolume");
static_assert(offsetof(MM_SoundManagerActor_SetMediaSoundVolume, PMediaSoundComponent) == 0x000000, "Member 'MM_SoundManagerActor_SetMediaSoundVolume::PMediaSoundComponent' has a wrong offset!");
static_assert(offsetof(MM_SoundManagerActor_SetMediaSoundVolume, FVolume) == 0x000008, "Member 'MM_SoundManagerActor_SetMediaSoundVolume::FVolume' has a wrong offset!");

// Function MirMobile.MM_Hud_Chat_ChattingRoom.OnClickCheckBoxBookmark
// 0x0001 (0x0001 - 0x0000)
struct MM_Hud_Chat_ChattingRoom_OnClickCheckBoxBookmark final
{
public:
	bool                                          Checked;                                           // 0x0000(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(MM_Hud_Chat_ChattingRoom_OnClickCheckBoxBookmark) == 0x000001, "Wrong alignment on MM_Hud_Chat_ChattingRoom_OnClickCheckBoxBookmark");
static_assert(sizeof(MM_Hud_Chat_ChattingRoom_OnClickCheckBoxBookmark) == 0x000001, "Wrong size on MM_Hud_Chat_ChattingRoom_OnClickCheckBoxBookmark");
static_assert(offsetof(MM_Hud_Chat_ChattingRoom_OnClickCheckBoxBookmark, Checked) == 0x000000, "Member 'MM_Hud_Chat_ChattingRoom_OnClickCheckBoxBookmark::Checked' has a wrong offset!");

// Function MirMobile.SceneCaptureTool.AddCameraFOVInput
// 0x0004 (0x0004 - 0x0000)
struct SceneCaptureTool_AddCameraFOVInput final
{
public:
	float                                         Value;                                             // 0x0000(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(SceneCaptureTool_AddCameraFOVInput) == 0x000004, "Wrong alignment on SceneCaptureTool_AddCameraFOVInput");
static_assert(sizeof(SceneCaptureTool_AddCameraFOVInput) == 0x000004, "Wrong size on SceneCaptureTool_AddCameraFOVInput");
static_assert(offsetof(SceneCaptureTool_AddCameraFOVInput, Value) == 0x000000, "Member 'SceneCaptureTool_AddCameraFOVInput::Value' has a wrong offset!");

// Function MirMobile.SceneCaptureTool.AddCameraPitchInput
// 0x0004 (0x0004 - 0x0000)
struct SceneCaptureTool_AddCameraPitchInput final
{
public:
	float                                         Value;                                             // 0x0000(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(SceneCaptureTool_AddCameraPitchInput) == 0x000004, "Wrong alignment on SceneCaptureTool_AddCameraPitchInput");
static_assert(sizeof(SceneCaptureTool_AddCameraPitchInput) == 0x000004, "Wrong size on SceneCaptureTool_AddCameraPitchInput");
static_assert(offsetof(SceneCaptureTool_AddCameraPitchInput, Value) == 0x000000, "Member 'SceneCaptureTool_AddCameraPitchInput::Value' has a wrong offset!");

// Function MirMobile.SceneCaptureTool.MoveForward
// 0x0004 (0x0004 - 0x0000)
struct SceneCaptureTool_MoveForward final
{
public:
	float                                         Value;                                             // 0x0000(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(SceneCaptureTool_MoveForward) == 0x000004, "Wrong alignment on SceneCaptureTool_MoveForward");
static_assert(sizeof(SceneCaptureTool_MoveForward) == 0x000004, "Wrong size on SceneCaptureTool_MoveForward");
static_assert(offsetof(SceneCaptureTool_MoveForward, Value) == 0x000000, "Member 'SceneCaptureTool_MoveForward::Value' has a wrong offset!");

// Function MirMobile.SceneCaptureTool.MoveRight
// 0x0004 (0x0004 - 0x0000)
struct SceneCaptureTool_MoveRight final
{
public:
	float                                         Value;                                             // 0x0000(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(SceneCaptureTool_MoveRight) == 0x000004, "Wrong alignment on SceneCaptureTool_MoveRight");
static_assert(sizeof(SceneCaptureTool_MoveRight) == 0x000004, "Wrong size on SceneCaptureTool_MoveRight");
static_assert(offsetof(SceneCaptureTool_MoveRight, Value) == 0x000000, "Member 'SceneCaptureTool_MoveRight::Value' has a wrong offset!");

// Function MirMobile.SceneCaptureTool.MoveUp
// 0x0004 (0x0004 - 0x0000)
struct SceneCaptureTool_MoveUp final
{
public:
	float                                         Value;                                             // 0x0000(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(SceneCaptureTool_MoveUp) == 0x000004, "Wrong alignment on SceneCaptureTool_MoveUp");
static_assert(sizeof(SceneCaptureTool_MoveUp) == 0x000004, "Wrong size on SceneCaptureTool_MoveUp");
static_assert(offsetof(SceneCaptureTool_MoveUp, Value) == 0x000000, "Member 'SceneCaptureTool_MoveUp::Value' has a wrong offset!");

// Function MirMobile.SceneCaptureTool.OnChangedComboxPC
// 0x0018 (0x0018 - 0x0000)
struct SceneCaptureTool_OnChangedComboxPC final
{
public:
	class FString                                 SelectedItem;                                      // 0x0000(0x0010)(Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	ESelectInfo                                   SelectionType;                                     // 0x0010(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_11[0x7];                                       // 0x0011(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(SceneCaptureTool_OnChangedComboxPC) == 0x000008, "Wrong alignment on SceneCaptureTool_OnChangedComboxPC");
static_assert(sizeof(SceneCaptureTool_OnChangedComboxPC) == 0x000018, "Wrong size on SceneCaptureTool_OnChangedComboxPC");
static_assert(offsetof(SceneCaptureTool_OnChangedComboxPC, SelectedItem) == 0x000000, "Member 'SceneCaptureTool_OnChangedComboxPC::SelectedItem' has a wrong offset!");
static_assert(offsetof(SceneCaptureTool_OnChangedComboxPC, SelectionType) == 0x000010, "Member 'SceneCaptureTool_OnChangedComboxPC::SelectionType' has a wrong offset!");

// Function MirMobile.SceneCaptureTool.OnChangedComboxUI
// 0x0018 (0x0018 - 0x0000)
struct SceneCaptureTool_OnChangedComboxUI final
{
public:
	class FString                                 SelectedItem;                                      // 0x0000(0x0010)(Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	ESelectInfo                                   SelectionType;                                     // 0x0010(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_11[0x7];                                       // 0x0011(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(SceneCaptureTool_OnChangedComboxUI) == 0x000008, "Wrong alignment on SceneCaptureTool_OnChangedComboxUI");
static_assert(sizeof(SceneCaptureTool_OnChangedComboxUI) == 0x000018, "Wrong size on SceneCaptureTool_OnChangedComboxUI");
static_assert(offsetof(SceneCaptureTool_OnChangedComboxUI, SelectedItem) == 0x000000, "Member 'SceneCaptureTool_OnChangedComboxUI::SelectedItem' has a wrong offset!");
static_assert(offsetof(SceneCaptureTool_OnChangedComboxUI, SelectionType) == 0x000010, "Member 'SceneCaptureTool_OnChangedComboxUI::SelectionType' has a wrong offset!");

// Function MirMobile.SceneCaptureTool.OnChangedDirLightRotation
// 0x000C (0x000C - 0x0000)
struct SceneCaptureTool_OnChangedDirLightRotation final
{
public:
	struct FRotator                               Rotator;                                           // 0x0000(0x000C)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(SceneCaptureTool_OnChangedDirLightRotation) == 0x000004, "Wrong alignment on SceneCaptureTool_OnChangedDirLightRotation");
static_assert(sizeof(SceneCaptureTool_OnChangedDirLightRotation) == 0x00000C, "Wrong size on SceneCaptureTool_OnChangedDirLightRotation");
static_assert(offsetof(SceneCaptureTool_OnChangedDirLightRotation, Rotator) == 0x000000, "Member 'SceneCaptureTool_OnChangedDirLightRotation::Rotator' has a wrong offset!");

// Function MirMobile.SceneCaptureTool.OnChangedSceneCameraRotation
// 0x000C (0x000C - 0x0000)
struct SceneCaptureTool_OnChangedSceneCameraRotation final
{
public:
	struct FRotator                               Rotator;                                           // 0x0000(0x000C)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(SceneCaptureTool_OnChangedSceneCameraRotation) == 0x000004, "Wrong alignment on SceneCaptureTool_OnChangedSceneCameraRotation");
static_assert(sizeof(SceneCaptureTool_OnChangedSceneCameraRotation) == 0x00000C, "Wrong size on SceneCaptureTool_OnChangedSceneCameraRotation");
static_assert(offsetof(SceneCaptureTool_OnChangedSceneCameraRotation, Rotator) == 0x000000, "Member 'SceneCaptureTool_OnChangedSceneCameraRotation::Rotator' has a wrong offset!");

// Function MirMobile.SceneCaptureTool.OnChangedWidgetOpacity
// 0x0004 (0x0004 - 0x0000)
struct SceneCaptureTool_OnChangedWidgetOpacity final
{
public:
	float                                         Value;                                             // 0x0000(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(SceneCaptureTool_OnChangedWidgetOpacity) == 0x000004, "Wrong alignment on SceneCaptureTool_OnChangedWidgetOpacity");
static_assert(sizeof(SceneCaptureTool_OnChangedWidgetOpacity) == 0x000004, "Wrong size on SceneCaptureTool_OnChangedWidgetOpacity");
static_assert(offsetof(SceneCaptureTool_OnChangedWidgetOpacity, Value) == 0x000000, "Member 'SceneCaptureTool_OnChangedWidgetOpacity::Value' has a wrong offset!");

// Function MirMobile.MM_Hud_Chat_MacroSlot.OnChangedMacroTextField
// 0x0018 (0x0018 - 0x0000)
struct MM_Hud_Chat_MacroSlot_OnChangedMacroTextField final
{
public:
	class FText                                   InText;                                            // 0x0000(0x0018)(ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
};
static_assert(alignof(MM_Hud_Chat_MacroSlot_OnChangedMacroTextField) == 0x000008, "Wrong alignment on MM_Hud_Chat_MacroSlot_OnChangedMacroTextField");
static_assert(sizeof(MM_Hud_Chat_MacroSlot_OnChangedMacroTextField) == 0x000018, "Wrong size on MM_Hud_Chat_MacroSlot_OnChangedMacroTextField");
static_assert(offsetof(MM_Hud_Chat_MacroSlot_OnChangedMacroTextField, InText) == 0x000000, "Member 'MM_Hud_Chat_MacroSlot_OnChangedMacroTextField::InText' has a wrong offset!");

// Function MirMobile.MM_Hud_Chat_MacroSlot.OnCommittedMacroTextField
// 0x0020 (0x0020 - 0x0000)
struct MM_Hud_Chat_MacroSlot_OnCommittedMacroTextField final
{
public:
	class FText                                   InText;                                            // 0x0000(0x0018)(ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
	ETextCommit                                   CommitType;                                        // 0x0018(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_19[0x7];                                       // 0x0019(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(MM_Hud_Chat_MacroSlot_OnCommittedMacroTextField) == 0x000008, "Wrong alignment on MM_Hud_Chat_MacroSlot_OnCommittedMacroTextField");
static_assert(sizeof(MM_Hud_Chat_MacroSlot_OnCommittedMacroTextField) == 0x000020, "Wrong size on MM_Hud_Chat_MacroSlot_OnCommittedMacroTextField");
static_assert(offsetof(MM_Hud_Chat_MacroSlot_OnCommittedMacroTextField, InText) == 0x000000, "Member 'MM_Hud_Chat_MacroSlot_OnCommittedMacroTextField::InText' has a wrong offset!");
static_assert(offsetof(MM_Hud_Chat_MacroSlot_OnCommittedMacroTextField, CommitType) == 0x000018, "Member 'MM_Hud_Chat_MacroSlot_OnCommittedMacroTextField::CommitType' has a wrong offset!");

// Function MirMobile.MM_Popup_UIShopShoppingBag.OnChangeMakeCount
// 0x0008 (0x0008 - 0x0000)
struct MM_Popup_UIShopShoppingBag_OnChangeMakeCount final
{
public:
	int64                                         MakeCount;                                         // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(MM_Popup_UIShopShoppingBag_OnChangeMakeCount) == 0x000008, "Wrong alignment on MM_Popup_UIShopShoppingBag_OnChangeMakeCount");
static_assert(sizeof(MM_Popup_UIShopShoppingBag_OnChangeMakeCount) == 0x000008, "Wrong size on MM_Popup_UIShopShoppingBag_OnChangeMakeCount");
static_assert(offsetof(MM_Popup_UIShopShoppingBag_OnChangeMakeCount, MakeCount) == 0x000000, "Member 'MM_Popup_UIShopShoppingBag_OnChangeMakeCount::MakeCount' has a wrong offset!");

// Function MirMobile.MM_Hud_Chat_SearchWhisper.OnTextCommitted
// 0x0020 (0x0020 - 0x0000)
struct MM_Hud_Chat_SearchWhisper_OnTextCommitted final
{
public:
	class FText                                   Text_;                                             // 0x0000(0x0018)(ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
	ETextCommit                                   Commit_method_;                                    // 0x0018(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_19[0x7];                                       // 0x0019(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(MM_Hud_Chat_SearchWhisper_OnTextCommitted) == 0x000008, "Wrong alignment on MM_Hud_Chat_SearchWhisper_OnTextCommitted");
static_assert(sizeof(MM_Hud_Chat_SearchWhisper_OnTextCommitted) == 0x000020, "Wrong size on MM_Hud_Chat_SearchWhisper_OnTextCommitted");
static_assert(offsetof(MM_Hud_Chat_SearchWhisper_OnTextCommitted, Text_) == 0x000000, "Member 'MM_Hud_Chat_SearchWhisper_OnTextCommitted::Text_' has a wrong offset!");
static_assert(offsetof(MM_Hud_Chat_SearchWhisper_OnTextCommitted, Commit_method_) == 0x000018, "Member 'MM_Hud_Chat_SearchWhisper_OnTextCommitted::Commit_method_' has a wrong offset!");

// Function MirMobile.MM_Hud_Chat_SearchWhisper.OnToggleGuildTab
// 0x0001 (0x0001 - 0x0000)
struct MM_Hud_Chat_SearchWhisper_OnToggleGuildTab final
{
public:
	bool                                          CheckState;                                        // 0x0000(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(MM_Hud_Chat_SearchWhisper_OnToggleGuildTab) == 0x000001, "Wrong alignment on MM_Hud_Chat_SearchWhisper_OnToggleGuildTab");
static_assert(sizeof(MM_Hud_Chat_SearchWhisper_OnToggleGuildTab) == 0x000001, "Wrong size on MM_Hud_Chat_SearchWhisper_OnToggleGuildTab");
static_assert(offsetof(MM_Hud_Chat_SearchWhisper_OnToggleGuildTab, CheckState) == 0x000000, "Member 'MM_Hud_Chat_SearchWhisper_OnToggleGuildTab::CheckState' has a wrong offset!");

// Function MirMobile.MM_Hud_Chat_SearchWhisper.OnTogglePartyTab
// 0x0001 (0x0001 - 0x0000)
struct MM_Hud_Chat_SearchWhisper_OnTogglePartyTab final
{
public:
	bool                                          CheckState;                                        // 0x0000(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(MM_Hud_Chat_SearchWhisper_OnTogglePartyTab) == 0x000001, "Wrong alignment on MM_Hud_Chat_SearchWhisper_OnTogglePartyTab");
static_assert(sizeof(MM_Hud_Chat_SearchWhisper_OnTogglePartyTab) == 0x000001, "Wrong size on MM_Hud_Chat_SearchWhisper_OnTogglePartyTab");
static_assert(offsetof(MM_Hud_Chat_SearchWhisper_OnTogglePartyTab, CheckState) == 0x000000, "Member 'MM_Hud_Chat_SearchWhisper_OnTogglePartyTab::CheckState' has a wrong offset!");

// Function MirMobile.MM_Hud_Chat_SearchWhisper.OnToggleSearchTab
// 0x0001 (0x0001 - 0x0000)
struct MM_Hud_Chat_SearchWhisper_OnToggleSearchTab final
{
public:
	bool                                          CheckState;                                        // 0x0000(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(MM_Hud_Chat_SearchWhisper_OnToggleSearchTab) == 0x000001, "Wrong alignment on MM_Hud_Chat_SearchWhisper_OnToggleSearchTab");
static_assert(sizeof(MM_Hud_Chat_SearchWhisper_OnToggleSearchTab) == 0x000001, "Wrong size on MM_Hud_Chat_SearchWhisper_OnToggleSearchTab");
static_assert(offsetof(MM_Hud_Chat_SearchWhisper_OnToggleSearchTab, CheckState) == 0x000000, "Member 'MM_Hud_Chat_SearchWhisper_OnToggleSearchTab::CheckState' has a wrong offset!");

// Function MirMobile.UIBackGroundActor.AddSceneCaptureActor
// 0x0008 (0x0008 - 0x0000)
struct UIBackGroundActor_AddSceneCaptureActor final
{
public:
	class AActor*                                 AddActor;                                          // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(UIBackGroundActor_AddSceneCaptureActor) == 0x000008, "Wrong alignment on UIBackGroundActor_AddSceneCaptureActor");
static_assert(sizeof(UIBackGroundActor_AddSceneCaptureActor) == 0x000008, "Wrong size on UIBackGroundActor_AddSceneCaptureActor");
static_assert(offsetof(UIBackGroundActor_AddSceneCaptureActor, AddActor) == 0x000000, "Member 'UIBackGroundActor_AddSceneCaptureActor::AddActor' has a wrong offset!");

// Function MirMobile.UIBackGroundActor.CreateRenderTargetEvent
// 0x0008 (0x0008 - 0x0000)
struct UIBackGroundActor_CreateRenderTargetEvent final
{
public:
	class UCanvasRenderTarget2D*                  ReturnValue;                                       // 0x0000(0x0008)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(UIBackGroundActor_CreateRenderTargetEvent) == 0x000008, "Wrong alignment on UIBackGroundActor_CreateRenderTargetEvent");
static_assert(sizeof(UIBackGroundActor_CreateRenderTargetEvent) == 0x000008, "Wrong size on UIBackGroundActor_CreateRenderTargetEvent");
static_assert(offsetof(UIBackGroundActor_CreateRenderTargetEvent, ReturnValue) == 0x000000, "Member 'UIBackGroundActor_CreateRenderTargetEvent::ReturnValue' has a wrong offset!");

// Function MirMobile.UIBackGroundActor.GetSceneCapturePosition
// 0x0028 (0x0028 - 0x0000)
struct UIBackGroundActor_GetSceneCapturePosition final
{
public:
	class FString                                 PositionName;                                      // 0x0000(0x0010)(Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                OutLocation;                                       // 0x0010(0x000C)(Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FRotator                               OutRotator;                                        // 0x001C(0x000C)(Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(UIBackGroundActor_GetSceneCapturePosition) == 0x000008, "Wrong alignment on UIBackGroundActor_GetSceneCapturePosition");
static_assert(sizeof(UIBackGroundActor_GetSceneCapturePosition) == 0x000028, "Wrong size on UIBackGroundActor_GetSceneCapturePosition");
static_assert(offsetof(UIBackGroundActor_GetSceneCapturePosition, PositionName) == 0x000000, "Member 'UIBackGroundActor_GetSceneCapturePosition::PositionName' has a wrong offset!");
static_assert(offsetof(UIBackGroundActor_GetSceneCapturePosition, OutLocation) == 0x000010, "Member 'UIBackGroundActor_GetSceneCapturePosition::OutLocation' has a wrong offset!");
static_assert(offsetof(UIBackGroundActor_GetSceneCapturePosition, OutRotator) == 0x00001C, "Member 'UIBackGroundActor_GetSceneCapturePosition::OutRotator' has a wrong offset!");

// Function MirMobile.UIBackGroundActor.RemoveSceneCaptureActor
// 0x0008 (0x0008 - 0x0000)
struct UIBackGroundActor_RemoveSceneCaptureActor final
{
public:
	class AActor*                                 AddActor;                                          // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(UIBackGroundActor_RemoveSceneCaptureActor) == 0x000008, "Wrong alignment on UIBackGroundActor_RemoveSceneCaptureActor");
static_assert(sizeof(UIBackGroundActor_RemoveSceneCaptureActor) == 0x000008, "Wrong size on UIBackGroundActor_RemoveSceneCaptureActor");
static_assert(offsetof(UIBackGroundActor_RemoveSceneCaptureActor, AddActor) == 0x000000, "Member 'UIBackGroundActor_RemoveSceneCaptureActor::AddActor' has a wrong offset!");

// Function MirMobile.UIBackGroundActor.SetSceneCaptureTargetImage
// 0x0010 (0x0010 - 0x0000)
struct UIBackGroundActor_SetSceneCaptureTargetImage final
{
public:
	class UImage*                                 TargetImage;                                       // 0x0000(0x0008)(Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UImage*                                 TargetPos;                                         // 0x0008(0x0008)(Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(UIBackGroundActor_SetSceneCaptureTargetImage) == 0x000008, "Wrong alignment on UIBackGroundActor_SetSceneCaptureTargetImage");
static_assert(sizeof(UIBackGroundActor_SetSceneCaptureTargetImage) == 0x000010, "Wrong size on UIBackGroundActor_SetSceneCaptureTargetImage");
static_assert(offsetof(UIBackGroundActor_SetSceneCaptureTargetImage, TargetImage) == 0x000000, "Member 'UIBackGroundActor_SetSceneCaptureTargetImage::TargetImage' has a wrong offset!");
static_assert(offsetof(UIBackGroundActor_SetSceneCaptureTargetImage, TargetPos) == 0x000008, "Member 'UIBackGroundActor_SetSceneCaptureTargetImage::TargetPos' has a wrong offset!");

// Function MirMobile.UIBackGroundActor.SetTestFOV
// 0x0004 (0x0004 - 0x0000)
struct UIBackGroundActor_SetTestFOV final
{
public:
	float                                         TestFOV;                                           // 0x0000(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(UIBackGroundActor_SetTestFOV) == 0x000004, "Wrong alignment on UIBackGroundActor_SetTestFOV");
static_assert(sizeof(UIBackGroundActor_SetTestFOV) == 0x000004, "Wrong size on UIBackGroundActor_SetTestFOV");
static_assert(offsetof(UIBackGroundActor_SetTestFOV, TestFOV) == 0x000000, "Member 'UIBackGroundActor_SetTestFOV::TestFOV' has a wrong offset!");

// Function MirMobile.MM_SleepMode.OnDragStopSlider
// 0x0004 (0x0004 - 0x0000)
struct MM_SleepMode_OnDragStopSlider final
{
public:
	float                                         FRatio;                                            // 0x0000(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(MM_SleepMode_OnDragStopSlider) == 0x000004, "Wrong alignment on MM_SleepMode_OnDragStopSlider");
static_assert(sizeof(MM_SleepMode_OnDragStopSlider) == 0x000004, "Wrong size on MM_SleepMode_OnDragStopSlider");
static_assert(offsetof(MM_SleepMode_OnDragStopSlider, FRatio) == 0x000000, "Member 'MM_SleepMode_OnDragStopSlider::FRatio' has a wrong offset!");

// Function MirMobile.PetRenderRoom.GetSelectedPetID
// 0x0004 (0x0004 - 0x0000)
struct PetRenderRoom_GetSelectedPetID final
{
public:
	int32                                         ReturnValue;                                       // 0x0000(0x0004)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(PetRenderRoom_GetSelectedPetID) == 0x000004, "Wrong alignment on PetRenderRoom_GetSelectedPetID");
static_assert(sizeof(PetRenderRoom_GetSelectedPetID) == 0x000004, "Wrong size on PetRenderRoom_GetSelectedPetID");
static_assert(offsetof(PetRenderRoom_GetSelectedPetID, ReturnValue) == 0x000000, "Member 'PetRenderRoom_GetSelectedPetID::ReturnValue' has a wrong offset!");

// Function MirMobile.PetRenderRoom.OnChangePetTierEvent
// 0x0004 (0x0004 - 0x0000)
struct PetRenderRoom_OnChangePetTierEvent final
{
public:
	int32                                         PetTier;                                           // 0x0000(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(PetRenderRoom_OnChangePetTierEvent) == 0x000004, "Wrong alignment on PetRenderRoom_OnChangePetTierEvent");
static_assert(sizeof(PetRenderRoom_OnChangePetTierEvent) == 0x000004, "Wrong size on PetRenderRoom_OnChangePetTierEvent");
static_assert(offsetof(PetRenderRoom_OnChangePetTierEvent, PetTier) == 0x000000, "Member 'PetRenderRoom_OnChangePetTierEvent::PetTier' has a wrong offset!");

// Function MirMobile.PetRenderRoom.OnMeshLoadCompleteEvent
// 0x0004 (0x0004 - 0x0000)
struct PetRenderRoom_OnMeshLoadCompleteEvent final
{
public:
	int32                                         PetTier;                                           // 0x0000(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(PetRenderRoom_OnMeshLoadCompleteEvent) == 0x000004, "Wrong alignment on PetRenderRoom_OnMeshLoadCompleteEvent");
static_assert(sizeof(PetRenderRoom_OnMeshLoadCompleteEvent) == 0x000004, "Wrong size on PetRenderRoom_OnMeshLoadCompleteEvent");
static_assert(offsetof(PetRenderRoom_OnMeshLoadCompleteEvent, PetTier) == 0x000000, "Member 'PetRenderRoom_OnMeshLoadCompleteEvent::PetTier' has a wrong offset!");

// Function MirMobile.PetRenderRoom.SetCameraFOV
// 0x0004 (0x0004 - 0x0000)
struct PetRenderRoom_SetCameraFOV final
{
public:
	float                                         CameraFov;                                         // 0x0000(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(PetRenderRoom_SetCameraFOV) == 0x000004, "Wrong alignment on PetRenderRoom_SetCameraFOV");
static_assert(sizeof(PetRenderRoom_SetCameraFOV) == 0x000004, "Wrong size on PetRenderRoom_SetCameraFOV");
static_assert(offsetof(PetRenderRoom_SetCameraFOV, CameraFov) == 0x000000, "Member 'PetRenderRoom_SetCameraFOV::CameraFov' has a wrong offset!");

// Function MirMobile.PetRenderRoom.SetFloorData
// 0x001C (0x001C - 0x0000)
struct PetRenderRoom_SetFloorData final
{
public:
	float                                         FloorScale;                                        // 0x0000(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                FloorLocation;                                     // 0x0004(0x000C)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FRotator                               FloorRotation;                                     // 0x0010(0x000C)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(PetRenderRoom_SetFloorData) == 0x000004, "Wrong alignment on PetRenderRoom_SetFloorData");
static_assert(sizeof(PetRenderRoom_SetFloorData) == 0x00001C, "Wrong size on PetRenderRoom_SetFloorData");
static_assert(offsetof(PetRenderRoom_SetFloorData, FloorScale) == 0x000000, "Member 'PetRenderRoom_SetFloorData::FloorScale' has a wrong offset!");
static_assert(offsetof(PetRenderRoom_SetFloorData, FloorLocation) == 0x000004, "Member 'PetRenderRoom_SetFloorData::FloorLocation' has a wrong offset!");
static_assert(offsetof(PetRenderRoom_SetFloorData, FloorRotation) == 0x000010, "Member 'PetRenderRoom_SetFloorData::FloorRotation' has a wrong offset!");

// Function MirMobile.PetRenderRoom.SetPetPlacement
// 0x0018 (0x0018 - 0x0000)
struct PetRenderRoom_SetPetPlacement final
{
public:
	struct FVector                                PetLoc;                                            // 0x0000(0x000C)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FRotator                               PetRot;                                            // 0x000C(0x000C)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(PetRenderRoom_SetPetPlacement) == 0x000004, "Wrong alignment on PetRenderRoom_SetPetPlacement");
static_assert(sizeof(PetRenderRoom_SetPetPlacement) == 0x000018, "Wrong size on PetRenderRoom_SetPetPlacement");
static_assert(offsetof(PetRenderRoom_SetPetPlacement, PetLoc) == 0x000000, "Member 'PetRenderRoom_SetPetPlacement::PetLoc' has a wrong offset!");
static_assert(offsetof(PetRenderRoom_SetPetPlacement, PetRot) == 0x00000C, "Member 'PetRenderRoom_SetPetPlacement::PetRot' has a wrong offset!");

// Function MirMobile.PetRenderRoom.SetPetScale
// 0x0004 (0x0004 - 0x0000)
struct PetRenderRoom_SetPetScale final
{
public:
	float                                         PetScale;                                          // 0x0000(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(PetRenderRoom_SetPetScale) == 0x000004, "Wrong alignment on PetRenderRoom_SetPetScale");
static_assert(sizeof(PetRenderRoom_SetPetScale) == 0x000004, "Wrong size on PetRenderRoom_SetPetScale");
static_assert(offsetof(PetRenderRoom_SetPetScale, PetScale) == 0x000000, "Member 'PetRenderRoom_SetPetScale::PetScale' has a wrong offset!");

// Function MirMobile.PetRenderRoom.ShowLoadingEffect
// 0x0001 (0x0001 - 0x0000)
struct PetRenderRoom_ShowLoadingEffect final
{
public:
	bool                                          bShow;                                             // 0x0000(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(PetRenderRoom_ShowLoadingEffect) == 0x000001, "Wrong alignment on PetRenderRoom_ShowLoadingEffect");
static_assert(sizeof(PetRenderRoom_ShowLoadingEffect) == 0x000001, "Wrong size on PetRenderRoom_ShowLoadingEffect");
static_assert(offsetof(PetRenderRoom_ShowLoadingEffect, bShow) == 0x000000, "Member 'PetRenderRoom_ShowLoadingEffect::bShow' has a wrong offset!");

// Function MirMobile.PetRenderRoom.ShowupParticleEvent
// 0x0004 (0x0004 - 0x0000)
struct PetRenderRoom_ShowupParticleEvent final
{
public:
	int32                                         PetTier;                                           // 0x0000(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(PetRenderRoom_ShowupParticleEvent) == 0x000004, "Wrong alignment on PetRenderRoom_ShowupParticleEvent");
static_assert(sizeof(PetRenderRoom_ShowupParticleEvent) == 0x000004, "Wrong size on PetRenderRoom_ShowupParticleEvent");
static_assert(offsetof(PetRenderRoom_ShowupParticleEvent, PetTier) == 0x000000, "Member 'PetRenderRoom_ShowupParticleEvent::PetTier' has a wrong offset!");

// Function MirMobile.MM_SeasonToken_Make_Inventory.OnClickSlot
// 0x0004 (0x0004 - 0x0000)
struct MM_SeasonToken_Make_Inventory_OnClickSlot final
{
public:
	int32                                         IItemTID;                                          // 0x0000(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(MM_SeasonToken_Make_Inventory_OnClickSlot) == 0x000004, "Wrong alignment on MM_SeasonToken_Make_Inventory_OnClickSlot");
static_assert(sizeof(MM_SeasonToken_Make_Inventory_OnClickSlot) == 0x000004, "Wrong size on MM_SeasonToken_Make_Inventory_OnClickSlot");
static_assert(offsetof(MM_SeasonToken_Make_Inventory_OnClickSlot, IItemTID) == 0x000000, "Member 'MM_SeasonToken_Make_Inventory_OnClickSlot::IItemTID' has a wrong offset!");

// Function MirMobile.SceneCaptureLevelScriptActor.k2_Init
// 0x0008 (0x0008 - 0x0000)
struct SceneCaptureLevelScriptActor_K2_Init final
{
public:
	EClassType                                    ClassType;                                         // 0x0000(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EContentsSceneType                            ContentsSceneType;                                 // 0x0001(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2[0x2];                                        // 0x0002(0x0002)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         CameraType;                                        // 0x0004(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(SceneCaptureLevelScriptActor_K2_Init) == 0x000004, "Wrong alignment on SceneCaptureLevelScriptActor_K2_Init");
static_assert(sizeof(SceneCaptureLevelScriptActor_K2_Init) == 0x000008, "Wrong size on SceneCaptureLevelScriptActor_K2_Init");
static_assert(offsetof(SceneCaptureLevelScriptActor_K2_Init, ClassType) == 0x000000, "Member 'SceneCaptureLevelScriptActor_K2_Init::ClassType' has a wrong offset!");
static_assert(offsetof(SceneCaptureLevelScriptActor_K2_Init, ContentsSceneType) == 0x000001, "Member 'SceneCaptureLevelScriptActor_K2_Init::ContentsSceneType' has a wrong offset!");
static_assert(offsetof(SceneCaptureLevelScriptActor_K2_Init, CameraType) == 0x000004, "Member 'SceneCaptureLevelScriptActor_K2_Init::CameraType' has a wrong offset!");

// Function MirMobile.SceneCaptureLevelScriptActor.SetCamera
// 0x0004 (0x0004 - 0x0000)
struct SceneCaptureLevelScriptActor_SetCamera final
{
public:
	int32                                         CameraType;                                        // 0x0000(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(SceneCaptureLevelScriptActor_SetCamera) == 0x000004, "Wrong alignment on SceneCaptureLevelScriptActor_SetCamera");
static_assert(sizeof(SceneCaptureLevelScriptActor_SetCamera) == 0x000004, "Wrong size on SceneCaptureLevelScriptActor_SetCamera");
static_assert(offsetof(SceneCaptureLevelScriptActor_SetCamera, CameraType) == 0x000000, "Member 'SceneCaptureLevelScriptActor_SetCamera::CameraType' has a wrong offset!");

// Function MirMobile.RichTextBox.GetText
// 0x0018 (0x0018 - 0x0000)
struct RichTextBox_GetText final
{
public:
	class FText                                   ReturnValue;                                       // 0x0000(0x0018)(Parm, OutParm, ReturnParm, NativeAccessSpecifierPublic)
};
static_assert(alignof(RichTextBox_GetText) == 0x000008, "Wrong alignment on RichTextBox_GetText");
static_assert(sizeof(RichTextBox_GetText) == 0x000018, "Wrong size on RichTextBox_GetText");
static_assert(offsetof(RichTextBox_GetText, ReturnValue) == 0x000000, "Member 'RichTextBox_GetText::ReturnValue' has a wrong offset!");

// Function MirMobile.RichTextBox.SetColor
// 0x0010 (0x0010 - 0x0000)
struct RichTextBox_SetColor final
{
public:
	struct FLinearColor                           InColorAndOpacity;                                 // 0x0000(0x0010)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(RichTextBox_SetColor) == 0x000004, "Wrong alignment on RichTextBox_SetColor");
static_assert(sizeof(RichTextBox_SetColor) == 0x000010, "Wrong size on RichTextBox_SetColor");
static_assert(offsetof(RichTextBox_SetColor, InColorAndOpacity) == 0x000000, "Member 'RichTextBox_SetColor::InColorAndOpacity' has a wrong offset!");

// Function MirMobile.RichTextBox.SetFont
// 0x0050 (0x0050 - 0x0000)
struct RichTextBox_SetFont final
{
public:
	struct FSlateFontInfo                         InFont;                                            // 0x0000(0x0050)(Parm, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(RichTextBox_SetFont) == 0x000008, "Wrong alignment on RichTextBox_SetFont");
static_assert(sizeof(RichTextBox_SetFont) == 0x000050, "Wrong size on RichTextBox_SetFont");
static_assert(offsetof(RichTextBox_SetFont, InFont) == 0x000000, "Member 'RichTextBox_SetFont::InFont' has a wrong offset!");

// Function MirMobile.RichTextBox.SetText
// 0x0018 (0x0018 - 0x0000)
struct RichTextBox_SetText final
{
public:
	class FText                                   InText;                                            // 0x0000(0x0018)(Parm, NativeAccessSpecifierPublic)
};
static_assert(alignof(RichTextBox_SetText) == 0x000008, "Wrong alignment on RichTextBox_SetText");
static_assert(sizeof(RichTextBox_SetText) == 0x000018, "Wrong size on RichTextBox_SetText");
static_assert(offsetof(RichTextBox_SetText, InText) == 0x000000, "Member 'RichTextBox_SetText::InText' has a wrong offset!");

// Function MirMobile.MM_HudTargetInfo.OnClickBuffIcon
// 0x0004 (0x0004 - 0x0000)
struct MM_HudTargetInfo_OnClickBuffIcon final
{
public:
	int32                                         Idx;                                               // 0x0000(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(MM_HudTargetInfo_OnClickBuffIcon) == 0x000004, "Wrong alignment on MM_HudTargetInfo_OnClickBuffIcon");
static_assert(sizeof(MM_HudTargetInfo_OnClickBuffIcon) == 0x000004, "Wrong size on MM_HudTargetInfo_OnClickBuffIcon");
static_assert(offsetof(MM_HudTargetInfo_OnClickBuffIcon, Idx) == 0x000000, "Member 'MM_HudTargetInfo_OnClickBuffIcon::Idx' has a wrong offset!");

// Function MirMobile.MM_Popup_PersonalInfo.OnCheckStateChanged_CheckCaliforniaNo
// 0x0001 (0x0001 - 0x0000)
struct MM_Popup_PersonalInfo_OnCheckStateChanged_CheckCaliforniaNo final
{
public:
	bool                                          bChecked;                                          // 0x0000(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(MM_Popup_PersonalInfo_OnCheckStateChanged_CheckCaliforniaNo) == 0x000001, "Wrong alignment on MM_Popup_PersonalInfo_OnCheckStateChanged_CheckCaliforniaNo");
static_assert(sizeof(MM_Popup_PersonalInfo_OnCheckStateChanged_CheckCaliforniaNo) == 0x000001, "Wrong size on MM_Popup_PersonalInfo_OnCheckStateChanged_CheckCaliforniaNo");
static_assert(offsetof(MM_Popup_PersonalInfo_OnCheckStateChanged_CheckCaliforniaNo, bChecked) == 0x000000, "Member 'MM_Popup_PersonalInfo_OnCheckStateChanged_CheckCaliforniaNo::bChecked' has a wrong offset!");

// Function MirMobile.MM_Popup_PersonalInfo.OnCheckStateChanged_CheckCaliforniaYes
// 0x0001 (0x0001 - 0x0000)
struct MM_Popup_PersonalInfo_OnCheckStateChanged_CheckCaliforniaYes final
{
public:
	bool                                          bChecked;                                          // 0x0000(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(MM_Popup_PersonalInfo_OnCheckStateChanged_CheckCaliforniaYes) == 0x000001, "Wrong alignment on MM_Popup_PersonalInfo_OnCheckStateChanged_CheckCaliforniaYes");
static_assert(sizeof(MM_Popup_PersonalInfo_OnCheckStateChanged_CheckCaliforniaYes) == 0x000001, "Wrong size on MM_Popup_PersonalInfo_OnCheckStateChanged_CheckCaliforniaYes");
static_assert(offsetof(MM_Popup_PersonalInfo_OnCheckStateChanged_CheckCaliforniaYes, bChecked) == 0x000000, "Member 'MM_Popup_PersonalInfo_OnCheckStateChanged_CheckCaliforniaYes::bChecked' has a wrong offset!");

// Function MirMobile.MM_Popup_PersonalInfo.OnSelectionChanged_ComboBoxDay
// 0x0018 (0x0018 - 0x0000)
struct MM_Popup_PersonalInfo_OnSelectionChanged_ComboBoxDay final
{
public:
	class FString                                 SelectedItem;                                      // 0x0000(0x0010)(Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	ESelectInfo                                   SelectionType;                                     // 0x0010(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_11[0x7];                                       // 0x0011(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(MM_Popup_PersonalInfo_OnSelectionChanged_ComboBoxDay) == 0x000008, "Wrong alignment on MM_Popup_PersonalInfo_OnSelectionChanged_ComboBoxDay");
static_assert(sizeof(MM_Popup_PersonalInfo_OnSelectionChanged_ComboBoxDay) == 0x000018, "Wrong size on MM_Popup_PersonalInfo_OnSelectionChanged_ComboBoxDay");
static_assert(offsetof(MM_Popup_PersonalInfo_OnSelectionChanged_ComboBoxDay, SelectedItem) == 0x000000, "Member 'MM_Popup_PersonalInfo_OnSelectionChanged_ComboBoxDay::SelectedItem' has a wrong offset!");
static_assert(offsetof(MM_Popup_PersonalInfo_OnSelectionChanged_ComboBoxDay, SelectionType) == 0x000010, "Member 'MM_Popup_PersonalInfo_OnSelectionChanged_ComboBoxDay::SelectionType' has a wrong offset!");

// Function MirMobile.MM_Popup_PersonalInfo.OnSelectionChanged_ComboBoxMonth
// 0x0018 (0x0018 - 0x0000)
struct MM_Popup_PersonalInfo_OnSelectionChanged_ComboBoxMonth final
{
public:
	class FString                                 SelectedItem;                                      // 0x0000(0x0010)(Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	ESelectInfo                                   SelectionType;                                     // 0x0010(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_11[0x7];                                       // 0x0011(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(MM_Popup_PersonalInfo_OnSelectionChanged_ComboBoxMonth) == 0x000008, "Wrong alignment on MM_Popup_PersonalInfo_OnSelectionChanged_ComboBoxMonth");
static_assert(sizeof(MM_Popup_PersonalInfo_OnSelectionChanged_ComboBoxMonth) == 0x000018, "Wrong size on MM_Popup_PersonalInfo_OnSelectionChanged_ComboBoxMonth");
static_assert(offsetof(MM_Popup_PersonalInfo_OnSelectionChanged_ComboBoxMonth, SelectedItem) == 0x000000, "Member 'MM_Popup_PersonalInfo_OnSelectionChanged_ComboBoxMonth::SelectedItem' has a wrong offset!");
static_assert(offsetof(MM_Popup_PersonalInfo_OnSelectionChanged_ComboBoxMonth, SelectionType) == 0x000010, "Member 'MM_Popup_PersonalInfo_OnSelectionChanged_ComboBoxMonth::SelectionType' has a wrong offset!");

// Function MirMobile.MM_Popup_PersonalInfo.OnSelectionChanged_ComboBoxYear
// 0x0018 (0x0018 - 0x0000)
struct MM_Popup_PersonalInfo_OnSelectionChanged_ComboBoxYear final
{
public:
	class FString                                 SelectedItem;                                      // 0x0000(0x0010)(Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	ESelectInfo                                   SelectionType;                                     // 0x0010(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_11[0x7];                                       // 0x0011(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(MM_Popup_PersonalInfo_OnSelectionChanged_ComboBoxYear) == 0x000008, "Wrong alignment on MM_Popup_PersonalInfo_OnSelectionChanged_ComboBoxYear");
static_assert(sizeof(MM_Popup_PersonalInfo_OnSelectionChanged_ComboBoxYear) == 0x000018, "Wrong size on MM_Popup_PersonalInfo_OnSelectionChanged_ComboBoxYear");
static_assert(offsetof(MM_Popup_PersonalInfo_OnSelectionChanged_ComboBoxYear, SelectedItem) == 0x000000, "Member 'MM_Popup_PersonalInfo_OnSelectionChanged_ComboBoxYear::SelectedItem' has a wrong offset!");
static_assert(offsetof(MM_Popup_PersonalInfo_OnSelectionChanged_ComboBoxYear, SelectionType) == 0x000010, "Member 'MM_Popup_PersonalInfo_OnSelectionChanged_ComboBoxYear::SelectionType' has a wrong offset!");

// Function MirMobile.MM_Popup_PersonalInfo.OnTextChanged_EditZipcode
// 0x0018 (0x0018 - 0x0000)
struct MM_Popup_PersonalInfo_OnTextChanged_EditZipcode final
{
public:
	class FText                                   Text;                                              // 0x0000(0x0018)(ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
};
static_assert(alignof(MM_Popup_PersonalInfo_OnTextChanged_EditZipcode) == 0x000008, "Wrong alignment on MM_Popup_PersonalInfo_OnTextChanged_EditZipcode");
static_assert(sizeof(MM_Popup_PersonalInfo_OnTextChanged_EditZipcode) == 0x000018, "Wrong size on MM_Popup_PersonalInfo_OnTextChanged_EditZipcode");
static_assert(offsetof(MM_Popup_PersonalInfo_OnTextChanged_EditZipcode, Text) == 0x000000, "Member 'MM_Popup_PersonalInfo_OnTextChanged_EditZipcode::Text' has a wrong offset!");

// Function MirMobile.MM_Inventory_Tab.ShowBtnIndicator
// 0x0004 (0x0004 - 0x0000)
struct MM_Inventory_Tab_ShowBtnIndicator final
{
public:
	int32                                         IIndicator;                                        // 0x0000(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(MM_Inventory_Tab_ShowBtnIndicator) == 0x000004, "Wrong alignment on MM_Inventory_Tab_ShowBtnIndicator");
static_assert(sizeof(MM_Inventory_Tab_ShowBtnIndicator) == 0x000004, "Wrong size on MM_Inventory_Tab_ShowBtnIndicator");
static_assert(offsetof(MM_Inventory_Tab_ShowBtnIndicator, IIndicator) == 0x000000, "Member 'MM_Inventory_Tab_ShowBtnIndicator::IIndicator' has a wrong offset!");

// Function MirMobile.MM_Inventory_Tab.ShowIndicator
// 0x0004 (0x0004 - 0x0000)
struct MM_Inventory_Tab_ShowIndicator final
{
public:
	int32                                         IIndicator;                                        // 0x0000(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(MM_Inventory_Tab_ShowIndicator) == 0x000004, "Wrong alignment on MM_Inventory_Tab_ShowIndicator");
static_assert(sizeof(MM_Inventory_Tab_ShowIndicator) == 0x000004, "Wrong size on MM_Inventory_Tab_ShowIndicator");
static_assert(offsetof(MM_Inventory_Tab_ShowIndicator, IIndicator) == 0x000000, "Member 'MM_Inventory_Tab_ShowIndicator::IIndicator' has a wrong offset!");

// Function MirMobile.MM_Popup_PostCodeChange.OnTextChanged_EditZipcode
// 0x0018 (0x0018 - 0x0000)
struct MM_Popup_PostCodeChange_OnTextChanged_EditZipcode final
{
public:
	class FText                                   Text;                                              // 0x0000(0x0018)(ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
};
static_assert(alignof(MM_Popup_PostCodeChange_OnTextChanged_EditZipcode) == 0x000008, "Wrong alignment on MM_Popup_PostCodeChange_OnTextChanged_EditZipcode");
static_assert(sizeof(MM_Popup_PostCodeChange_OnTextChanged_EditZipcode) == 0x000018, "Wrong size on MM_Popup_PostCodeChange_OnTextChanged_EditZipcode");
static_assert(offsetof(MM_Popup_PostCodeChange_OnTextChanged_EditZipcode, Text) == 0x000000, "Member 'MM_Popup_PostCodeChange_OnTextChanged_EditZipcode::Text' has a wrong offset!");

// Function MirMobile.MM_Popup_Potential_TotalInfo.OnClickCheckBoxPassiveTab
// 0x0001 (0x0001 - 0x0000)
struct MM_Popup_Potential_TotalInfo_OnClickCheckBoxPassiveTab final
{
public:
	bool                                          bChecked;                                          // 0x0000(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(MM_Popup_Potential_TotalInfo_OnClickCheckBoxPassiveTab) == 0x000001, "Wrong alignment on MM_Popup_Potential_TotalInfo_OnClickCheckBoxPassiveTab");
static_assert(sizeof(MM_Popup_Potential_TotalInfo_OnClickCheckBoxPassiveTab) == 0x000001, "Wrong size on MM_Popup_Potential_TotalInfo_OnClickCheckBoxPassiveTab");
static_assert(offsetof(MM_Popup_Potential_TotalInfo_OnClickCheckBoxPassiveTab, bChecked) == 0x000000, "Member 'MM_Popup_Potential_TotalInfo_OnClickCheckBoxPassiveTab::bChecked' has a wrong offset!");

// Function MirMobile.MM_Popup_Potential_TotalInfo.OnClickCheckBoxStatusTab
// 0x0001 (0x0001 - 0x0000)
struct MM_Popup_Potential_TotalInfo_OnClickCheckBoxStatusTab final
{
public:
	bool                                          bChecked;                                          // 0x0000(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(MM_Popup_Potential_TotalInfo_OnClickCheckBoxStatusTab) == 0x000001, "Wrong alignment on MM_Popup_Potential_TotalInfo_OnClickCheckBoxStatusTab");
static_assert(sizeof(MM_Popup_Potential_TotalInfo_OnClickCheckBoxStatusTab) == 0x000001, "Wrong size on MM_Popup_Potential_TotalInfo_OnClickCheckBoxStatusTab");
static_assert(offsetof(MM_Popup_Potential_TotalInfo_OnClickCheckBoxStatusTab, bChecked) == 0x000000, "Member 'MM_Popup_Potential_TotalInfo_OnClickCheckBoxStatusTab::bChecked' has a wrong offset!");

// Function MirMobile.MM_Item_Make_Slider.SetCurValueReturn
// 0x0008 (0x0008 - 0x0000)
struct MM_Item_Make_Slider_SetCurValueReturn final
{
public:
	int64                                         Value;                                             // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(MM_Item_Make_Slider_SetCurValueReturn) == 0x000008, "Wrong alignment on MM_Item_Make_Slider_SetCurValueReturn");
static_assert(sizeof(MM_Item_Make_Slider_SetCurValueReturn) == 0x000008, "Wrong size on MM_Item_Make_Slider_SetCurValueReturn");
static_assert(offsetof(MM_Item_Make_Slider_SetCurValueReturn, Value) == 0x000000, "Member 'MM_Item_Make_Slider_SetCurValueReturn::Value' has a wrong offset!");

// Function MirMobile.MM_Item_Make_Slider_BigInteger.SetCurValueReturn
// 0x0008 (0x0008 - 0x0000)
struct MM_Item_Make_Slider_BigInteger_SetCurValueReturn final
{
public:
	int64                                         Value;                                             // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(MM_Item_Make_Slider_BigInteger_SetCurValueReturn) == 0x000008, "Wrong alignment on MM_Item_Make_Slider_BigInteger_SetCurValueReturn");
static_assert(sizeof(MM_Item_Make_Slider_BigInteger_SetCurValueReturn) == 0x000008, "Wrong size on MM_Item_Make_Slider_BigInteger_SetCurValueReturn");
static_assert(offsetof(MM_Item_Make_Slider_BigInteger_SetCurValueReturn, Value) == 0x000000, "Member 'MM_Item_Make_Slider_BigInteger_SetCurValueReturn::Value' has a wrong offset!");

// Function MirMobile.MM_Item_Make_Special_Popup.OnClickInvenSlot
// 0x0008 (0x0008 - 0x0000)
struct MM_Item_Make_Special_Popup_OnClickInvenSlot final
{
public:
	class UMM_Slot_Base*                          SlotWidget;                                        // 0x0000(0x0008)(Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(MM_Item_Make_Special_Popup_OnClickInvenSlot) == 0x000008, "Wrong alignment on MM_Item_Make_Special_Popup_OnClickInvenSlot");
static_assert(sizeof(MM_Item_Make_Special_Popup_OnClickInvenSlot) == 0x000008, "Wrong size on MM_Item_Make_Special_Popup_OnClickInvenSlot");
static_assert(offsetof(MM_Item_Make_Special_Popup_OnClickInvenSlot, SlotWidget) == 0x000000, "Member 'MM_Item_Make_Special_Popup_OnClickInvenSlot::SlotWidget' has a wrong offset!");

// Function MirMobile.MM_Item_Make_Special_Popup.OnClickMaterialItem
// 0x0008 (0x0008 - 0x0000)
struct MM_Item_Make_Special_Popup_OnClickMaterialItem final
{
public:
	class UMM_Slot_Base*                          PSlot;                                             // 0x0000(0x0008)(Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(MM_Item_Make_Special_Popup_OnClickMaterialItem) == 0x000008, "Wrong alignment on MM_Item_Make_Special_Popup_OnClickMaterialItem");
static_assert(sizeof(MM_Item_Make_Special_Popup_OnClickMaterialItem) == 0x000008, "Wrong size on MM_Item_Make_Special_Popup_OnClickMaterialItem");
static_assert(offsetof(MM_Item_Make_Special_Popup_OnClickMaterialItem, PSlot) == 0x000000, "Member 'MM_Item_Make_Special_Popup_OnClickMaterialItem::PSlot' has a wrong offset!");

// Function MirMobile.MM_Popup_HolyStuff_Detail_Info.OnClick_CheckBoxPassive
// 0x0001 (0x0001 - 0x0000)
struct MM_Popup_HolyStuff_Detail_Info_OnClick_CheckBoxPassive final
{
public:
	bool                                          bSelected;                                         // 0x0000(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(MM_Popup_HolyStuff_Detail_Info_OnClick_CheckBoxPassive) == 0x000001, "Wrong alignment on MM_Popup_HolyStuff_Detail_Info_OnClick_CheckBoxPassive");
static_assert(sizeof(MM_Popup_HolyStuff_Detail_Info_OnClick_CheckBoxPassive) == 0x000001, "Wrong size on MM_Popup_HolyStuff_Detail_Info_OnClick_CheckBoxPassive");
static_assert(offsetof(MM_Popup_HolyStuff_Detail_Info_OnClick_CheckBoxPassive, bSelected) == 0x000000, "Member 'MM_Popup_HolyStuff_Detail_Info_OnClick_CheckBoxPassive::bSelected' has a wrong offset!");

// Function MirMobile.MM_Popup_HolyStuff_Detail_Info.OnClick_CheckBoxStat
// 0x0001 (0x0001 - 0x0000)
struct MM_Popup_HolyStuff_Detail_Info_OnClick_CheckBoxStat final
{
public:
	bool                                          bSelected;                                         // 0x0000(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(MM_Popup_HolyStuff_Detail_Info_OnClick_CheckBoxStat) == 0x000001, "Wrong alignment on MM_Popup_HolyStuff_Detail_Info_OnClick_CheckBoxStat");
static_assert(sizeof(MM_Popup_HolyStuff_Detail_Info_OnClick_CheckBoxStat) == 0x000001, "Wrong size on MM_Popup_HolyStuff_Detail_Info_OnClick_CheckBoxStat");
static_assert(offsetof(MM_Popup_HolyStuff_Detail_Info_OnClick_CheckBoxStat, bSelected) == 0x000000, "Member 'MM_Popup_HolyStuff_Detail_Info_OnClick_CheckBoxStat::bSelected' has a wrong offset!");

// Function MirMobile.MM_PopUp_InventoryExtend.OnChangeCount
// 0x0008 (0x0008 - 0x0000)
struct MM_PopUp_InventoryExtend_OnChangeCount final
{
public:
	int64                                         IValue;                                            // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(MM_PopUp_InventoryExtend_OnChangeCount) == 0x000008, "Wrong alignment on MM_PopUp_InventoryExtend_OnChangeCount");
static_assert(sizeof(MM_PopUp_InventoryExtend_OnChangeCount) == 0x000008, "Wrong size on MM_PopUp_InventoryExtend_OnChangeCount");
static_assert(offsetof(MM_PopUp_InventoryExtend_OnChangeCount, IValue) == 0x000000, "Member 'MM_PopUp_InventoryExtend_OnChangeCount::IValue' has a wrong offset!");

// Function MirMobile.MM_ItemMake_Inventory.OnClickCraftSlot
// 0x0004 (0x0004 - 0x0000)
struct MM_ItemMake_Inventory_OnClickCraftSlot final
{
public:
	int32                                         CraftId;                                           // 0x0000(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(MM_ItemMake_Inventory_OnClickCraftSlot) == 0x000004, "Wrong alignment on MM_ItemMake_Inventory_OnClickCraftSlot");
static_assert(sizeof(MM_ItemMake_Inventory_OnClickCraftSlot) == 0x000004, "Wrong size on MM_ItemMake_Inventory_OnClickCraftSlot");
static_assert(offsetof(MM_ItemMake_Inventory_OnClickCraftSlot, CraftId) == 0x000000, "Member 'MM_ItemMake_Inventory_OnClickCraftSlot::CraftId' has a wrong offset!");

// Function MirMobile.MM_ItemMake_Inventory.OnClickSlot
// 0x0004 (0x0004 - 0x0000)
struct MM_ItemMake_Inventory_OnClickSlot final
{
public:
	int32                                         MakeItemId;                                        // 0x0000(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(MM_ItemMake_Inventory_OnClickSlot) == 0x000004, "Wrong alignment on MM_ItemMake_Inventory_OnClickSlot");
static_assert(sizeof(MM_ItemMake_Inventory_OnClickSlot) == 0x000004, "Wrong size on MM_ItemMake_Inventory_OnClickSlot");
static_assert(offsetof(MM_ItemMake_Inventory_OnClickSlot, MakeItemId) == 0x000000, "Member 'MM_ItemMake_Inventory_OnClickSlot::MakeItemId' has a wrong offset!");

// Function MirMobile.MM_MagicOrbPopupOptionChange.OnOptionChangeEffect
// 0x0004 (0x0004 - 0x0000)
struct MM_MagicOrbPopupOptionChange_OnOptionChangeEffect final
{
public:
	float                                         Delta_time_;                                       // 0x0000(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(MM_MagicOrbPopupOptionChange_OnOptionChangeEffect) == 0x000004, "Wrong alignment on MM_MagicOrbPopupOptionChange_OnOptionChangeEffect");
static_assert(sizeof(MM_MagicOrbPopupOptionChange_OnOptionChangeEffect) == 0x000004, "Wrong size on MM_MagicOrbPopupOptionChange_OnOptionChangeEffect");
static_assert(offsetof(MM_MagicOrbPopupOptionChange_OnOptionChangeEffect, Delta_time_) == 0x000000, "Member 'MM_MagicOrbPopupOptionChange_OnOptionChangeEffect::Delta_time_' has a wrong offset!");

// Function MirMobile.MM_Popup_OneStoreIAP.OnUrlChanged
// 0x0018 (0x0018 - 0x0000)
struct MM_Popup_OneStoreIAP_OnUrlChanged final
{
public:
	class FText                                   URL;                                               // 0x0000(0x0018)(ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
};
static_assert(alignof(MM_Popup_OneStoreIAP_OnUrlChanged) == 0x000008, "Wrong alignment on MM_Popup_OneStoreIAP_OnUrlChanged");
static_assert(sizeof(MM_Popup_OneStoreIAP_OnUrlChanged) == 0x000018, "Wrong size on MM_Popup_OneStoreIAP_OnUrlChanged");
static_assert(offsetof(MM_Popup_OneStoreIAP_OnUrlChanged, URL) == 0x000000, "Member 'MM_Popup_OneStoreIAP_OnUrlChanged::URL' has a wrong offset!");

// Function MirMobile.MM_UserEvent_MissionPass_Slot.OnClickSlot
// 0x0008 (0x0008 - 0x0000)
struct MM_UserEvent_MissionPass_Slot_OnClickSlot final
{
public:
	class UMM_Slot_Base*                          PSlot;                                             // 0x0000(0x0008)(Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(MM_UserEvent_MissionPass_Slot_OnClickSlot) == 0x000008, "Wrong alignment on MM_UserEvent_MissionPass_Slot_OnClickSlot");
static_assert(sizeof(MM_UserEvent_MissionPass_Slot_OnClickSlot) == 0x000008, "Wrong size on MM_UserEvent_MissionPass_Slot_OnClickSlot");
static_assert(offsetof(MM_UserEvent_MissionPass_Slot_OnClickSlot, PSlot) == 0x000000, "Member 'MM_UserEvent_MissionPass_Slot_OnClickSlot::PSlot' has a wrong offset!");

// Function MirMobile.MM_Popup_Siege_Command_EditText.OnTextChangeInputText
// 0x0018 (0x0018 - 0x0000)
struct MM_Popup_Siege_Command_EditText_OnTextChangeInputText final
{
public:
	class FText                                   Text;                                              // 0x0000(0x0018)(ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
};
static_assert(alignof(MM_Popup_Siege_Command_EditText_OnTextChangeInputText) == 0x000008, "Wrong alignment on MM_Popup_Siege_Command_EditText_OnTextChangeInputText");
static_assert(sizeof(MM_Popup_Siege_Command_EditText_OnTextChangeInputText) == 0x000018, "Wrong size on MM_Popup_Siege_Command_EditText_OnTextChangeInputText");
static_assert(offsetof(MM_Popup_Siege_Command_EditText_OnTextChangeInputText, Text) == 0x000000, "Member 'MM_Popup_Siege_Command_EditText_OnTextChangeInputText::Text' has a wrong offset!");

// Function MirMobile.MM_PC.GetCameraControl
// 0x0008 (0x0008 - 0x0000)
struct MM_PC_GetCameraControl final
{
public:
	class ALobbyCameraControl*                    ReturnValue;                                       // 0x0000(0x0008)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(MM_PC_GetCameraControl) == 0x000008, "Wrong alignment on MM_PC_GetCameraControl");
static_assert(sizeof(MM_PC_GetCameraControl) == 0x000008, "Wrong size on MM_PC_GetCameraControl");
static_assert(offsetof(MM_PC_GetCameraControl, ReturnValue) == 0x000000, "Member 'MM_PC_GetCameraControl::ReturnValue' has a wrong offset!");

// Function MirMobile.MM_PC.GetHeroCamera
// 0x0008 (0x0008 - 0x0000)
struct MM_PC_GetHeroCamera final
{
public:
	class AHeroInfoCamera*                        ReturnValue;                                       // 0x0000(0x0008)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(MM_PC_GetHeroCamera) == 0x000008, "Wrong alignment on MM_PC_GetHeroCamera");
static_assert(sizeof(MM_PC_GetHeroCamera) == 0x000008, "Wrong size on MM_PC_GetHeroCamera");
static_assert(offsetof(MM_PC_GetHeroCamera, ReturnValue) == 0x000000, "Member 'MM_PC_GetHeroCamera::ReturnValue' has a wrong offset!");

// Function MirMobile.MM_PC.IsBattleState
// 0x0001 (0x0001 - 0x0000)
struct MM_PC_IsBattleState final
{
public:
	bool                                          ReturnValue;                                       // 0x0000(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(MM_PC_IsBattleState) == 0x000001, "Wrong alignment on MM_PC_IsBattleState");
static_assert(sizeof(MM_PC_IsBattleState) == 0x000001, "Wrong size on MM_PC_IsBattleState");
static_assert(offsetof(MM_PC_IsBattleState, ReturnValue) == 0x000000, "Member 'MM_PC_IsBattleState::ReturnValue' has a wrong offset!");

// Function MirMobile.MM_MainPC.HitWall
// 0x0088 (0x0088 - 0x0000)
struct MM_MainPC_HitWall final
{
public:
	struct FHitResult                             HitResult;                                         // 0x0000(0x0088)(Parm, IsPlainOldData, NoDestructor, ContainsInstancedReference, NativeAccessSpecifierPublic)
};
static_assert(alignof(MM_MainPC_HitWall) == 0x000004, "Wrong alignment on MM_MainPC_HitWall");
static_assert(sizeof(MM_MainPC_HitWall) == 0x000088, "Wrong size on MM_MainPC_HitWall");
static_assert(offsetof(MM_MainPC_HitWall, HitResult) == 0x000000, "Member 'MM_MainPC_HitWall::HitResult' has a wrong offset!");

// Function MirMobile.MM_MainPC.K2_AutoBehaviorFindGatherObject
// 0x0001 (0x0001 - 0x0000)
struct MM_MainPC_K2_AutoBehaviorFindGatherObject final
{
public:
	bool                                          ReturnValue;                                       // 0x0000(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(MM_MainPC_K2_AutoBehaviorFindGatherObject) == 0x000001, "Wrong alignment on MM_MainPC_K2_AutoBehaviorFindGatherObject");
static_assert(sizeof(MM_MainPC_K2_AutoBehaviorFindGatherObject) == 0x000001, "Wrong size on MM_MainPC_K2_AutoBehaviorFindGatherObject");
static_assert(offsetof(MM_MainPC_K2_AutoBehaviorFindGatherObject, ReturnValue) == 0x000000, "Member 'MM_MainPC_K2_AutoBehaviorFindGatherObject::ReturnValue' has a wrong offset!");

// Function MirMobile.MM_MainPC.K2_AutoBehaviorFindTargetByQuest
// 0x0001 (0x0001 - 0x0000)
struct MM_MainPC_K2_AutoBehaviorFindTargetByQuest final
{
public:
	bool                                          ReturnValue;                                       // 0x0000(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(MM_MainPC_K2_AutoBehaviorFindTargetByQuest) == 0x000001, "Wrong alignment on MM_MainPC_K2_AutoBehaviorFindTargetByQuest");
static_assert(sizeof(MM_MainPC_K2_AutoBehaviorFindTargetByQuest) == 0x000001, "Wrong size on MM_MainPC_K2_AutoBehaviorFindTargetByQuest");
static_assert(offsetof(MM_MainPC_K2_AutoBehaviorFindTargetByQuest, ReturnValue) == 0x000000, "Member 'MM_MainPC_K2_AutoBehaviorFindTargetByQuest::ReturnValue' has a wrong offset!");

// Function MirMobile.MM_MainPC.K2_AutoBehaviorFindTargetInEnemies
// 0x0001 (0x0001 - 0x0000)
struct MM_MainPC_K2_AutoBehaviorFindTargetInEnemies final
{
public:
	bool                                          ReturnValue;                                       // 0x0000(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(MM_MainPC_K2_AutoBehaviorFindTargetInEnemies) == 0x000001, "Wrong alignment on MM_MainPC_K2_AutoBehaviorFindTargetInEnemies");
static_assert(sizeof(MM_MainPC_K2_AutoBehaviorFindTargetInEnemies) == 0x000001, "Wrong size on MM_MainPC_K2_AutoBehaviorFindTargetInEnemies");
static_assert(offsetof(MM_MainPC_K2_AutoBehaviorFindTargetInEnemies, ReturnValue) == 0x000000, "Member 'MM_MainPC_K2_AutoBehaviorFindTargetInEnemies::ReturnValue' has a wrong offset!");

// Function MirMobile.MM_MainPC.K2_AutoBehaviorFindTargetOnAround
// 0x0001 (0x0001 - 0x0000)
struct MM_MainPC_K2_AutoBehaviorFindTargetOnAround final
{
public:
	bool                                          ReturnValue;                                       // 0x0000(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(MM_MainPC_K2_AutoBehaviorFindTargetOnAround) == 0x000001, "Wrong alignment on MM_MainPC_K2_AutoBehaviorFindTargetOnAround");
static_assert(sizeof(MM_MainPC_K2_AutoBehaviorFindTargetOnAround) == 0x000001, "Wrong size on MM_MainPC_K2_AutoBehaviorFindTargetOnAround");
static_assert(offsetof(MM_MainPC_K2_AutoBehaviorFindTargetOnAround, ReturnValue) == 0x000000, "Member 'MM_MainPC_K2_AutoBehaviorFindTargetOnAround::ReturnValue' has a wrong offset!");

// Function MirMobile.MM_MainPC.K2_IsOutOfQuestCompleteCoordRange
// 0x0001 (0x0001 - 0x0000)
struct MM_MainPC_K2_IsOutOfQuestCompleteCoordRange final
{
public:
	bool                                          ReturnValue;                                       // 0x0000(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(MM_MainPC_K2_IsOutOfQuestCompleteCoordRange) == 0x000001, "Wrong alignment on MM_MainPC_K2_IsOutOfQuestCompleteCoordRange");
static_assert(sizeof(MM_MainPC_K2_IsOutOfQuestCompleteCoordRange) == 0x000001, "Wrong size on MM_MainPC_K2_IsOutOfQuestCompleteCoordRange");
static_assert(offsetof(MM_MainPC_K2_IsOutOfQuestCompleteCoordRange, ReturnValue) == 0x000000, "Member 'MM_MainPC_K2_IsOutOfQuestCompleteCoordRange::ReturnValue' has a wrong offset!");

// Function MirMobile.MM_MainPC.K2_ReturnToCenter
// 0x0002 (0x0002 - 0x0000)
struct MM_MainPC_K2_ReturnToCenter final
{
public:
	bool                                          Force;                                             // 0x0000(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          ReturnValue;                                       // 0x0001(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(MM_MainPC_K2_ReturnToCenter) == 0x000001, "Wrong alignment on MM_MainPC_K2_ReturnToCenter");
static_assert(sizeof(MM_MainPC_K2_ReturnToCenter) == 0x000002, "Wrong size on MM_MainPC_K2_ReturnToCenter");
static_assert(offsetof(MM_MainPC_K2_ReturnToCenter, Force) == 0x000000, "Member 'MM_MainPC_K2_ReturnToCenter::Force' has a wrong offset!");
static_assert(offsetof(MM_MainPC_K2_ReturnToCenter, ReturnValue) == 0x000001, "Member 'MM_MainPC_K2_ReturnToCenter::ReturnValue' has a wrong offset!");

// Function MirMobile.MM_MainPC.K2_SetAutoState
// 0x0001 (0x0001 - 0x0000)
struct MM_MainPC_K2_SetAutoState final
{
public:
	EAutoBattleState                              NewState;                                          // 0x0000(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(MM_MainPC_K2_SetAutoState) == 0x000001, "Wrong alignment on MM_MainPC_K2_SetAutoState");
static_assert(sizeof(MM_MainPC_K2_SetAutoState) == 0x000001, "Wrong size on MM_MainPC_K2_SetAutoState");
static_assert(offsetof(MM_MainPC_K2_SetAutoState, NewState) == 0x000000, "Member 'MM_MainPC_K2_SetAutoState::NewState' has a wrong offset!");

// Function MirMobile.MM_MainPC.K2_SetBehaviorType
// 0x0001 (0x0001 - 0x0000)
struct MM_MainPC_K2_SetBehaviorType final
{
public:
	EBehaviorType                                 NewBehaviorType;                                   // 0x0000(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(MM_MainPC_K2_SetBehaviorType) == 0x000001, "Wrong alignment on MM_MainPC_K2_SetBehaviorType");
static_assert(sizeof(MM_MainPC_K2_SetBehaviorType) == 0x000001, "Wrong size on MM_MainPC_K2_SetBehaviorType");
static_assert(offsetof(MM_MainPC_K2_SetBehaviorType, NewBehaviorType) == 0x000000, "Member 'MM_MainPC_K2_SetBehaviorType::NewBehaviorType' has a wrong offset!");

// Function MirMobile.MM_MainPC.K2_UpdateCenterLocation
// 0x0001 (0x0001 - 0x0000)
struct MM_MainPC_K2_UpdateCenterLocation final
{
public:
	bool                                          ReturnValue;                                       // 0x0000(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(MM_MainPC_K2_UpdateCenterLocation) == 0x000001, "Wrong alignment on MM_MainPC_K2_UpdateCenterLocation");
static_assert(sizeof(MM_MainPC_K2_UpdateCenterLocation) == 0x000001, "Wrong size on MM_MainPC_K2_UpdateCenterLocation");
static_assert(offsetof(MM_MainPC_K2_UpdateCenterLocation, ReturnValue) == 0x000000, "Member 'MM_MainPC_K2_UpdateCenterLocation::ReturnValue' has a wrong offset!");

// Function MirMobile.MM_PopUp_SuccessionWeapon_EquipAuto.OnClickEquipSlot
// 0x0010 (0x0010 - 0x0000)
struct MM_PopUp_SuccessionWeapon_EquipAuto_OnClickEquipSlot final
{
public:
	int64                                         IItemUID;                                          // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         IItemTID;                                          // 0x0008(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         ISlotIndex;                                        // 0x000C(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(MM_PopUp_SuccessionWeapon_EquipAuto_OnClickEquipSlot) == 0x000008, "Wrong alignment on MM_PopUp_SuccessionWeapon_EquipAuto_OnClickEquipSlot");
static_assert(sizeof(MM_PopUp_SuccessionWeapon_EquipAuto_OnClickEquipSlot) == 0x000010, "Wrong size on MM_PopUp_SuccessionWeapon_EquipAuto_OnClickEquipSlot");
static_assert(offsetof(MM_PopUp_SuccessionWeapon_EquipAuto_OnClickEquipSlot, IItemUID) == 0x000000, "Member 'MM_PopUp_SuccessionWeapon_EquipAuto_OnClickEquipSlot::IItemUID' has a wrong offset!");
static_assert(offsetof(MM_PopUp_SuccessionWeapon_EquipAuto_OnClickEquipSlot, IItemTID) == 0x000008, "Member 'MM_PopUp_SuccessionWeapon_EquipAuto_OnClickEquipSlot::IItemTID' has a wrong offset!");
static_assert(offsetof(MM_PopUp_SuccessionWeapon_EquipAuto_OnClickEquipSlot, ISlotIndex) == 0x00000C, "Member 'MM_PopUp_SuccessionWeapon_EquipAuto_OnClickEquipSlot::ISlotIndex' has a wrong offset!");

// Function MirMobile.MM_Map_CheckBtn.OnClickMain
// 0x0001 (0x0001 - 0x0000)
struct MM_Map_CheckBtn_OnClickMain final
{
public:
	bool                                          bCheck;                                            // 0x0000(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(MM_Map_CheckBtn_OnClickMain) == 0x000001, "Wrong alignment on MM_Map_CheckBtn_OnClickMain");
static_assert(sizeof(MM_Map_CheckBtn_OnClickMain) == 0x000001, "Wrong size on MM_Map_CheckBtn_OnClickMain");
static_assert(offsetof(MM_Map_CheckBtn_OnClickMain, bCheck) == 0x000000, "Member 'MM_Map_CheckBtn_OnClickMain::bCheck' has a wrong offset!");

// Function MirMobile.MM_Popup_TermsOfService.OnClickCheckBoxAd
// 0x0001 (0x0001 - 0x0000)
struct MM_Popup_TermsOfService_OnClickCheckBoxAd final
{
public:
	bool                                          bChecked;                                          // 0x0000(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(MM_Popup_TermsOfService_OnClickCheckBoxAd) == 0x000001, "Wrong alignment on MM_Popup_TermsOfService_OnClickCheckBoxAd");
static_assert(sizeof(MM_Popup_TermsOfService_OnClickCheckBoxAd) == 0x000001, "Wrong size on MM_Popup_TermsOfService_OnClickCheckBoxAd");
static_assert(offsetof(MM_Popup_TermsOfService_OnClickCheckBoxAd, bChecked) == 0x000000, "Member 'MM_Popup_TermsOfService_OnClickCheckBoxAd::bChecked' has a wrong offset!");

// Function MirMobile.MM_Popup_TermsOfService.OnClickCheckBoxNightPush
// 0x0001 (0x0001 - 0x0000)
struct MM_Popup_TermsOfService_OnClickCheckBoxNightPush final
{
public:
	bool                                          bChecked;                                          // 0x0000(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(MM_Popup_TermsOfService_OnClickCheckBoxNightPush) == 0x000001, "Wrong alignment on MM_Popup_TermsOfService_OnClickCheckBoxNightPush");
static_assert(sizeof(MM_Popup_TermsOfService_OnClickCheckBoxNightPush) == 0x000001, "Wrong size on MM_Popup_TermsOfService_OnClickCheckBoxNightPush");
static_assert(offsetof(MM_Popup_TermsOfService_OnClickCheckBoxNightPush, bChecked) == 0x000000, "Member 'MM_Popup_TermsOfService_OnClickCheckBoxNightPush::bChecked' has a wrong offset!");

// Function MirMobile.MM_Popup_TermsOfService.OnClickCheckBoxPrivacy
// 0x0001 (0x0001 - 0x0000)
struct MM_Popup_TermsOfService_OnClickCheckBoxPrivacy final
{
public:
	bool                                          bChecked;                                          // 0x0000(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(MM_Popup_TermsOfService_OnClickCheckBoxPrivacy) == 0x000001, "Wrong alignment on MM_Popup_TermsOfService_OnClickCheckBoxPrivacy");
static_assert(sizeof(MM_Popup_TermsOfService_OnClickCheckBoxPrivacy) == 0x000001, "Wrong size on MM_Popup_TermsOfService_OnClickCheckBoxPrivacy");
static_assert(offsetof(MM_Popup_TermsOfService_OnClickCheckBoxPrivacy, bChecked) == 0x000000, "Member 'MM_Popup_TermsOfService_OnClickCheckBoxPrivacy::bChecked' has a wrong offset!");

// Function MirMobile.MM_Popup_TermsOfService.OnClickCheckBoxTerms
// 0x0001 (0x0001 - 0x0000)
struct MM_Popup_TermsOfService_OnClickCheckBoxTerms final
{
public:
	bool                                          bChecked;                                          // 0x0000(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(MM_Popup_TermsOfService_OnClickCheckBoxTerms) == 0x000001, "Wrong alignment on MM_Popup_TermsOfService_OnClickCheckBoxTerms");
static_assert(sizeof(MM_Popup_TermsOfService_OnClickCheckBoxTerms) == 0x000001, "Wrong size on MM_Popup_TermsOfService_OnClickCheckBoxTerms");
static_assert(offsetof(MM_Popup_TermsOfService_OnClickCheckBoxTerms, bChecked) == 0x000000, "Member 'MM_Popup_TermsOfService_OnClickCheckBoxTerms::bChecked' has a wrong offset!");

// Function MirMobile.MM_Map_Minimap.OnClickCheckbox_SectorGrade
// 0x0001 (0x0001 - 0x0000)
struct MM_Map_Minimap_OnClickCheckbox_SectorGrade final
{
public:
	bool                                          bChecked;                                          // 0x0000(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(MM_Map_Minimap_OnClickCheckbox_SectorGrade) == 0x000001, "Wrong alignment on MM_Map_Minimap_OnClickCheckbox_SectorGrade");
static_assert(sizeof(MM_Map_Minimap_OnClickCheckbox_SectorGrade) == 0x000001, "Wrong size on MM_Map_Minimap_OnClickCheckbox_SectorGrade");
static_assert(offsetof(MM_Map_Minimap_OnClickCheckbox_SectorGrade, bChecked) == 0x000000, "Member 'MM_Map_Minimap_OnClickCheckbox_SectorGrade::bChecked' has a wrong offset!");

// Function MirMobile.MM_Map_Minimap.OnClickTab
// 0x0008 (0x0008 - 0x0000)
struct MM_Map_Minimap_OnClickTab final
{
public:
	int32                                         ITabIndex;                                         // 0x0000(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bLocked;                                           // 0x0004(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_5[0x3];                                        // 0x0005(0x0003)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(MM_Map_Minimap_OnClickTab) == 0x000004, "Wrong alignment on MM_Map_Minimap_OnClickTab");
static_assert(sizeof(MM_Map_Minimap_OnClickTab) == 0x000008, "Wrong size on MM_Map_Minimap_OnClickTab");
static_assert(offsetof(MM_Map_Minimap_OnClickTab, ITabIndex) == 0x000000, "Member 'MM_Map_Minimap_OnClickTab::ITabIndex' has a wrong offset!");
static_assert(offsetof(MM_Map_Minimap_OnClickTab, bLocked) == 0x000004, "Member 'MM_Map_Minimap_OnClickTab::bLocked' has a wrong offset!");

// Function MirMobile.MM_PopUp_Quest_Obtain.PlayCloseAni
// 0x0004 (0x0004 - 0x0000)
struct MM_PopUp_Quest_Obtain_PlayCloseAni final
{
public:
	float                                         ReturnValue;                                       // 0x0000(0x0004)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(MM_PopUp_Quest_Obtain_PlayCloseAni) == 0x000004, "Wrong alignment on MM_PopUp_Quest_Obtain_PlayCloseAni");
static_assert(sizeof(MM_PopUp_Quest_Obtain_PlayCloseAni) == 0x000004, "Wrong size on MM_PopUp_Quest_Obtain_PlayCloseAni");
static_assert(offsetof(MM_PopUp_Quest_Obtain_PlayCloseAni, ReturnValue) == 0x000000, "Member 'MM_PopUp_Quest_Obtain_PlayCloseAni::ReturnValue' has a wrong offset!");

// Function MirMobile.MM_UserEvent_WebBanner.OnFailDownloadImage
// 0x0008 (0x0008 - 0x0000)
struct MM_UserEvent_WebBanner_OnFailDownloadImage final
{
public:
	class UTexture2DDynamic*                      Texture;                                           // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(MM_UserEvent_WebBanner_OnFailDownloadImage) == 0x000008, "Wrong alignment on MM_UserEvent_WebBanner_OnFailDownloadImage");
static_assert(sizeof(MM_UserEvent_WebBanner_OnFailDownloadImage) == 0x000008, "Wrong size on MM_UserEvent_WebBanner_OnFailDownloadImage");
static_assert(offsetof(MM_UserEvent_WebBanner_OnFailDownloadImage, Texture) == 0x000000, "Member 'MM_UserEvent_WebBanner_OnFailDownloadImage::Texture' has a wrong offset!");

// Function MirMobile.MM_UserEvent_WebBanner.OnSuccessDownloadImage
// 0x0008 (0x0008 - 0x0000)
struct MM_UserEvent_WebBanner_OnSuccessDownloadImage final
{
public:
	class UTexture2DDynamic*                      Texture;                                           // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(MM_UserEvent_WebBanner_OnSuccessDownloadImage) == 0x000008, "Wrong alignment on MM_UserEvent_WebBanner_OnSuccessDownloadImage");
static_assert(sizeof(MM_UserEvent_WebBanner_OnSuccessDownloadImage) == 0x000008, "Wrong size on MM_UserEvent_WebBanner_OnSuccessDownloadImage");
static_assert(offsetof(MM_UserEvent_WebBanner_OnSuccessDownloadImage, Texture) == 0x000000, "Member 'MM_UserEvent_WebBanner_OnSuccessDownloadImage::Texture' has a wrong offset!");

// Function MirMobile.MM_Popup_Restore_Item.OnSelectSlot
// 0x0004 (0x0004 - 0x0000)
struct MM_Popup_Restore_Item_OnSelectSlot final
{
public:
	int32                                         ISlotIndex;                                        // 0x0000(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(MM_Popup_Restore_Item_OnSelectSlot) == 0x000004, "Wrong alignment on MM_Popup_Restore_Item_OnSelectSlot");
static_assert(sizeof(MM_Popup_Restore_Item_OnSelectSlot) == 0x000004, "Wrong size on MM_Popup_Restore_Item_OnSelectSlot");
static_assert(offsetof(MM_Popup_Restore_Item_OnSelectSlot, ISlotIndex) == 0x000000, "Member 'MM_Popup_Restore_Item_OnSelectSlot::ISlotIndex' has a wrong offset!");

// Function MirMobile.MM_Map_Waypoint_List_Slot.OnToggleMapMark
// 0x0001 (0x0001 - 0x0000)
struct MM_Map_Waypoint_List_Slot_OnToggleMapMark final
{
public:
	bool                                          CheckState;                                        // 0x0000(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(MM_Map_Waypoint_List_Slot_OnToggleMapMark) == 0x000001, "Wrong alignment on MM_Map_Waypoint_List_Slot_OnToggleMapMark");
static_assert(sizeof(MM_Map_Waypoint_List_Slot_OnToggleMapMark) == 0x000001, "Wrong size on MM_Map_Waypoint_List_Slot_OnToggleMapMark");
static_assert(offsetof(MM_Map_Waypoint_List_Slot_OnToggleMapMark, CheckState) == 0x000000, "Member 'MM_Map_Waypoint_List_Slot_OnToggleMapMark::CheckState' has a wrong offset!");

// Function MirMobile.MM_UIAction_GameOption.OnAmbientVolume
// 0x0004 (0x0004 - 0x0000)
struct MM_UIAction_GameOption_OnAmbientVolume final
{
public:
	int32                                         Value;                                             // 0x0000(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(MM_UIAction_GameOption_OnAmbientVolume) == 0x000004, "Wrong alignment on MM_UIAction_GameOption_OnAmbientVolume");
static_assert(sizeof(MM_UIAction_GameOption_OnAmbientVolume) == 0x000004, "Wrong size on MM_UIAction_GameOption_OnAmbientVolume");
static_assert(offsetof(MM_UIAction_GameOption_OnAmbientVolume, Value) == 0x000000, "Member 'MM_UIAction_GameOption_OnAmbientVolume::Value' has a wrong offset!");

// Function MirMobile.MM_UIAction_GameOption.OnARejectParty
// 0x0004 (0x0004 - 0x0000)
struct MM_UIAction_GameOption_OnARejectParty final
{
public:
	int32                                         Value;                                             // 0x0000(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(MM_UIAction_GameOption_OnARejectParty) == 0x000004, "Wrong alignment on MM_UIAction_GameOption_OnARejectParty");
static_assert(sizeof(MM_UIAction_GameOption_OnARejectParty) == 0x000004, "Wrong size on MM_UIAction_GameOption_OnARejectParty");
static_assert(offsetof(MM_UIAction_GameOption_OnARejectParty, Value) == 0x000000, "Member 'MM_UIAction_GameOption_OnARejectParty::Value' has a wrong offset!");

// Function MirMobile.MM_UIAction_GameOption.OnARejectSquad
// 0x0004 (0x0004 - 0x0000)
struct MM_UIAction_GameOption_OnARejectSquad final
{
public:
	int32                                         Value;                                             // 0x0000(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(MM_UIAction_GameOption_OnARejectSquad) == 0x000004, "Wrong alignment on MM_UIAction_GameOption_OnARejectSquad");
static_assert(sizeof(MM_UIAction_GameOption_OnARejectSquad) == 0x000004, "Wrong size on MM_UIAction_GameOption_OnARejectSquad");
static_assert(offsetof(MM_UIAction_GameOption_OnARejectSquad, Value) == 0x000000, "Member 'MM_UIAction_GameOption_OnARejectSquad::Value' has a wrong offset!");

// Function MirMobile.MM_UIAction_GameOption.OnAutoBattleFunction
// 0x0004 (0x0004 - 0x0000)
struct MM_UIAction_GameOption_OnAutoBattleFunction final
{
public:
	int32                                         Value;                                             // 0x0000(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(MM_UIAction_GameOption_OnAutoBattleFunction) == 0x000004, "Wrong alignment on MM_UIAction_GameOption_OnAutoBattleFunction");
static_assert(sizeof(MM_UIAction_GameOption_OnAutoBattleFunction) == 0x000004, "Wrong size on MM_UIAction_GameOption_OnAutoBattleFunction");
static_assert(offsetof(MM_UIAction_GameOption_OnAutoBattleFunction, Value) == 0x000000, "Member 'MM_UIAction_GameOption_OnAutoBattleFunction::Value' has a wrong offset!");

// Function MirMobile.MM_UIAction_GameOption.OnAutoBattleRange
// 0x0004 (0x0004 - 0x0000)
struct MM_UIAction_GameOption_OnAutoBattleRange final
{
public:
	int32                                         Value;                                             // 0x0000(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(MM_UIAction_GameOption_OnAutoBattleRange) == 0x000004, "Wrong alignment on MM_UIAction_GameOption_OnAutoBattleRange");
static_assert(sizeof(MM_UIAction_GameOption_OnAutoBattleRange) == 0x000004, "Wrong size on MM_UIAction_GameOption_OnAutoBattleRange");
static_assert(offsetof(MM_UIAction_GameOption_OnAutoBattleRange, Value) == 0x000000, "Member 'MM_UIAction_GameOption_OnAutoBattleRange::Value' has a wrong offset!");

// Function MirMobile.MM_UIAction_GameOption.OnAutoCounterAttack
// 0x0004 (0x0004 - 0x0000)
struct MM_UIAction_GameOption_OnAutoCounterAttack final
{
public:
	int32                                         Value;                                             // 0x0000(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(MM_UIAction_GameOption_OnAutoCounterAttack) == 0x000004, "Wrong alignment on MM_UIAction_GameOption_OnAutoCounterAttack");
static_assert(sizeof(MM_UIAction_GameOption_OnAutoCounterAttack) == 0x000004, "Wrong size on MM_UIAction_GameOption_OnAutoCounterAttack");
static_assert(offsetof(MM_UIAction_GameOption_OnAutoCounterAttack, Value) == 0x000000, "Member 'MM_UIAction_GameOption_OnAutoCounterAttack::Value' has a wrong offset!");

// Function MirMobile.MM_UIAction_GameOption.OnAutoLockOn
// 0x0004 (0x0004 - 0x0000)
struct MM_UIAction_GameOption_OnAutoLockOn final
{
public:
	int32                                         Value;                                             // 0x0000(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(MM_UIAction_GameOption_OnAutoLockOn) == 0x000004, "Wrong alignment on MM_UIAction_GameOption_OnAutoLockOn");
static_assert(sizeof(MM_UIAction_GameOption_OnAutoLockOn) == 0x000004, "Wrong size on MM_UIAction_GameOption_OnAutoLockOn");
static_assert(offsetof(MM_UIAction_GameOption_OnAutoLockOn, Value) == 0x000000, "Member 'MM_UIAction_GameOption_OnAutoLockOn::Value' has a wrong offset!");

// Function MirMobile.MM_UIAction_GameOption.OnAutoPlayUseSkill
// 0x0004 (0x0004 - 0x0000)
struct MM_UIAction_GameOption_OnAutoPlayUseSkill final
{
public:
	int32                                         Value;                                             // 0x0000(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(MM_UIAction_GameOption_OnAutoPlayUseSkill) == 0x000004, "Wrong alignment on MM_UIAction_GameOption_OnAutoPlayUseSkill");
static_assert(sizeof(MM_UIAction_GameOption_OnAutoPlayUseSkill) == 0x000004, "Wrong size on MM_UIAction_GameOption_OnAutoPlayUseSkill");
static_assert(offsetof(MM_UIAction_GameOption_OnAutoPlayUseSkill, Value) == 0x000000, "Member 'MM_UIAction_GameOption_OnAutoPlayUseSkill::Value' has a wrong offset!");

// Function MirMobile.MM_UIAction_GameOption.OnAutoPotionHpPercent
// 0x0004 (0x0004 - 0x0000)
struct MM_UIAction_GameOption_OnAutoPotionHpPercent final
{
public:
	int32                                         Value;                                             // 0x0000(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(MM_UIAction_GameOption_OnAutoPotionHpPercent) == 0x000004, "Wrong alignment on MM_UIAction_GameOption_OnAutoPotionHpPercent");
static_assert(sizeof(MM_UIAction_GameOption_OnAutoPotionHpPercent) == 0x000004, "Wrong size on MM_UIAction_GameOption_OnAutoPotionHpPercent");
static_assert(offsetof(MM_UIAction_GameOption_OnAutoPotionHpPercent, Value) == 0x000000, "Member 'MM_UIAction_GameOption_OnAutoPotionHpPercent::Value' has a wrong offset!");

// Function MirMobile.MM_UIAction_GameOption.OnAutoPotionMpPercent
// 0x0004 (0x0004 - 0x0000)
struct MM_UIAction_GameOption_OnAutoPotionMpPercent final
{
public:
	int32                                         Value;                                             // 0x0000(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(MM_UIAction_GameOption_OnAutoPotionMpPercent) == 0x000004, "Wrong alignment on MM_UIAction_GameOption_OnAutoPotionMpPercent");
static_assert(sizeof(MM_UIAction_GameOption_OnAutoPotionMpPercent) == 0x000004, "Wrong size on MM_UIAction_GameOption_OnAutoPotionMpPercent");
static_assert(offsetof(MM_UIAction_GameOption_OnAutoPotionMpPercent, Value) == 0x000000, "Member 'MM_UIAction_GameOption_OnAutoPotionMpPercent::Value' has a wrong offset!");

// Function MirMobile.MM_UIAction_GameOption.OnAutoReturnOnDeath
// 0x0004 (0x0004 - 0x0000)
struct MM_UIAction_GameOption_OnAutoReturnOnDeath final
{
public:
	int32                                         Value;                                             // 0x0000(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(MM_UIAction_GameOption_OnAutoReturnOnDeath) == 0x000004, "Wrong alignment on MM_UIAction_GameOption_OnAutoReturnOnDeath");
static_assert(sizeof(MM_UIAction_GameOption_OnAutoReturnOnDeath) == 0x000004, "Wrong size on MM_UIAction_GameOption_OnAutoReturnOnDeath");
static_assert(offsetof(MM_UIAction_GameOption_OnAutoReturnOnDeath, Value) == 0x000000, "Member 'MM_UIAction_GameOption_OnAutoReturnOnDeath::Value' has a wrong offset!");

// Function MirMobile.MM_UIAction_GameOption.OnAutoSkill
// 0x0004 (0x0004 - 0x0000)
struct MM_UIAction_GameOption_OnAutoSkill final
{
public:
	int32                                         Value;                                             // 0x0000(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(MM_UIAction_GameOption_OnAutoSkill) == 0x000004, "Wrong alignment on MM_UIAction_GameOption_OnAutoSkill");
static_assert(sizeof(MM_UIAction_GameOption_OnAutoSkill) == 0x000004, "Wrong size on MM_UIAction_GameOption_OnAutoSkill");
static_assert(offsetof(MM_UIAction_GameOption_OnAutoSkill, Value) == 0x000000, "Member 'MM_UIAction_GameOption_OnAutoSkill::Value' has a wrong offset!");

// Function MirMobile.MM_UIAction_GameOption.OnBGMVolume
// 0x0004 (0x0004 - 0x0000)
struct MM_UIAction_GameOption_OnBGMVolume final
{
public:
	int32                                         Value;                                             // 0x0000(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(MM_UIAction_GameOption_OnBGMVolume) == 0x000004, "Wrong alignment on MM_UIAction_GameOption_OnBGMVolume");
static_assert(sizeof(MM_UIAction_GameOption_OnBGMVolume) == 0x000004, "Wrong size on MM_UIAction_GameOption_OnBGMVolume");
static_assert(offsetof(MM_UIAction_GameOption_OnBGMVolume, Value) == 0x000000, "Member 'MM_UIAction_GameOption_OnBGMVolume::Value' has a wrong offset!");

// Function MirMobile.MM_UIAction_GameOption.OnBuddyLoginNotice
// 0x0004 (0x0004 - 0x0000)
struct MM_UIAction_GameOption_OnBuddyLoginNotice final
{
public:
	int32                                         Value;                                             // 0x0000(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(MM_UIAction_GameOption_OnBuddyLoginNotice) == 0x000004, "Wrong alignment on MM_UIAction_GameOption_OnBuddyLoginNotice");
static_assert(sizeof(MM_UIAction_GameOption_OnBuddyLoginNotice) == 0x000004, "Wrong size on MM_UIAction_GameOption_OnBuddyLoginNotice");
static_assert(offsetof(MM_UIAction_GameOption_OnBuddyLoginNotice, Value) == 0x000000, "Member 'MM_UIAction_GameOption_OnBuddyLoginNotice::Value' has a wrong offset!");

// Function MirMobile.MM_UIAction_GameOption.OnBuddyRequestAutoReject
// 0x0004 (0x0004 - 0x0000)
struct MM_UIAction_GameOption_OnBuddyRequestAutoReject final
{
public:
	int32                                         Value;                                             // 0x0000(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(MM_UIAction_GameOption_OnBuddyRequestAutoReject) == 0x000004, "Wrong alignment on MM_UIAction_GameOption_OnBuddyRequestAutoReject");
static_assert(sizeof(MM_UIAction_GameOption_OnBuddyRequestAutoReject) == 0x000004, "Wrong size on MM_UIAction_GameOption_OnBuddyRequestAutoReject");
static_assert(offsetof(MM_UIAction_GameOption_OnBuddyRequestAutoReject, Value) == 0x000000, "Member 'MM_UIAction_GameOption_OnBuddyRequestAutoReject::Value' has a wrong offset!");

// Function MirMobile.MM_UIAction_GameOption.OnCameraMode
// 0x0004 (0x0004 - 0x0000)
struct MM_UIAction_GameOption_OnCameraMode final
{
public:
	int32                                         Value;                                             // 0x0000(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(MM_UIAction_GameOption_OnCameraMode) == 0x000004, "Wrong alignment on MM_UIAction_GameOption_OnCameraMode");
static_assert(sizeof(MM_UIAction_GameOption_OnCameraMode) == 0x000004, "Wrong size on MM_UIAction_GameOption_OnCameraMode");
static_assert(offsetof(MM_UIAction_GameOption_OnCameraMode, Value) == 0x000000, "Member 'MM_UIAction_GameOption_OnCameraMode::Value' has a wrong offset!");

// Function MirMobile.MM_UIAction_GameOption.OnCameraShakeScale
// 0x0004 (0x0004 - 0x0000)
struct MM_UIAction_GameOption_OnCameraShakeScale final
{
public:
	int32                                         Value;                                             // 0x0000(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(MM_UIAction_GameOption_OnCameraShakeScale) == 0x000004, "Wrong alignment on MM_UIAction_GameOption_OnCameraShakeScale");
static_assert(sizeof(MM_UIAction_GameOption_OnCameraShakeScale) == 0x000004, "Wrong size on MM_UIAction_GameOption_OnCameraShakeScale");
static_assert(offsetof(MM_UIAction_GameOption_OnCameraShakeScale, Value) == 0x000000, "Member 'MM_UIAction_GameOption_OnCameraShakeScale::Value' has a wrong offset!");

// Function MirMobile.MM_UIAction_GameOption.OnChattingRenderOpacity
// 0x0004 (0x0004 - 0x0000)
struct MM_UIAction_GameOption_OnChattingRenderOpacity final
{
public:
	int32                                         Value;                                             // 0x0000(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(MM_UIAction_GameOption_OnChattingRenderOpacity) == 0x000004, "Wrong alignment on MM_UIAction_GameOption_OnChattingRenderOpacity");
static_assert(sizeof(MM_UIAction_GameOption_OnChattingRenderOpacity) == 0x000004, "Wrong size on MM_UIAction_GameOption_OnChattingRenderOpacity");
static_assert(offsetof(MM_UIAction_GameOption_OnChattingRenderOpacity, Value) == 0x000000, "Member 'MM_UIAction_GameOption_OnChattingRenderOpacity::Value' has a wrong offset!");

// Function MirMobile.MM_UIAction_GameOption.OnComplateQuestSort
// 0x0004 (0x0004 - 0x0000)
struct MM_UIAction_GameOption_OnComplateQuestSort final
{
public:
	int32                                         Value;                                             // 0x0000(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(MM_UIAction_GameOption_OnComplateQuestSort) == 0x000004, "Wrong alignment on MM_UIAction_GameOption_OnComplateQuestSort");
static_assert(sizeof(MM_UIAction_GameOption_OnComplateQuestSort) == 0x000004, "Wrong size on MM_UIAction_GameOption_OnComplateQuestSort");
static_assert(offsetof(MM_UIAction_GameOption_OnComplateQuestSort, Value) == 0x000000, "Member 'MM_UIAction_GameOption_OnComplateQuestSort::Value' has a wrong offset!");

// Function MirMobile.MM_UIAction_GameOption.OnCostumeTitleOption
// 0x0004 (0x0004 - 0x0000)
struct MM_UIAction_GameOption_OnCostumeTitleOption final
{
public:
	int32                                         Value;                                             // 0x0000(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(MM_UIAction_GameOption_OnCostumeTitleOption) == 0x000004, "Wrong alignment on MM_UIAction_GameOption_OnCostumeTitleOption");
static_assert(sizeof(MM_UIAction_GameOption_OnCostumeTitleOption) == 0x000004, "Wrong size on MM_UIAction_GameOption_OnCostumeTitleOption");
static_assert(offsetof(MM_UIAction_GameOption_OnCostumeTitleOption, Value) == 0x000000, "Member 'MM_UIAction_GameOption_OnCostumeTitleOption::Value' has a wrong offset!");

// Function MirMobile.MM_UIAction_GameOption.OnEffectVisual
// 0x0004 (0x0004 - 0x0000)
struct MM_UIAction_GameOption_OnEffectVisual final
{
public:
	int32                                         Value;                                             // 0x0000(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(MM_UIAction_GameOption_OnEffectVisual) == 0x000004, "Wrong alignment on MM_UIAction_GameOption_OnEffectVisual");
static_assert(sizeof(MM_UIAction_GameOption_OnEffectVisual) == 0x000004, "Wrong size on MM_UIAction_GameOption_OnEffectVisual");
static_assert(offsetof(MM_UIAction_GameOption_OnEffectVisual, Value) == 0x000000, "Member 'MM_UIAction_GameOption_OnEffectVisual::Value' has a wrong offset!");

// Function MirMobile.MM_UIAction_GameOption.OnFrameSpeed
// 0x0004 (0x0004 - 0x0000)
struct MM_UIAction_GameOption_OnFrameSpeed final
{
public:
	int32                                         Value;                                             // 0x0000(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(MM_UIAction_GameOption_OnFrameSpeed) == 0x000004, "Wrong alignment on MM_UIAction_GameOption_OnFrameSpeed");
static_assert(sizeof(MM_UIAction_GameOption_OnFrameSpeed) == 0x000004, "Wrong size on MM_UIAction_GameOption_OnFrameSpeed");
static_assert(offsetof(MM_UIAction_GameOption_OnFrameSpeed, Value) == 0x000000, "Member 'MM_UIAction_GameOption_OnFrameSpeed::Value' has a wrong offset!");

// Function MirMobile.MM_UIAction_GameOption.OnGuestPWChangeComplete
// 0x0018 (0x0018 - 0x0000)
struct MM_UIAction_GameOption_OnGuestPWChangeComplete final
{
public:
	bool                                          Success;                                           // 0x0000(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1[0x7];                                        // 0x0001(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	class FString                                 Message;                                           // 0x0008(0x0010)(Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(MM_UIAction_GameOption_OnGuestPWChangeComplete) == 0x000008, "Wrong alignment on MM_UIAction_GameOption_OnGuestPWChangeComplete");
static_assert(sizeof(MM_UIAction_GameOption_OnGuestPWChangeComplete) == 0x000018, "Wrong size on MM_UIAction_GameOption_OnGuestPWChangeComplete");
static_assert(offsetof(MM_UIAction_GameOption_OnGuestPWChangeComplete, Success) == 0x000000, "Member 'MM_UIAction_GameOption_OnGuestPWChangeComplete::Success' has a wrong offset!");
static_assert(offsetof(MM_UIAction_GameOption_OnGuestPWChangeComplete, Message) == 0x000008, "Member 'MM_UIAction_GameOption_OnGuestPWChangeComplete::Message' has a wrong offset!");

// Function MirMobile.MM_UIAction_GameOption.OnHUDAutoResizing
// 0x0004 (0x0004 - 0x0000)
struct MM_UIAction_GameOption_OnHUDAutoResizing final
{
public:
	int32                                         Value;                                             // 0x0000(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(MM_UIAction_GameOption_OnHUDAutoResizing) == 0x000004, "Wrong alignment on MM_UIAction_GameOption_OnHUDAutoResizing");
static_assert(sizeof(MM_UIAction_GameOption_OnHUDAutoResizing) == 0x000004, "Wrong size on MM_UIAction_GameOption_OnHUDAutoResizing");
static_assert(offsetof(MM_UIAction_GameOption_OnHUDAutoResizing, Value) == 0x000000, "Member 'MM_UIAction_GameOption_OnHUDAutoResizing::Value' has a wrong offset!");

// Function MirMobile.MM_UIAction_GameOption.OnLeaderCenteredBattle
// 0x0004 (0x0004 - 0x0000)
struct MM_UIAction_GameOption_OnLeaderCenteredBattle final
{
public:
	int32                                         Value;                                             // 0x0000(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(MM_UIAction_GameOption_OnLeaderCenteredBattle) == 0x000004, "Wrong alignment on MM_UIAction_GameOption_OnLeaderCenteredBattle");
static_assert(sizeof(MM_UIAction_GameOption_OnLeaderCenteredBattle) == 0x000004, "Wrong size on MM_UIAction_GameOption_OnLeaderCenteredBattle");
static_assert(offsetof(MM_UIAction_GameOption_OnLeaderCenteredBattle, Value) == 0x000000, "Member 'MM_UIAction_GameOption_OnLeaderCenteredBattle::Value' has a wrong offset!");

// Function MirMobile.MM_UIAction_GameOption.OnLinkIDPComplete
// 0x0018 (0x0018 - 0x0000)
struct MM_UIAction_GameOption_OnLinkIDPComplete final
{
public:
	bool                                          Success;                                           // 0x0000(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1[0x7];                                        // 0x0001(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	class FString                                 Message;                                           // 0x0008(0x0010)(Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(MM_UIAction_GameOption_OnLinkIDPComplete) == 0x000008, "Wrong alignment on MM_UIAction_GameOption_OnLinkIDPComplete");
static_assert(sizeof(MM_UIAction_GameOption_OnLinkIDPComplete) == 0x000018, "Wrong size on MM_UIAction_GameOption_OnLinkIDPComplete");
static_assert(offsetof(MM_UIAction_GameOption_OnLinkIDPComplete, Success) == 0x000000, "Member 'MM_UIAction_GameOption_OnLinkIDPComplete::Success' has a wrong offset!");
static_assert(offsetof(MM_UIAction_GameOption_OnLinkIDPComplete, Message) == 0x000008, "Member 'MM_UIAction_GameOption_OnLinkIDPComplete::Message' has a wrong offset!");

// Function MirMobile.MM_UIAction_GameOption.OnMasterVolume
// 0x0004 (0x0004 - 0x0000)
struct MM_UIAction_GameOption_OnMasterVolume final
{
public:
	int32                                         Value;                                             // 0x0000(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(MM_UIAction_GameOption_OnMasterVolume) == 0x000004, "Wrong alignment on MM_UIAction_GameOption_OnMasterVolume");
static_assert(sizeof(MM_UIAction_GameOption_OnMasterVolume) == 0x000004, "Wrong size on MM_UIAction_GameOption_OnMasterVolume");
static_assert(offsetof(MM_UIAction_GameOption_OnMasterVolume, Value) == 0x000000, "Member 'MM_UIAction_GameOption_OnMasterVolume::Value' has a wrong offset!");

// Function MirMobile.MM_UIAction_GameOption.OnMonNameOption
// 0x0004 (0x0004 - 0x0000)
struct MM_UIAction_GameOption_OnMonNameOption final
{
public:
	int32                                         Value;                                             // 0x0000(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(MM_UIAction_GameOption_OnMonNameOption) == 0x000004, "Wrong alignment on MM_UIAction_GameOption_OnMonNameOption");
static_assert(sizeof(MM_UIAction_GameOption_OnMonNameOption) == 0x000004, "Wrong size on MM_UIAction_GameOption_OnMonNameOption");
static_assert(offsetof(MM_UIAction_GameOption_OnMonNameOption, Value) == 0x000000, "Member 'MM_UIAction_GameOption_OnMonNameOption::Value' has a wrong offset!");

// Function MirMobile.MM_UIAction_GameOption.OnMyAllianceGuildMark
// 0x0004 (0x0004 - 0x0000)
struct MM_UIAction_GameOption_OnMyAllianceGuildMark final
{
public:
	int32                                         Value;                                             // 0x0000(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(MM_UIAction_GameOption_OnMyAllianceGuildMark) == 0x000004, "Wrong alignment on MM_UIAction_GameOption_OnMyAllianceGuildMark");
static_assert(sizeof(MM_UIAction_GameOption_OnMyAllianceGuildMark) == 0x000004, "Wrong size on MM_UIAction_GameOption_OnMyAllianceGuildMark");
static_assert(offsetof(MM_UIAction_GameOption_OnMyAllianceGuildMark, Value) == 0x000000, "Member 'MM_UIAction_GameOption_OnMyAllianceGuildMark::Value' has a wrong offset!");

// Function MirMobile.MM_UIAction_GameOption.OnMyGuildMark
// 0x0004 (0x0004 - 0x0000)
struct MM_UIAction_GameOption_OnMyGuildMark final
{
public:
	int32                                         Value;                                             // 0x0000(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(MM_UIAction_GameOption_OnMyGuildMark) == 0x000004, "Wrong alignment on MM_UIAction_GameOption_OnMyGuildMark");
static_assert(sizeof(MM_UIAction_GameOption_OnMyGuildMark) == 0x000004, "Wrong size on MM_UIAction_GameOption_OnMyGuildMark");
static_assert(offsetof(MM_UIAction_GameOption_OnMyGuildMark, Value) == 0x000000, "Member 'MM_UIAction_GameOption_OnMyGuildMark::Value' has a wrong offset!");

// Function MirMobile.MM_UIAction_GameOption.OnMyNameOption
// 0x0004 (0x0004 - 0x0000)
struct MM_UIAction_GameOption_OnMyNameOption final
{
public:
	int32                                         Value;                                             // 0x0000(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(MM_UIAction_GameOption_OnMyNameOption) == 0x000004, "Wrong alignment on MM_UIAction_GameOption_OnMyNameOption");
static_assert(sizeof(MM_UIAction_GameOption_OnMyNameOption) == 0x000004, "Wrong size on MM_UIAction_GameOption_OnMyNameOption");
static_assert(offsetof(MM_UIAction_GameOption_OnMyNameOption, Value) == 0x000000, "Member 'MM_UIAction_GameOption_OnMyNameOption::Value' has a wrong offset!");

// Function MirMobile.MM_UIAction_GameOption.OnOneStoreLogoutComplete
// 0x0018 (0x0018 - 0x0000)
struct MM_UIAction_GameOption_OnOneStoreLogoutComplete final
{
public:
	bool                                          Success;                                           // 0x0000(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1[0x7];                                        // 0x0001(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	class FString                                 Message;                                           // 0x0008(0x0010)(Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(MM_UIAction_GameOption_OnOneStoreLogoutComplete) == 0x000008, "Wrong alignment on MM_UIAction_GameOption_OnOneStoreLogoutComplete");
static_assert(sizeof(MM_UIAction_GameOption_OnOneStoreLogoutComplete) == 0x000018, "Wrong size on MM_UIAction_GameOption_OnOneStoreLogoutComplete");
static_assert(offsetof(MM_UIAction_GameOption_OnOneStoreLogoutComplete, Success) == 0x000000, "Member 'MM_UIAction_GameOption_OnOneStoreLogoutComplete::Success' has a wrong offset!");
static_assert(offsetof(MM_UIAction_GameOption_OnOneStoreLogoutComplete, Message) == 0x000008, "Member 'MM_UIAction_GameOption_OnOneStoreLogoutComplete::Message' has a wrong offset!");

// Function MirMobile.MM_UIAction_GameOption.OnOtherGuildMark
// 0x0004 (0x0004 - 0x0000)
struct MM_UIAction_GameOption_OnOtherGuildMark final
{
public:
	int32                                         Value;                                             // 0x0000(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(MM_UIAction_GameOption_OnOtherGuildMark) == 0x000004, "Wrong alignment on MM_UIAction_GameOption_OnOtherGuildMark");
static_assert(sizeof(MM_UIAction_GameOption_OnOtherGuildMark) == 0x000004, "Wrong size on MM_UIAction_GameOption_OnOtherGuildMark");
static_assert(offsetof(MM_UIAction_GameOption_OnOtherGuildMark, Value) == 0x000000, "Member 'MM_UIAction_GameOption_OnOtherGuildMark::Value' has a wrong offset!");

// Function MirMobile.MM_UIAction_GameOption.OnPartyBattleTargetShare
// 0x0004 (0x0004 - 0x0000)
struct MM_UIAction_GameOption_OnPartyBattleTargetShare final
{
public:
	int32                                         Value;                                             // 0x0000(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(MM_UIAction_GameOption_OnPartyBattleTargetShare) == 0x000004, "Wrong alignment on MM_UIAction_GameOption_OnPartyBattleTargetShare");
static_assert(sizeof(MM_UIAction_GameOption_OnPartyBattleTargetShare) == 0x000004, "Wrong size on MM_UIAction_GameOption_OnPartyBattleTargetShare");
static_assert(offsetof(MM_UIAction_GameOption_OnPartyBattleTargetShare, Value) == 0x000000, "Member 'MM_UIAction_GameOption_OnPartyBattleTargetShare::Value' has a wrong offset!");

// Function MirMobile.MM_UIAction_GameOption.OnPartyUIAutoVisible
// 0x0004 (0x0004 - 0x0000)
struct MM_UIAction_GameOption_OnPartyUIAutoVisible final
{
public:
	int32                                         Value;                                             // 0x0000(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(MM_UIAction_GameOption_OnPartyUIAutoVisible) == 0x000004, "Wrong alignment on MM_UIAction_GameOption_OnPartyUIAutoVisible");
static_assert(sizeof(MM_UIAction_GameOption_OnPartyUIAutoVisible) == 0x000004, "Wrong size on MM_UIAction_GameOption_OnPartyUIAutoVisible");
static_assert(offsetof(MM_UIAction_GameOption_OnPartyUIAutoVisible, Value) == 0x000000, "Member 'MM_UIAction_GameOption_OnPartyUIAutoVisible::Value' has a wrong offset!");

// Function MirMobile.MM_UIAction_GameOption.OnPet
// 0x0004 (0x0004 - 0x0000)
struct MM_UIAction_GameOption_OnPet final
{
public:
	int32                                         Value;                                             // 0x0000(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(MM_UIAction_GameOption_OnPet) == 0x000004, "Wrong alignment on MM_UIAction_GameOption_OnPet");
static_assert(sizeof(MM_UIAction_GameOption_OnPet) == 0x000004, "Wrong size on MM_UIAction_GameOption_OnPet");
static_assert(offsetof(MM_UIAction_GameOption_OnPet, Value) == 0x000000, "Member 'MM_UIAction_GameOption_OnPet::Value' has a wrong offset!");

// Function MirMobile.MM_UIAction_GameOption.OnQuickSlotAutoEquip
// 0x0004 (0x0004 - 0x0000)
struct MM_UIAction_GameOption_OnQuickSlotAutoEquip final
{
public:
	int32                                         Value;                                             // 0x0000(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(MM_UIAction_GameOption_OnQuickSlotAutoEquip) == 0x000004, "Wrong alignment on MM_UIAction_GameOption_OnQuickSlotAutoEquip");
static_assert(sizeof(MM_UIAction_GameOption_OnQuickSlotAutoEquip) == 0x000004, "Wrong size on MM_UIAction_GameOption_OnQuickSlotAutoEquip");
static_assert(offsetof(MM_UIAction_GameOption_OnQuickSlotAutoEquip, Value) == 0x000000, "Member 'MM_UIAction_GameOption_OnQuickSlotAutoEquip::Value' has a wrong offset!");

// Function MirMobile.MM_UIAction_GameOption.OnQuickSlotAutoPotion_0
// 0x0004 (0x0004 - 0x0000)
struct MM_UIAction_GameOption_OnQuickSlotAutoPotion_0 final
{
public:
	int32                                         Value;                                             // 0x0000(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(MM_UIAction_GameOption_OnQuickSlotAutoPotion_0) == 0x000004, "Wrong alignment on MM_UIAction_GameOption_OnQuickSlotAutoPotion_0");
static_assert(sizeof(MM_UIAction_GameOption_OnQuickSlotAutoPotion_0) == 0x000004, "Wrong size on MM_UIAction_GameOption_OnQuickSlotAutoPotion_0");
static_assert(offsetof(MM_UIAction_GameOption_OnQuickSlotAutoPotion_0, Value) == 0x000000, "Member 'MM_UIAction_GameOption_OnQuickSlotAutoPotion_0::Value' has a wrong offset!");

// Function MirMobile.MM_UIAction_GameOption.OnQuickSlotAutoPotion_1
// 0x0004 (0x0004 - 0x0000)
struct MM_UIAction_GameOption_OnQuickSlotAutoPotion_1 final
{
public:
	int32                                         Value;                                             // 0x0000(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(MM_UIAction_GameOption_OnQuickSlotAutoPotion_1) == 0x000004, "Wrong alignment on MM_UIAction_GameOption_OnQuickSlotAutoPotion_1");
static_assert(sizeof(MM_UIAction_GameOption_OnQuickSlotAutoPotion_1) == 0x000004, "Wrong size on MM_UIAction_GameOption_OnQuickSlotAutoPotion_1");
static_assert(offsetof(MM_UIAction_GameOption_OnQuickSlotAutoPotion_1, Value) == 0x000000, "Member 'MM_UIAction_GameOption_OnQuickSlotAutoPotion_1::Value' has a wrong offset!");

// Function MirMobile.MM_UIAction_GameOption.OnQuickSlotAutoPotion_2
// 0x0004 (0x0004 - 0x0000)
struct MM_UIAction_GameOption_OnQuickSlotAutoPotion_2 final
{
public:
	int32                                         Value;                                             // 0x0000(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(MM_UIAction_GameOption_OnQuickSlotAutoPotion_2) == 0x000004, "Wrong alignment on MM_UIAction_GameOption_OnQuickSlotAutoPotion_2");
static_assert(sizeof(MM_UIAction_GameOption_OnQuickSlotAutoPotion_2) == 0x000004, "Wrong size on MM_UIAction_GameOption_OnQuickSlotAutoPotion_2");
static_assert(offsetof(MM_UIAction_GameOption_OnQuickSlotAutoPotion_2, Value) == 0x000000, "Member 'MM_UIAction_GameOption_OnQuickSlotAutoPotion_2::Value' has a wrong offset!");

// Function MirMobile.MM_UIAction_GameOption.OnQuickSlotInvenOrder
// 0x0004 (0x0004 - 0x0000)
struct MM_UIAction_GameOption_OnQuickSlotInvenOrder final
{
public:
	int32                                         Value;                                             // 0x0000(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(MM_UIAction_GameOption_OnQuickSlotInvenOrder) == 0x000004, "Wrong alignment on MM_UIAction_GameOption_OnQuickSlotInvenOrder");
static_assert(sizeof(MM_UIAction_GameOption_OnQuickSlotInvenOrder) == 0x000004, "Wrong size on MM_UIAction_GameOption_OnQuickSlotInvenOrder");
static_assert(offsetof(MM_UIAction_GameOption_OnQuickSlotInvenOrder, Value) == 0x000000, "Member 'MM_UIAction_GameOption_OnQuickSlotInvenOrder::Value' has a wrong offset!");

// Function MirMobile.MM_UIAction_GameOption.OnQuickSlotInvenSort
// 0x0004 (0x0004 - 0x0000)
struct MM_UIAction_GameOption_OnQuickSlotInvenSort final
{
public:
	int32                                         Value;                                             // 0x0000(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(MM_UIAction_GameOption_OnQuickSlotInvenSort) == 0x000004, "Wrong alignment on MM_UIAction_GameOption_OnQuickSlotInvenSort");
static_assert(sizeof(MM_UIAction_GameOption_OnQuickSlotInvenSort) == 0x000004, "Wrong size on MM_UIAction_GameOption_OnQuickSlotInvenSort");
static_assert(offsetof(MM_UIAction_GameOption_OnQuickSlotInvenSort, Value) == 0x000000, "Member 'MM_UIAction_GameOption_OnQuickSlotInvenSort::Value' has a wrong offset!");

// Function MirMobile.MM_UIAction_GameOption.OnResolution
// 0x0004 (0x0004 - 0x0000)
struct MM_UIAction_GameOption_OnResolution final
{
public:
	int32                                         Value;                                             // 0x0000(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(MM_UIAction_GameOption_OnResolution) == 0x000004, "Wrong alignment on MM_UIAction_GameOption_OnResolution");
static_assert(sizeof(MM_UIAction_GameOption_OnResolution) == 0x000004, "Wrong size on MM_UIAction_GameOption_OnResolution");
static_assert(offsetof(MM_UIAction_GameOption_OnResolution, Value) == 0x000000, "Member 'MM_UIAction_GameOption_OnResolution::Value' has a wrong offset!");

// Function MirMobile.MM_UIAction_GameOption.OnScreenEffect
// 0x0004 (0x0004 - 0x0000)
struct MM_UIAction_GameOption_OnScreenEffect final
{
public:
	int32                                         Value;                                             // 0x0000(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(MM_UIAction_GameOption_OnScreenEffect) == 0x000004, "Wrong alignment on MM_UIAction_GameOption_OnScreenEffect");
static_assert(sizeof(MM_UIAction_GameOption_OnScreenEffect) == 0x000004, "Wrong size on MM_UIAction_GameOption_OnScreenEffect");
static_assert(offsetof(MM_UIAction_GameOption_OnScreenEffect, Value) == 0x000000, "Member 'MM_UIAction_GameOption_OnScreenEffect::Value' has a wrong offset!");

// Function MirMobile.MM_UIAction_GameOption.OnSFXVolume
// 0x0004 (0x0004 - 0x0000)
struct MM_UIAction_GameOption_OnSFXVolume final
{
public:
	int32                                         Value;                                             // 0x0000(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(MM_UIAction_GameOption_OnSFXVolume) == 0x000004, "Wrong alignment on MM_UIAction_GameOption_OnSFXVolume");
static_assert(sizeof(MM_UIAction_GameOption_OnSFXVolume) == 0x000004, "Wrong size on MM_UIAction_GameOption_OnSFXVolume");
static_assert(offsetof(MM_UIAction_GameOption_OnSFXVolume, Value) == 0x000000, "Member 'MM_UIAction_GameOption_OnSFXVolume::Value' has a wrong offset!");

// Function MirMobile.MM_UIAction_GameOption.OnShadow
// 0x0004 (0x0004 - 0x0000)
struct MM_UIAction_GameOption_OnShadow final
{
public:
	int32                                         Value;                                             // 0x0000(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(MM_UIAction_GameOption_OnShadow) == 0x000004, "Wrong alignment on MM_UIAction_GameOption_OnShadow");
static_assert(sizeof(MM_UIAction_GameOption_OnShadow) == 0x000004, "Wrong size on MM_UIAction_GameOption_OnShadow");
static_assert(offsetof(MM_UIAction_GameOption_OnShadow, Value) == 0x000000, "Member 'MM_UIAction_GameOption_OnShadow::Value' has a wrong offset!");

// Function MirMobile.MM_UIAction_GameOption.OnSimple
// 0x0004 (0x0004 - 0x0000)
struct MM_UIAction_GameOption_OnSimple final
{
public:
	int32                                         Value;                                             // 0x0000(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(MM_UIAction_GameOption_OnSimple) == 0x000004, "Wrong alignment on MM_UIAction_GameOption_OnSimple");
static_assert(sizeof(MM_UIAction_GameOption_OnSimple) == 0x000004, "Wrong size on MM_UIAction_GameOption_OnSimple");
static_assert(offsetof(MM_UIAction_GameOption_OnSimple, Value) == 0x000000, "Member 'MM_UIAction_GameOption_OnSimple::Value' has a wrong offset!");

// Function MirMobile.MM_UIAction_GameOption.OnSkillEffect
// 0x0004 (0x0004 - 0x0000)
struct MM_UIAction_GameOption_OnSkillEffect final
{
public:
	int32                                         Value;                                             // 0x0000(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(MM_UIAction_GameOption_OnSkillEffect) == 0x000004, "Wrong alignment on MM_UIAction_GameOption_OnSkillEffect");
static_assert(sizeof(MM_UIAction_GameOption_OnSkillEffect) == 0x000004, "Wrong size on MM_UIAction_GameOption_OnSkillEffect");
static_assert(offsetof(MM_UIAction_GameOption_OnSkillEffect, Value) == 0x000000, "Member 'MM_UIAction_GameOption_OnSkillEffect::Value' has a wrong offset!");

// Function MirMobile.MM_UIAction_GameOption.OnSleepModeStartTime
// 0x0004 (0x0004 - 0x0000)
struct MM_UIAction_GameOption_OnSleepModeStartTime final
{
public:
	int32                                         Value;                                             // 0x0000(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(MM_UIAction_GameOption_OnSleepModeStartTime) == 0x000004, "Wrong alignment on MM_UIAction_GameOption_OnSleepModeStartTime");
static_assert(sizeof(MM_UIAction_GameOption_OnSleepModeStartTime) == 0x000004, "Wrong size on MM_UIAction_GameOption_OnSleepModeStartTime");
static_assert(offsetof(MM_UIAction_GameOption_OnSleepModeStartTime, Value) == 0x000000, "Member 'MM_UIAction_GameOption_OnSleepModeStartTime::Value' has a wrong offset!");

// Function MirMobile.MM_UIAction_GameOption.OnSubWeaponDisable
// 0x0004 (0x0004 - 0x0000)
struct MM_UIAction_GameOption_OnSubWeaponDisable final
{
public:
	int32                                         Value;                                             // 0x0000(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(MM_UIAction_GameOption_OnSubWeaponDisable) == 0x000004, "Wrong alignment on MM_UIAction_GameOption_OnSubWeaponDisable");
static_assert(sizeof(MM_UIAction_GameOption_OnSubWeaponDisable) == 0x000004, "Wrong size on MM_UIAction_GameOption_OnSubWeaponDisable");
static_assert(offsetof(MM_UIAction_GameOption_OnSubWeaponDisable, Value) == 0x000000, "Member 'MM_UIAction_GameOption_OnSubWeaponDisable::Value' has a wrong offset!");

// Function MirMobile.MM_UIAction_GameOption.OnTexture
// 0x0004 (0x0004 - 0x0000)
struct MM_UIAction_GameOption_OnTexture final
{
public:
	int32                                         Value;                                             // 0x0000(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(MM_UIAction_GameOption_OnTexture) == 0x000004, "Wrong alignment on MM_UIAction_GameOption_OnTexture");
static_assert(sizeof(MM_UIAction_GameOption_OnTexture) == 0x000004, "Wrong size on MM_UIAction_GameOption_OnTexture");
static_assert(offsetof(MM_UIAction_GameOption_OnTexture, Value) == 0x000000, "Member 'MM_UIAction_GameOption_OnTexture::Value' has a wrong offset!");

// Function MirMobile.MM_UIAction_GameOption.OnUnSleepModeWhenAttacked
// 0x0004 (0x0004 - 0x0000)
struct MM_UIAction_GameOption_OnUnSleepModeWhenAttacked final
{
public:
	int32                                         Value;                                             // 0x0000(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(MM_UIAction_GameOption_OnUnSleepModeWhenAttacked) == 0x000004, "Wrong alignment on MM_UIAction_GameOption_OnUnSleepModeWhenAttacked");
static_assert(sizeof(MM_UIAction_GameOption_OnUnSleepModeWhenAttacked) == 0x000004, "Wrong size on MM_UIAction_GameOption_OnUnSleepModeWhenAttacked");
static_assert(offsetof(MM_UIAction_GameOption_OnUnSleepModeWhenAttacked, Value) == 0x000000, "Member 'MM_UIAction_GameOption_OnUnSleepModeWhenAttacked::Value' has a wrong offset!");

// Function MirMobile.MM_UIAction_GameOption.OnUserNameOption
// 0x0004 (0x0004 - 0x0000)
struct MM_UIAction_GameOption_OnUserNameOption final
{
public:
	int32                                         Value;                                             // 0x0000(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(MM_UIAction_GameOption_OnUserNameOption) == 0x000004, "Wrong alignment on MM_UIAction_GameOption_OnUserNameOption");
static_assert(sizeof(MM_UIAction_GameOption_OnUserNameOption) == 0x000004, "Wrong size on MM_UIAction_GameOption_OnUserNameOption");
static_assert(offsetof(MM_UIAction_GameOption_OnUserNameOption, Value) == 0x000000, "Member 'MM_UIAction_GameOption_OnUserNameOption::Value' has a wrong offset!");

// Function MirMobile.MM_UIAction_GameOption.OnVisual
// 0x0004 (0x0004 - 0x0000)
struct MM_UIAction_GameOption_OnVisual final
{
public:
	int32                                         Value;                                             // 0x0000(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(MM_UIAction_GameOption_OnVisual) == 0x000004, "Wrong alignment on MM_UIAction_GameOption_OnVisual");
static_assert(sizeof(MM_UIAction_GameOption_OnVisual) == 0x000004, "Wrong size on MM_UIAction_GameOption_OnVisual");
static_assert(offsetof(MM_UIAction_GameOption_OnVisual, Value) == 0x000000, "Member 'MM_UIAction_GameOption_OnVisual::Value' has a wrong offset!");

// Function MirMobile.MM_UIAction_GameOption.OnVoiceVolume
// 0x0004 (0x0004 - 0x0000)
struct MM_UIAction_GameOption_OnVoiceVolume final
{
public:
	int32                                         Value;                                             // 0x0000(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(MM_UIAction_GameOption_OnVoiceVolume) == 0x000004, "Wrong alignment on MM_UIAction_GameOption_OnVoiceVolume");
static_assert(sizeof(MM_UIAction_GameOption_OnVoiceVolume) == 0x000004, "Wrong size on MM_UIAction_GameOption_OnVoiceVolume");
static_assert(offsetof(MM_UIAction_GameOption_OnVoiceVolume, Value) == 0x000000, "Member 'MM_UIAction_GameOption_OnVoiceVolume::Value' has a wrong offset!");

// Function MirMobile.MM_Mastery_Info.OnClickMatTrainingSlot
// 0x0010 (0x0010 - 0x0000)
struct MM_Mastery_Info_OnClickMatTrainingSlot final
{
public:
	int64                                         ItemUID;                                           // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         ItemTID;                                           // 0x0008(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         EquipPosition;                                     // 0x000C(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(MM_Mastery_Info_OnClickMatTrainingSlot) == 0x000008, "Wrong alignment on MM_Mastery_Info_OnClickMatTrainingSlot");
static_assert(sizeof(MM_Mastery_Info_OnClickMatTrainingSlot) == 0x000010, "Wrong size on MM_Mastery_Info_OnClickMatTrainingSlot");
static_assert(offsetof(MM_Mastery_Info_OnClickMatTrainingSlot, ItemUID) == 0x000000, "Member 'MM_Mastery_Info_OnClickMatTrainingSlot::ItemUID' has a wrong offset!");
static_assert(offsetof(MM_Mastery_Info_OnClickMatTrainingSlot, ItemTID) == 0x000008, "Member 'MM_Mastery_Info_OnClickMatTrainingSlot::ItemTID' has a wrong offset!");
static_assert(offsetof(MM_Mastery_Info_OnClickMatTrainingSlot, EquipPosition) == 0x00000C, "Member 'MM_Mastery_Info_OnClickMatTrainingSlot::EquipPosition' has a wrong offset!");

// Function MirMobile.MM_Mastery_Info.OnClickMatUpgradeSlot
// 0x0010 (0x0010 - 0x0000)
struct MM_Mastery_Info_OnClickMatUpgradeSlot final
{
public:
	int64                                         ItemUID;                                           // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         ItemTID;                                           // 0x0008(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         EquipPosition;                                     // 0x000C(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(MM_Mastery_Info_OnClickMatUpgradeSlot) == 0x000008, "Wrong alignment on MM_Mastery_Info_OnClickMatUpgradeSlot");
static_assert(sizeof(MM_Mastery_Info_OnClickMatUpgradeSlot) == 0x000010, "Wrong size on MM_Mastery_Info_OnClickMatUpgradeSlot");
static_assert(offsetof(MM_Mastery_Info_OnClickMatUpgradeSlot, ItemUID) == 0x000000, "Member 'MM_Mastery_Info_OnClickMatUpgradeSlot::ItemUID' has a wrong offset!");
static_assert(offsetof(MM_Mastery_Info_OnClickMatUpgradeSlot, ItemTID) == 0x000008, "Member 'MM_Mastery_Info_OnClickMatUpgradeSlot::ItemTID' has a wrong offset!");
static_assert(offsetof(MM_Mastery_Info_OnClickMatUpgradeSlot, EquipPosition) == 0x00000C, "Member 'MM_Mastery_Info_OnClickMatUpgradeSlot::EquipPosition' has a wrong offset!");

// Function MirMobile.MM_Popup_ItemTranscendUse.OnClickCheckBox
// 0x0001 (0x0001 - 0x0000)
struct MM_Popup_ItemTranscendUse_OnClickCheckBox final
{
public:
	bool                                          Checked;                                           // 0x0000(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(MM_Popup_ItemTranscendUse_OnClickCheckBox) == 0x000001, "Wrong alignment on MM_Popup_ItemTranscendUse_OnClickCheckBox");
static_assert(sizeof(MM_Popup_ItemTranscendUse_OnClickCheckBox) == 0x000001, "Wrong size on MM_Popup_ItemTranscendUse_OnClickCheckBox");
static_assert(offsetof(MM_Popup_ItemTranscendUse_OnClickCheckBox, Checked) == 0x000000, "Member 'MM_Popup_ItemTranscendUse_OnClickCheckBox::Checked' has a wrong offset!");

// Function MirMobile.MM_Monster.OnDamageBeginOverlap
// 0x00A8 (0x00A8 - 0x0000)
struct MM_Monster_OnDamageBeginOverlap final
{
public:
	class UPrimitiveComponent*                    OverlappedComponent;                               // 0x0000(0x0008)(Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class AActor*                                 POtherActor;                                       // 0x0008(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UPrimitiveComponent*                    OtherComponent;                                    // 0x0010(0x0008)(Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         OtherBodyIndex;                                    // 0x0018(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bFromSweep;                                        // 0x001C(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1D[0x3];                                       // 0x001D(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	struct FHitResult                             SweepResult;                                       // 0x0020(0x0088)(ConstParm, Parm, OutParm, ReferenceParm, IsPlainOldData, NoDestructor, ContainsInstancedReference, NativeAccessSpecifierPublic)
};
static_assert(alignof(MM_Monster_OnDamageBeginOverlap) == 0x000008, "Wrong alignment on MM_Monster_OnDamageBeginOverlap");
static_assert(sizeof(MM_Monster_OnDamageBeginOverlap) == 0x0000A8, "Wrong size on MM_Monster_OnDamageBeginOverlap");
static_assert(offsetof(MM_Monster_OnDamageBeginOverlap, OverlappedComponent) == 0x000000, "Member 'MM_Monster_OnDamageBeginOverlap::OverlappedComponent' has a wrong offset!");
static_assert(offsetof(MM_Monster_OnDamageBeginOverlap, POtherActor) == 0x000008, "Member 'MM_Monster_OnDamageBeginOverlap::POtherActor' has a wrong offset!");
static_assert(offsetof(MM_Monster_OnDamageBeginOverlap, OtherComponent) == 0x000010, "Member 'MM_Monster_OnDamageBeginOverlap::OtherComponent' has a wrong offset!");
static_assert(offsetof(MM_Monster_OnDamageBeginOverlap, OtherBodyIndex) == 0x000018, "Member 'MM_Monster_OnDamageBeginOverlap::OtherBodyIndex' has a wrong offset!");
static_assert(offsetof(MM_Monster_OnDamageBeginOverlap, bFromSweep) == 0x00001C, "Member 'MM_Monster_OnDamageBeginOverlap::bFromSweep' has a wrong offset!");
static_assert(offsetof(MM_Monster_OnDamageBeginOverlap, SweepResult) == 0x000020, "Member 'MM_Monster_OnDamageBeginOverlap::SweepResult' has a wrong offset!");

// Function MirMobile.MM_Monster.OnDamageEndOverlap
// 0x0020 (0x0020 - 0x0000)
struct MM_Monster_OnDamageEndOverlap final
{
public:
	class UPrimitiveComponent*                    OverlappedComponent;                               // 0x0000(0x0008)(Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class AActor*                                 POtherActor;                                       // 0x0008(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UPrimitiveComponent*                    OtherComponent;                                    // 0x0010(0x0008)(Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         OtherBodyIndex;                                    // 0x0018(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1C[0x4];                                       // 0x001C(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(MM_Monster_OnDamageEndOverlap) == 0x000008, "Wrong alignment on MM_Monster_OnDamageEndOverlap");
static_assert(sizeof(MM_Monster_OnDamageEndOverlap) == 0x000020, "Wrong size on MM_Monster_OnDamageEndOverlap");
static_assert(offsetof(MM_Monster_OnDamageEndOverlap, OverlappedComponent) == 0x000000, "Member 'MM_Monster_OnDamageEndOverlap::OverlappedComponent' has a wrong offset!");
static_assert(offsetof(MM_Monster_OnDamageEndOverlap, POtherActor) == 0x000008, "Member 'MM_Monster_OnDamageEndOverlap::POtherActor' has a wrong offset!");
static_assert(offsetof(MM_Monster_OnDamageEndOverlap, OtherComponent) == 0x000010, "Member 'MM_Monster_OnDamageEndOverlap::OtherComponent' has a wrong offset!");
static_assert(offsetof(MM_Monster_OnDamageEndOverlap, OtherBodyIndex) == 0x000018, "Member 'MM_Monster_OnDamageEndOverlap::OtherBodyIndex' has a wrong offset!");

// Function MirMobile.MM_Monster.StartAirWalk
// 0x0010 (0x0010 - 0x0000)
struct MM_Monster_StartAirWalk final
{
public:
	TArray<struct FVector>                        DestLocList;                                       // 0x0000(0x0010)(Parm, ZeroConstructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(MM_Monster_StartAirWalk) == 0x000008, "Wrong alignment on MM_Monster_StartAirWalk");
static_assert(sizeof(MM_Monster_StartAirWalk) == 0x000010, "Wrong size on MM_Monster_StartAirWalk");
static_assert(offsetof(MM_Monster_StartAirWalk, DestLocList) == 0x000000, "Member 'MM_Monster_StartAirWalk::DestLocList' has a wrong offset!");

// Function MirMobile.MM_MonsterAIController.IsExcessAttackCoolTime
// 0x0001 (0x0001 - 0x0000)
struct MM_MonsterAIController_IsExcessAttackCoolTime final
{
public:
	bool                                          ReturnValue;                                       // 0x0000(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(MM_MonsterAIController_IsExcessAttackCoolTime) == 0x000001, "Wrong alignment on MM_MonsterAIController_IsExcessAttackCoolTime");
static_assert(sizeof(MM_MonsterAIController_IsExcessAttackCoolTime) == 0x000001, "Wrong size on MM_MonsterAIController_IsExcessAttackCoolTime");
static_assert(offsetof(MM_MonsterAIController_IsExcessAttackCoolTime, ReturnValue) == 0x000000, "Member 'MM_MonsterAIController_IsExcessAttackCoolTime::ReturnValue' has a wrong offset!");

// Function MirMobile.MM_MonsterAIController.ReturnToHome
// 0x0001 (0x0001 - 0x0000)
struct MM_MonsterAIController_ReturnToHome final
{
public:
	bool                                          ReturnValue;                                       // 0x0000(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(MM_MonsterAIController_ReturnToHome) == 0x000001, "Wrong alignment on MM_MonsterAIController_ReturnToHome");
static_assert(sizeof(MM_MonsterAIController_ReturnToHome) == 0x000001, "Wrong size on MM_MonsterAIController_ReturnToHome");
static_assert(offsetof(MM_MonsterAIController_ReturnToHome, ReturnValue) == 0x000000, "Member 'MM_MonsterAIController_ReturnToHome::ReturnValue' has a wrong offset!");

// Function MirMobile.MM_MonsterAIController.SearchTargetMonster
// 0x0004 (0x0004 - 0x0000)
struct MM_MonsterAIController_SearchTargetMonster final
{
public:
	int32                                         NTID;                                              // 0x0000(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(MM_MonsterAIController_SearchTargetMonster) == 0x000004, "Wrong alignment on MM_MonsterAIController_SearchTargetMonster");
static_assert(sizeof(MM_MonsterAIController_SearchTargetMonster) == 0x000004, "Wrong size on MM_MonsterAIController_SearchTargetMonster");
static_assert(offsetof(MM_MonsterAIController_SearchTargetMonster, NTID) == 0x000000, "Member 'MM_MonsterAIController_SearchTargetMonster::NTID' has a wrong offset!");

// Function MirMobile.MM_MonsterAIController.SetAttackRate
// 0x0008 (0x0008 - 0x0000)
struct MM_MonsterAIController_SetAttackRate final
{
public:
	int32                                         Idx;                                               // 0x0000(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          ReturnValue;                                       // 0x0004(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_5[0x3];                                        // 0x0005(0x0003)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(MM_MonsterAIController_SetAttackRate) == 0x000004, "Wrong alignment on MM_MonsterAIController_SetAttackRate");
static_assert(sizeof(MM_MonsterAIController_SetAttackRate) == 0x000008, "Wrong size on MM_MonsterAIController_SetAttackRate");
static_assert(offsetof(MM_MonsterAIController_SetAttackRate, Idx) == 0x000000, "Member 'MM_MonsterAIController_SetAttackRate::Idx' has a wrong offset!");
static_assert(offsetof(MM_MonsterAIController_SetAttackRate, ReturnValue) == 0x000004, "Member 'MM_MonsterAIController_SetAttackRate::ReturnValue' has a wrong offset!");

// Function MirMobile.MM_MonsterAIController.SetLongAttackID
// 0x0008 (0x0008 - 0x0000)
struct MM_MonsterAIController_SetLongAttackID final
{
public:
	int32                                         NIdx;                                              // 0x0000(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         ReturnValue;                                       // 0x0004(0x0004)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(MM_MonsterAIController_SetLongAttackID) == 0x000004, "Wrong alignment on MM_MonsterAIController_SetLongAttackID");
static_assert(sizeof(MM_MonsterAIController_SetLongAttackID) == 0x000008, "Wrong size on MM_MonsterAIController_SetLongAttackID");
static_assert(offsetof(MM_MonsterAIController_SetLongAttackID, NIdx) == 0x000000, "Member 'MM_MonsterAIController_SetLongAttackID::NIdx' has a wrong offset!");
static_assert(offsetof(MM_MonsterAIController_SetLongAttackID, ReturnValue) == 0x000004, "Member 'MM_MonsterAIController_SetLongAttackID::ReturnValue' has a wrong offset!");

// Function MirMobile.MM_MonsterAIController.SetLongAttackRate
// 0x0008 (0x0008 - 0x0000)
struct MM_MonsterAIController_SetLongAttackRate final
{
public:
	int32                                         Idx;                                               // 0x0000(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          ReturnValue;                                       // 0x0004(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_5[0x3];                                        // 0x0005(0x0003)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(MM_MonsterAIController_SetLongAttackRate) == 0x000004, "Wrong alignment on MM_MonsterAIController_SetLongAttackRate");
static_assert(sizeof(MM_MonsterAIController_SetLongAttackRate) == 0x000008, "Wrong size on MM_MonsterAIController_SetLongAttackRate");
static_assert(offsetof(MM_MonsterAIController_SetLongAttackRate, Idx) == 0x000000, "Member 'MM_MonsterAIController_SetLongAttackRate::Idx' has a wrong offset!");
static_assert(offsetof(MM_MonsterAIController_SetLongAttackRate, ReturnValue) == 0x000004, "Member 'MM_MonsterAIController_SetLongAttackRate::ReturnValue' has a wrong offset!");

// Function MirMobile.MM_MonsterAIController.SetShortAttackID
// 0x0008 (0x0008 - 0x0000)
struct MM_MonsterAIController_SetShortAttackID final
{
public:
	int32                                         NIdx;                                              // 0x0000(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         ReturnValue;                                       // 0x0004(0x0004)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(MM_MonsterAIController_SetShortAttackID) == 0x000004, "Wrong alignment on MM_MonsterAIController_SetShortAttackID");
static_assert(sizeof(MM_MonsterAIController_SetShortAttackID) == 0x000008, "Wrong size on MM_MonsterAIController_SetShortAttackID");
static_assert(offsetof(MM_MonsterAIController_SetShortAttackID, NIdx) == 0x000000, "Member 'MM_MonsterAIController_SetShortAttackID::NIdx' has a wrong offset!");
static_assert(offsetof(MM_MonsterAIController_SetShortAttackID, ReturnValue) == 0x000004, "Member 'MM_MonsterAIController_SetShortAttackID::ReturnValue' has a wrong offset!");

// Function MirMobile.MM_MonsterDyeingCheatWidget.Change01ColorValue
// 0x0010 (0x0010 - 0x0000)
struct MM_MonsterDyeingCheatWidget_Change01ColorValue final
{
public:
	float                                         Body01_R;                                          // 0x0000(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         Body01_G;                                          // 0x0004(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         Body01_B;                                          // 0x0008(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         Body01_V;                                          // 0x000C(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(MM_MonsterDyeingCheatWidget_Change01ColorValue) == 0x000004, "Wrong alignment on MM_MonsterDyeingCheatWidget_Change01ColorValue");
static_assert(sizeof(MM_MonsterDyeingCheatWidget_Change01ColorValue) == 0x000010, "Wrong size on MM_MonsterDyeingCheatWidget_Change01ColorValue");
static_assert(offsetof(MM_MonsterDyeingCheatWidget_Change01ColorValue, Body01_R) == 0x000000, "Member 'MM_MonsterDyeingCheatWidget_Change01ColorValue::Body01_R' has a wrong offset!");
static_assert(offsetof(MM_MonsterDyeingCheatWidget_Change01ColorValue, Body01_G) == 0x000004, "Member 'MM_MonsterDyeingCheatWidget_Change01ColorValue::Body01_G' has a wrong offset!");
static_assert(offsetof(MM_MonsterDyeingCheatWidget_Change01ColorValue, Body01_B) == 0x000008, "Member 'MM_MonsterDyeingCheatWidget_Change01ColorValue::Body01_B' has a wrong offset!");
static_assert(offsetof(MM_MonsterDyeingCheatWidget_Change01ColorValue, Body01_V) == 0x00000C, "Member 'MM_MonsterDyeingCheatWidget_Change01ColorValue::Body01_V' has a wrong offset!");

// Function MirMobile.MM_Popup_MapMark_Slot.OnToggleMapMark
// 0x0001 (0x0001 - 0x0000)
struct MM_Popup_MapMark_Slot_OnToggleMapMark final
{
public:
	bool                                          CheckState;                                        // 0x0000(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(MM_Popup_MapMark_Slot_OnToggleMapMark) == 0x000001, "Wrong alignment on MM_Popup_MapMark_Slot_OnToggleMapMark");
static_assert(sizeof(MM_Popup_MapMark_Slot_OnToggleMapMark) == 0x000001, "Wrong size on MM_Popup_MapMark_Slot_OnToggleMapMark");
static_assert(offsetof(MM_Popup_MapMark_Slot_OnToggleMapMark, CheckState) == 0x000000, "Member 'MM_Popup_MapMark_Slot_OnToggleMapMark::CheckState' has a wrong offset!");

// Function MirMobile.MM_MoviePlayerWidget.PlayMedia
// 0x0010 (0x0010 - 0x0000)
struct MM_MoviePlayerWidget_PlayMedia final
{
public:
	class FString                                 StrMediaPath;                                      // 0x0000(0x0010)(Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(MM_MoviePlayerWidget_PlayMedia) == 0x000008, "Wrong alignment on MM_MoviePlayerWidget_PlayMedia");
static_assert(sizeof(MM_MoviePlayerWidget_PlayMedia) == 0x000010, "Wrong size on MM_MoviePlayerWidget_PlayMedia");
static_assert(offsetof(MM_MoviePlayerWidget_PlayMedia, StrMediaPath) == 0x000000, "Member 'MM_MoviePlayerWidget_PlayMedia::StrMediaPath' has a wrong offset!");

// Function MirMobile.MM_New_Force_Ability_List.OnClick_MatSlot
// 0x0010 (0x0010 - 0x0000)
struct MM_New_Force_Ability_List_OnClick_MatSlot final
{
public:
	int64                                         ItemUID;                                           // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         ItemTID;                                           // 0x0008(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         EquipPosition;                                     // 0x000C(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(MM_New_Force_Ability_List_OnClick_MatSlot) == 0x000008, "Wrong alignment on MM_New_Force_Ability_List_OnClick_MatSlot");
static_assert(sizeof(MM_New_Force_Ability_List_OnClick_MatSlot) == 0x000010, "Wrong size on MM_New_Force_Ability_List_OnClick_MatSlot");
static_assert(offsetof(MM_New_Force_Ability_List_OnClick_MatSlot, ItemUID) == 0x000000, "Member 'MM_New_Force_Ability_List_OnClick_MatSlot::ItemUID' has a wrong offset!");
static_assert(offsetof(MM_New_Force_Ability_List_OnClick_MatSlot, ItemTID) == 0x000008, "Member 'MM_New_Force_Ability_List_OnClick_MatSlot::ItemTID' has a wrong offset!");
static_assert(offsetof(MM_New_Force_Ability_List_OnClick_MatSlot, EquipPosition) == 0x00000C, "Member 'MM_New_Force_Ability_List_OnClick_MatSlot::EquipPosition' has a wrong offset!");

// Function MirMobile.MM_New_Force_Page.OnClickOpenMatSlot
// 0x0010 (0x0010 - 0x0000)
struct MM_New_Force_Page_OnClickOpenMatSlot final
{
public:
	int64                                         IUID;                                              // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         ITID;                                              // 0x0008(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         IPos;                                              // 0x000C(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(MM_New_Force_Page_OnClickOpenMatSlot) == 0x000008, "Wrong alignment on MM_New_Force_Page_OnClickOpenMatSlot");
static_assert(sizeof(MM_New_Force_Page_OnClickOpenMatSlot) == 0x000010, "Wrong size on MM_New_Force_Page_OnClickOpenMatSlot");
static_assert(offsetof(MM_New_Force_Page_OnClickOpenMatSlot, IUID) == 0x000000, "Member 'MM_New_Force_Page_OnClickOpenMatSlot::IUID' has a wrong offset!");
static_assert(offsetof(MM_New_Force_Page_OnClickOpenMatSlot, ITID) == 0x000008, "Member 'MM_New_Force_Page_OnClickOpenMatSlot::ITID' has a wrong offset!");
static_assert(offsetof(MM_New_Force_Page_OnClickOpenMatSlot, IPos) == 0x00000C, "Member 'MM_New_Force_Page_OnClickOpenMatSlot::IPos' has a wrong offset!");

// Function MirMobile.MM_Popup_BlackIronShop_Give.OnChangeCount
// 0x0008 (0x0008 - 0x0000)
struct MM_Popup_BlackIronShop_Give_OnChangeCount final
{
public:
	int64                                         Count_;                                            // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(MM_Popup_BlackIronShop_Give_OnChangeCount) == 0x000008, "Wrong alignment on MM_Popup_BlackIronShop_Give_OnChangeCount");
static_assert(sizeof(MM_Popup_BlackIronShop_Give_OnChangeCount) == 0x000008, "Wrong size on MM_Popup_BlackIronShop_Give_OnChangeCount");
static_assert(offsetof(MM_Popup_BlackIronShop_Give_OnChangeCount, Count_) == 0x000000, "Member 'MM_Popup_BlackIronShop_Give_OnChangeCount::Count_' has a wrong offset!");

// Function MirMobile.MM_Popup_BlackIronShop_Give.OnLockSlider
// 0x0001 (0x0001 - 0x0000)
struct MM_Popup_BlackIronShop_Give_OnLockSlider final
{
public:
	bool                                          bLock;                                             // 0x0000(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(MM_Popup_BlackIronShop_Give_OnLockSlider) == 0x000001, "Wrong alignment on MM_Popup_BlackIronShop_Give_OnLockSlider");
static_assert(sizeof(MM_Popup_BlackIronShop_Give_OnLockSlider) == 0x000001, "Wrong size on MM_Popup_BlackIronShop_Give_OnLockSlider");
static_assert(offsetof(MM_Popup_BlackIronShop_Give_OnLockSlider, bLock) == 0x000000, "Member 'MM_Popup_BlackIronShop_Give_OnLockSlider::bLock' has a wrong offset!");

// Function MirMobile.MM_New_Force_Upgrade.OnClick_MatSlot
// 0x0010 (0x0010 - 0x0000)
struct MM_New_Force_Upgrade_OnClick_MatSlot final
{
public:
	int64                                         ItemUID;                                           // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         ItemTID;                                           // 0x0008(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         EquipPosition;                                     // 0x000C(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(MM_New_Force_Upgrade_OnClick_MatSlot) == 0x000008, "Wrong alignment on MM_New_Force_Upgrade_OnClick_MatSlot");
static_assert(sizeof(MM_New_Force_Upgrade_OnClick_MatSlot) == 0x000010, "Wrong size on MM_New_Force_Upgrade_OnClick_MatSlot");
static_assert(offsetof(MM_New_Force_Upgrade_OnClick_MatSlot, ItemUID) == 0x000000, "Member 'MM_New_Force_Upgrade_OnClick_MatSlot::ItemUID' has a wrong offset!");
static_assert(offsetof(MM_New_Force_Upgrade_OnClick_MatSlot, ItemTID) == 0x000008, "Member 'MM_New_Force_Upgrade_OnClick_MatSlot::ItemTID' has a wrong offset!");
static_assert(offsetof(MM_New_Force_Upgrade_OnClick_MatSlot, EquipPosition) == 0x00000C, "Member 'MM_New_Force_Upgrade_OnClick_MatSlot::EquipPosition' has a wrong offset!");

// Function MirMobile.MM_NewInventory.ClickedSlot
// 0x0010 (0x0010 - 0x0000)
struct MM_NewInventory_ClickedSlot final
{
public:
	int64                                         IUID;                                              // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         ITID;                                              // 0x0008(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         IEquipPos;                                         // 0x000C(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(MM_NewInventory_ClickedSlot) == 0x000008, "Wrong alignment on MM_NewInventory_ClickedSlot");
static_assert(sizeof(MM_NewInventory_ClickedSlot) == 0x000010, "Wrong size on MM_NewInventory_ClickedSlot");
static_assert(offsetof(MM_NewInventory_ClickedSlot, IUID) == 0x000000, "Member 'MM_NewInventory_ClickedSlot::IUID' has a wrong offset!");
static_assert(offsetof(MM_NewInventory_ClickedSlot, ITID) == 0x000008, "Member 'MM_NewInventory_ClickedSlot::ITID' has a wrong offset!");
static_assert(offsetof(MM_NewInventory_ClickedSlot, IEquipPos) == 0x00000C, "Member 'MM_NewInventory_ClickedSlot::IEquipPos' has a wrong offset!");

// Function MirMobile.MM_Popup_Chat_Setting.OnClickAddBlockUser
// 0x0010 (0x0010 - 0x0000)
struct MM_Popup_Chat_Setting_OnClickAddBlockUser final
{
public:
	class FString                                 BlockUserName;                                     // 0x0000(0x0010)(Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(MM_Popup_Chat_Setting_OnClickAddBlockUser) == 0x000008, "Wrong alignment on MM_Popup_Chat_Setting_OnClickAddBlockUser");
static_assert(sizeof(MM_Popup_Chat_Setting_OnClickAddBlockUser) == 0x000010, "Wrong size on MM_Popup_Chat_Setting_OnClickAddBlockUser");
static_assert(offsetof(MM_Popup_Chat_Setting_OnClickAddBlockUser, BlockUserName) == 0x000000, "Member 'MM_Popup_Chat_Setting_OnClickAddBlockUser::BlockUserName' has a wrong offset!");

// Function MirMobile.MM_Popup_Chat_Setting.OnToggleChatIndicatorType
// 0x0001 (0x0001 - 0x0000)
struct MM_Popup_Chat_Setting_OnToggleChatIndicatorType final
{
public:
	bool                                          CheckState;                                        // 0x0000(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(MM_Popup_Chat_Setting_OnToggleChatIndicatorType) == 0x000001, "Wrong alignment on MM_Popup_Chat_Setting_OnToggleChatIndicatorType");
static_assert(sizeof(MM_Popup_Chat_Setting_OnToggleChatIndicatorType) == 0x000001, "Wrong size on MM_Popup_Chat_Setting_OnToggleChatIndicatorType");
static_assert(offsetof(MM_Popup_Chat_Setting_OnToggleChatIndicatorType, CheckState) == 0x000000, "Member 'MM_Popup_Chat_Setting_OnToggleChatIndicatorType::CheckState' has a wrong offset!");

// Function MirMobile.MM_Popup_Chat_Setting.OnToggleHideGuildSystemMessage
// 0x0001 (0x0001 - 0x0000)
struct MM_Popup_Chat_Setting_OnToggleHideGuildSystemMessage final
{
public:
	bool                                          CheckState;                                        // 0x0000(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(MM_Popup_Chat_Setting_OnToggleHideGuildSystemMessage) == 0x000001, "Wrong alignment on MM_Popup_Chat_Setting_OnToggleHideGuildSystemMessage");
static_assert(sizeof(MM_Popup_Chat_Setting_OnToggleHideGuildSystemMessage) == 0x000001, "Wrong size on MM_Popup_Chat_Setting_OnToggleHideGuildSystemMessage");
static_assert(offsetof(MM_Popup_Chat_Setting_OnToggleHideGuildSystemMessage, CheckState) == 0x000000, "Member 'MM_Popup_Chat_Setting_OnToggleHideGuildSystemMessage::CheckState' has a wrong offset!");

// Function MirMobile.MM_Popup_Chat_Setting.OnToggleHideSystemChannel
// 0x0001 (0x0001 - 0x0000)
struct MM_Popup_Chat_Setting_OnToggleHideSystemChannel final
{
public:
	bool                                          CheckState;                                        // 0x0000(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(MM_Popup_Chat_Setting_OnToggleHideSystemChannel) == 0x000001, "Wrong alignment on MM_Popup_Chat_Setting_OnToggleHideSystemChannel");
static_assert(sizeof(MM_Popup_Chat_Setting_OnToggleHideSystemChannel) == 0x000001, "Wrong size on MM_Popup_Chat_Setting_OnToggleHideSystemChannel");
static_assert(offsetof(MM_Popup_Chat_Setting_OnToggleHideSystemChannel, CheckState) == 0x000000, "Member 'MM_Popup_Chat_Setting_OnToggleHideSystemChannel::CheckState' has a wrong offset!");

// Function MirMobile.MM_Popup_Guild_ShopRecord.OnClickBuy
// 0x0001 (0x0001 - 0x0000)
struct MM_Popup_Guild_ShopRecord_OnClickBuy final
{
public:
	bool                                          bChecked;                                          // 0x0000(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(MM_Popup_Guild_ShopRecord_OnClickBuy) == 0x000001, "Wrong alignment on MM_Popup_Guild_ShopRecord_OnClickBuy");
static_assert(sizeof(MM_Popup_Guild_ShopRecord_OnClickBuy) == 0x000001, "Wrong size on MM_Popup_Guild_ShopRecord_OnClickBuy");
static_assert(offsetof(MM_Popup_Guild_ShopRecord_OnClickBuy, bChecked) == 0x000000, "Member 'MM_Popup_Guild_ShopRecord_OnClickBuy::bChecked' has a wrong offset!");

// Function MirMobile.MM_Popup_Guild_ShopRecord.OnClickRegist
// 0x0001 (0x0001 - 0x0000)
struct MM_Popup_Guild_ShopRecord_OnClickRegist final
{
public:
	bool                                          bChecked;                                          // 0x0000(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(MM_Popup_Guild_ShopRecord_OnClickRegist) == 0x000001, "Wrong alignment on MM_Popup_Guild_ShopRecord_OnClickRegist");
static_assert(sizeof(MM_Popup_Guild_ShopRecord_OnClickRegist) == 0x000001, "Wrong size on MM_Popup_Guild_ShopRecord_OnClickRegist");
static_assert(offsetof(MM_Popup_Guild_ShopRecord_OnClickRegist, bChecked) == 0x000000, "Member 'MM_Popup_Guild_ShopRecord_OnClickRegist::bChecked' has a wrong offset!");

// Function MirMobile.MM_Popup_Guild_ShopRecord.PlayEndAnimation
// 0x0004 (0x0004 - 0x0000)
struct MM_Popup_Guild_ShopRecord_PlayEndAnimation final
{
public:
	float                                         ReturnValue;                                       // 0x0000(0x0004)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(MM_Popup_Guild_ShopRecord_PlayEndAnimation) == 0x000004, "Wrong alignment on MM_Popup_Guild_ShopRecord_PlayEndAnimation");
static_assert(sizeof(MM_Popup_Guild_ShopRecord_PlayEndAnimation) == 0x000004, "Wrong size on MM_Popup_Guild_ShopRecord_PlayEndAnimation");
static_assert(offsetof(MM_Popup_Guild_ShopRecord_PlayEndAnimation, ReturnValue) == 0x000000, "Member 'MM_Popup_Guild_ShopRecord_PlayEndAnimation::ReturnValue' has a wrong offset!");

// Function MirMobile.MM_NewInventory_StorageRight.OnClickCheckBoxTotalTransfer
// 0x0001 (0x0001 - 0x0000)
struct MM_NewInventory_StorageRight_OnClickCheckBoxTotalTransfer final
{
public:
	bool                                          bChecked;                                          // 0x0000(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(MM_NewInventory_StorageRight_OnClickCheckBoxTotalTransfer) == 0x000001, "Wrong alignment on MM_NewInventory_StorageRight_OnClickCheckBoxTotalTransfer");
static_assert(sizeof(MM_NewInventory_StorageRight_OnClickCheckBoxTotalTransfer) == 0x000001, "Wrong size on MM_NewInventory_StorageRight_OnClickCheckBoxTotalTransfer");
static_assert(offsetof(MM_NewInventory_StorageRight_OnClickCheckBoxTotalTransfer, bChecked) == 0x000000, "Member 'MM_NewInventory_StorageRight_OnClickCheckBoxTotalTransfer::bChecked' has a wrong offset!");

// Function MirMobile.MM_Popup_GuildDevBenefit.PlayEndAnimation
// 0x0004 (0x0004 - 0x0000)
struct MM_Popup_GuildDevBenefit_PlayEndAnimation final
{
public:
	float                                         ReturnValue;                                       // 0x0000(0x0004)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(MM_Popup_GuildDevBenefit_PlayEndAnimation) == 0x000004, "Wrong alignment on MM_Popup_GuildDevBenefit_PlayEndAnimation");
static_assert(sizeof(MM_Popup_GuildDevBenefit_PlayEndAnimation) == 0x000004, "Wrong size on MM_Popup_GuildDevBenefit_PlayEndAnimation");
static_assert(offsetof(MM_Popup_GuildDevBenefit_PlayEndAnimation, ReturnValue) == 0x000000, "Member 'MM_Popup_GuildDevBenefit_PlayEndAnimation::ReturnValue' has a wrong offset!");

// Function MirMobile.MM_NewInventoryUnsealing.OnClickCheckBox
// 0x0001 (0x0001 - 0x0000)
struct MM_NewInventoryUnsealing_OnClickCheckBox final
{
public:
	bool                                          bChecked;                                          // 0x0000(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(MM_NewInventoryUnsealing_OnClickCheckBox) == 0x000001, "Wrong alignment on MM_NewInventoryUnsealing_OnClickCheckBox");
static_assert(sizeof(MM_NewInventoryUnsealing_OnClickCheckBox) == 0x000001, "Wrong size on MM_NewInventoryUnsealing_OnClickCheckBox");
static_assert(offsetof(MM_NewInventoryUnsealing_OnClickCheckBox, bChecked) == 0x000000, "Member 'MM_NewInventoryUnsealing_OnClickCheckBox::bChecked' has a wrong offset!");

// Function MirMobile.MM_UIAction_QuestRelation.OnClickCategory
// 0x0004 (0x0004 - 0x0000)
struct MM_UIAction_QuestRelation_OnClickCategory final
{
public:
	int32                                         Index_0;                                           // 0x0000(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(MM_UIAction_QuestRelation_OnClickCategory) == 0x000004, "Wrong alignment on MM_UIAction_QuestRelation_OnClickCategory");
static_assert(sizeof(MM_UIAction_QuestRelation_OnClickCategory) == 0x000004, "Wrong size on MM_UIAction_QuestRelation_OnClickCategory");
static_assert(offsetof(MM_UIAction_QuestRelation_OnClickCategory, Index_0) == 0x000000, "Member 'MM_UIAction_QuestRelation_OnClickCategory::Index_0' has a wrong offset!");

// Function MirMobile.MM_UIAction_QuestRelation.OnClickGroupOfQuest
// 0x0004 (0x0004 - 0x0000)
struct MM_UIAction_QuestRelation_OnClickGroupOfQuest final
{
public:
	int32                                         Index_0;                                           // 0x0000(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(MM_UIAction_QuestRelation_OnClickGroupOfQuest) == 0x000004, "Wrong alignment on MM_UIAction_QuestRelation_OnClickGroupOfQuest");
static_assert(sizeof(MM_UIAction_QuestRelation_OnClickGroupOfQuest) == 0x000004, "Wrong size on MM_UIAction_QuestRelation_OnClickGroupOfQuest");
static_assert(offsetof(MM_UIAction_QuestRelation_OnClickGroupOfQuest, Index_0) == 0x000000, "Member 'MM_UIAction_QuestRelation_OnClickGroupOfQuest::Index_0' has a wrong offset!");

// Function MirMobile.MM_NPC.StartAirWalk
// 0x0010 (0x0010 - 0x0000)
struct MM_NPC_StartAirWalk final
{
public:
	TArray<struct FVector>                        DestLocList;                                       // 0x0000(0x0010)(Parm, ZeroConstructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(MM_NPC_StartAirWalk) == 0x000008, "Wrong alignment on MM_NPC_StartAirWalk");
static_assert(sizeof(MM_NPC_StartAirWalk) == 0x000010, "Wrong size on MM_NPC_StartAirWalk");
static_assert(offsetof(MM_NPC_StartAirWalk, DestLocList) == 0x000000, "Member 'MM_NPC_StartAirWalk::DestLocList' has a wrong offset!");

// Function MirMobile.MM_Popup_Sabuk_EmperorOrder.OnOnEmperorOrder
// 0x0004 (0x0004 - 0x0000)
struct MM_Popup_Sabuk_EmperorOrder_OnOnEmperorOrder final
{
public:
	int32                                         InBuffID;                                          // 0x0000(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(MM_Popup_Sabuk_EmperorOrder_OnOnEmperorOrder) == 0x000004, "Wrong alignment on MM_Popup_Sabuk_EmperorOrder_OnOnEmperorOrder");
static_assert(sizeof(MM_Popup_Sabuk_EmperorOrder_OnOnEmperorOrder) == 0x000004, "Wrong size on MM_Popup_Sabuk_EmperorOrder_OnOnEmperorOrder");
static_assert(offsetof(MM_Popup_Sabuk_EmperorOrder_OnOnEmperorOrder, InBuffID) == 0x000000, "Member 'MM_Popup_Sabuk_EmperorOrder_OnOnEmperorOrder::InBuffID' has a wrong offset!");

// Function MirMobile.MM_Popup_Sabuk_EmperorOrder.OnSlotClicked
// 0x0008 (0x0008 - 0x0000)
struct MM_Popup_Sabuk_EmperorOrder_OnSlotClicked final
{
public:
	int32                                         InWorldID;                                         // 0x0000(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         InBuffID;                                          // 0x0004(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(MM_Popup_Sabuk_EmperorOrder_OnSlotClicked) == 0x000004, "Wrong alignment on MM_Popup_Sabuk_EmperorOrder_OnSlotClicked");
static_assert(sizeof(MM_Popup_Sabuk_EmperorOrder_OnSlotClicked) == 0x000008, "Wrong size on MM_Popup_Sabuk_EmperorOrder_OnSlotClicked");
static_assert(offsetof(MM_Popup_Sabuk_EmperorOrder_OnSlotClicked, InWorldID) == 0x000000, "Member 'MM_Popup_Sabuk_EmperorOrder_OnSlotClicked::InWorldID' has a wrong offset!");
static_assert(offsetof(MM_Popup_Sabuk_EmperorOrder_OnSlotClicked, InBuffID) == 0x000004, "Member 'MM_Popup_Sabuk_EmperorOrder_OnSlotClicked::InBuffID' has a wrong offset!");

// Function MirMobile.MM_Popup_Sabuk_Prize.OnClickSlot
// 0x0004 (0x0004 - 0x0000)
struct MM_Popup_Sabuk_Prize_OnClickSlot final
{
public:
	int32                                         IPrizeID;                                          // 0x0000(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(MM_Popup_Sabuk_Prize_OnClickSlot) == 0x000004, "Wrong alignment on MM_Popup_Sabuk_Prize_OnClickSlot");
static_assert(sizeof(MM_Popup_Sabuk_Prize_OnClickSlot) == 0x000004, "Wrong size on MM_Popup_Sabuk_Prize_OnClickSlot");
static_assert(offsetof(MM_Popup_Sabuk_Prize_OnClickSlot, IPrizeID) == 0x000000, "Member 'MM_Popup_Sabuk_Prize_OnClickSlot::IPrizeID' has a wrong offset!");

// Function MirMobile.MM_Occupation_CommandSlot.OnDragControlButton
// 0x0008 (0x0008 - 0x0000)
struct MM_Occupation_CommandSlot_OnDragControlButton final
{
public:
	struct FVector2D                              DragLoc;                                           // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(MM_Occupation_CommandSlot_OnDragControlButton) == 0x000004, "Wrong alignment on MM_Occupation_CommandSlot_OnDragControlButton");
static_assert(sizeof(MM_Occupation_CommandSlot_OnDragControlButton) == 0x000008, "Wrong size on MM_Occupation_CommandSlot_OnDragControlButton");
static_assert(offsetof(MM_Occupation_CommandSlot_OnDragControlButton, DragLoc) == 0x000000, "Member 'MM_Occupation_CommandSlot_OnDragControlButton::DragLoc' has a wrong offset!");

// Function MirMobile.MM_Occupation_CommandSlot.OnReleasedControlButton
// 0x0008 (0x0008 - 0x0000)
struct MM_Occupation_CommandSlot_OnReleasedControlButton final
{
public:
	struct FVector2D                              DragLoc;                                           // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(MM_Occupation_CommandSlot_OnReleasedControlButton) == 0x000004, "Wrong alignment on MM_Occupation_CommandSlot_OnReleasedControlButton");
static_assert(sizeof(MM_Occupation_CommandSlot_OnReleasedControlButton) == 0x000008, "Wrong size on MM_Occupation_CommandSlot_OnReleasedControlButton");
static_assert(offsetof(MM_Occupation_CommandSlot_OnReleasedControlButton, DragLoc) == 0x000000, "Member 'MM_Occupation_CommandSlot_OnReleasedControlButton::DragLoc' has a wrong offset!");

// Function MirMobile.MM_Occupation_CommandSlot.OnStartControlButton
// 0x0008 (0x0008 - 0x0000)
struct MM_Occupation_CommandSlot_OnStartControlButton final
{
public:
	struct FVector2D                              DragLoc;                                           // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(MM_Occupation_CommandSlot_OnStartControlButton) == 0x000004, "Wrong alignment on MM_Occupation_CommandSlot_OnStartControlButton");
static_assert(sizeof(MM_Occupation_CommandSlot_OnStartControlButton) == 0x000008, "Wrong size on MM_Occupation_CommandSlot_OnStartControlButton");
static_assert(offsetof(MM_Occupation_CommandSlot_OnStartControlButton, DragLoc) == 0x000000, "Member 'MM_Occupation_CommandSlot_OnStartControlButton::DragLoc' has a wrong offset!");

// Function MirMobile.MM_Popup_DominionBuff.OnClickSlot
// 0x0004 (0x0004 - 0x0000)
struct MM_Popup_DominionBuff_OnClickSlot final
{
public:
	int32                                         ISlotIndex;                                        // 0x0000(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(MM_Popup_DominionBuff_OnClickSlot) == 0x000004, "Wrong alignment on MM_Popup_DominionBuff_OnClickSlot");
static_assert(sizeof(MM_Popup_DominionBuff_OnClickSlot) == 0x000004, "Wrong size on MM_Popup_DominionBuff_OnClickSlot");
static_assert(offsetof(MM_Popup_DominionBuff_OnClickSlot, ISlotIndex) == 0x000000, "Member 'MM_Popup_DominionBuff_OnClickSlot::ISlotIndex' has a wrong offset!");

// Function MirMobile.MM_Popup_DominionPrize.OnClickSlot
// 0x0004 (0x0004 - 0x0000)
struct MM_Popup_DominionPrize_OnClickSlot final
{
public:
	int32                                         IPrizeID;                                          // 0x0000(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(MM_Popup_DominionPrize_OnClickSlot) == 0x000004, "Wrong alignment on MM_Popup_DominionPrize_OnClickSlot");
static_assert(sizeof(MM_Popup_DominionPrize_OnClickSlot) == 0x000004, "Wrong size on MM_Popup_DominionPrize_OnClickSlot");
static_assert(offsetof(MM_Popup_DominionPrize_OnClickSlot, IPrizeID) == 0x000000, "Member 'MM_Popup_DominionPrize_OnClickSlot::IPrizeID' has a wrong offset!");

// Function MirMobile.MM_Popup_Sabuk_TaxRate_Information.OnCheckBlackIron
// 0x0001 (0x0001 - 0x0000)
struct MM_Popup_Sabuk_TaxRate_Information_OnCheckBlackIron final
{
public:
	bool                                          bChecked;                                          // 0x0000(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(MM_Popup_Sabuk_TaxRate_Information_OnCheckBlackIron) == 0x000001, "Wrong alignment on MM_Popup_Sabuk_TaxRate_Information_OnCheckBlackIron");
static_assert(sizeof(MM_Popup_Sabuk_TaxRate_Information_OnCheckBlackIron) == 0x000001, "Wrong size on MM_Popup_Sabuk_TaxRate_Information_OnCheckBlackIron");
static_assert(offsetof(MM_Popup_Sabuk_TaxRate_Information_OnCheckBlackIron, bChecked) == 0x000000, "Member 'MM_Popup_Sabuk_TaxRate_Information_OnCheckBlackIron::bChecked' has a wrong offset!");

// Function MirMobile.MM_Popup_Sabuk_TaxRate_Information.OnCheckGold
// 0x0001 (0x0001 - 0x0000)
struct MM_Popup_Sabuk_TaxRate_Information_OnCheckGold final
{
public:
	bool                                          bChecked;                                          // 0x0000(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(MM_Popup_Sabuk_TaxRate_Information_OnCheckGold) == 0x000001, "Wrong alignment on MM_Popup_Sabuk_TaxRate_Information_OnCheckGold");
static_assert(sizeof(MM_Popup_Sabuk_TaxRate_Information_OnCheckGold) == 0x000001, "Wrong size on MM_Popup_Sabuk_TaxRate_Information_OnCheckGold");
static_assert(offsetof(MM_Popup_Sabuk_TaxRate_Information_OnCheckGold, bChecked) == 0x000000, "Member 'MM_Popup_Sabuk_TaxRate_Information_OnCheckGold::bChecked' has a wrong offset!");

// Function MirMobile.MM_Occupation_SituationBoard.OnClickCheckBoxCommandInfo
// 0x0001 (0x0001 - 0x0000)
struct MM_Occupation_SituationBoard_OnClickCheckBoxCommandInfo final
{
public:
	bool                                          Checked;                                           // 0x0000(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(MM_Occupation_SituationBoard_OnClickCheckBoxCommandInfo) == 0x000001, "Wrong alignment on MM_Occupation_SituationBoard_OnClickCheckBoxCommandInfo");
static_assert(sizeof(MM_Occupation_SituationBoard_OnClickCheckBoxCommandInfo) == 0x000001, "Wrong size on MM_Occupation_SituationBoard_OnClickCheckBoxCommandInfo");
static_assert(offsetof(MM_Occupation_SituationBoard_OnClickCheckBoxCommandInfo, Checked) == 0x000000, "Member 'MM_Occupation_SituationBoard_OnClickCheckBoxCommandInfo::Checked' has a wrong offset!");

// Function MirMobile.MM_Party_ExplainTextField.OnChangeTextPartyExplain
// 0x0018 (0x0018 - 0x0000)
struct MM_Party_ExplainTextField_OnChangeTextPartyExplain final
{
public:
	class FText                                   Text;                                              // 0x0000(0x0018)(ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
};
static_assert(alignof(MM_Party_ExplainTextField_OnChangeTextPartyExplain) == 0x000008, "Wrong alignment on MM_Party_ExplainTextField_OnChangeTextPartyExplain");
static_assert(sizeof(MM_Party_ExplainTextField_OnChangeTextPartyExplain) == 0x000018, "Wrong size on MM_Party_ExplainTextField_OnChangeTextPartyExplain");
static_assert(offsetof(MM_Party_ExplainTextField_OnChangeTextPartyExplain, Text) == 0x000000, "Member 'MM_Party_ExplainTextField_OnChangeTextPartyExplain::Text' has a wrong offset!");

// Function MirMobile.MM_Party_ExplainTextField.OnComboBoxChanged
// 0x0010 (0x0010 - 0x0000)
struct MM_Party_ExplainTextField_OnComboBoxChanged final
{
public:
	class FString                                 StrSelectItem;                                     // 0x0000(0x0010)(Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(MM_Party_ExplainTextField_OnComboBoxChanged) == 0x000008, "Wrong alignment on MM_Party_ExplainTextField_OnComboBoxChanged");
static_assert(sizeof(MM_Party_ExplainTextField_OnComboBoxChanged) == 0x000010, "Wrong size on MM_Party_ExplainTextField_OnComboBoxChanged");
static_assert(offsetof(MM_Party_ExplainTextField_OnComboBoxChanged, StrSelectItem) == 0x000000, "Member 'MM_Party_ExplainTextField_OnComboBoxChanged::StrSelectItem' has a wrong offset!");

// Function MirMobile.MM_Party_ExplainTextField.OnTextPartyExplainCommitted
// 0x0020 (0x0020 - 0x0000)
struct MM_Party_ExplainTextField_OnTextPartyExplainCommitted final
{
public:
	class FText                                   Text;                                              // 0x0000(0x0018)(ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
	ETextCommit                                   CommitMethod;                                      // 0x0018(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_19[0x7];                                       // 0x0019(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(MM_Party_ExplainTextField_OnTextPartyExplainCommitted) == 0x000008, "Wrong alignment on MM_Party_ExplainTextField_OnTextPartyExplainCommitted");
static_assert(sizeof(MM_Party_ExplainTextField_OnTextPartyExplainCommitted) == 0x000020, "Wrong size on MM_Party_ExplainTextField_OnTextPartyExplainCommitted");
static_assert(offsetof(MM_Party_ExplainTextField_OnTextPartyExplainCommitted, Text) == 0x000000, "Member 'MM_Party_ExplainTextField_OnTextPartyExplainCommitted::Text' has a wrong offset!");
static_assert(offsetof(MM_Party_ExplainTextField_OnTextPartyExplainCommitted, CommitMethod) == 0x000018, "Member 'MM_Party_ExplainTextField_OnTextPartyExplainCommitted::CommitMethod' has a wrong offset!");

// Function MirMobile.MM_Popup_GiftGive.OnClickFriendsTab
// 0x0001 (0x0001 - 0x0000)
struct MM_Popup_GiftGive_OnClickFriendsTab final
{
public:
	bool                                          IsChecked;                                         // 0x0000(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(MM_Popup_GiftGive_OnClickFriendsTab) == 0x000001, "Wrong alignment on MM_Popup_GiftGive_OnClickFriendsTab");
static_assert(sizeof(MM_Popup_GiftGive_OnClickFriendsTab) == 0x000001, "Wrong size on MM_Popup_GiftGive_OnClickFriendsTab");
static_assert(offsetof(MM_Popup_GiftGive_OnClickFriendsTab, IsChecked) == 0x000000, "Member 'MM_Popup_GiftGive_OnClickFriendsTab::IsChecked' has a wrong offset!");

// Function MirMobile.MM_Popup_GiftGive.OnClickGuildeMembersTab
// 0x0001 (0x0001 - 0x0000)
struct MM_Popup_GiftGive_OnClickGuildeMembersTab final
{
public:
	bool                                          IsChecked;                                         // 0x0000(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(MM_Popup_GiftGive_OnClickGuildeMembersTab) == 0x000001, "Wrong alignment on MM_Popup_GiftGive_OnClickGuildeMembersTab");
static_assert(sizeof(MM_Popup_GiftGive_OnClickGuildeMembersTab) == 0x000001, "Wrong size on MM_Popup_GiftGive_OnClickGuildeMembersTab");
static_assert(offsetof(MM_Popup_GiftGive_OnClickGuildeMembersTab, IsChecked) == 0x000000, "Member 'MM_Popup_GiftGive_OnClickGuildeMembersTab::IsChecked' has a wrong offset!");

// Function MirMobile.MM_Popup_GiftGive.OnClickOtherMembersTab
// 0x0001 (0x0001 - 0x0000)
struct MM_Popup_GiftGive_OnClickOtherMembersTab final
{
public:
	bool                                          IsChecked;                                         // 0x0000(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(MM_Popup_GiftGive_OnClickOtherMembersTab) == 0x000001, "Wrong alignment on MM_Popup_GiftGive_OnClickOtherMembersTab");
static_assert(sizeof(MM_Popup_GiftGive_OnClickOtherMembersTab) == 0x000001, "Wrong size on MM_Popup_GiftGive_OnClickOtherMembersTab");
static_assert(offsetof(MM_Popup_GiftGive_OnClickOtherMembersTab, IsChecked) == 0x000000, "Member 'MM_Popup_GiftGive_OnClickOtherMembersTab::IsChecked' has a wrong offset!");

// Function MirMobile.MM_Popup_GiftGive.OnClickSortCheckBox
// 0x0001 (0x0001 - 0x0000)
struct MM_Popup_GiftGive_OnClickSortCheckBox final
{
public:
	bool                                          IsChecked;                                         // 0x0000(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(MM_Popup_GiftGive_OnClickSortCheckBox) == 0x000001, "Wrong alignment on MM_Popup_GiftGive_OnClickSortCheckBox");
static_assert(sizeof(MM_Popup_GiftGive_OnClickSortCheckBox) == 0x000001, "Wrong size on MM_Popup_GiftGive_OnClickSortCheckBox");
static_assert(offsetof(MM_Popup_GiftGive_OnClickSortCheckBox, IsChecked) == 0x000000, "Member 'MM_Popup_GiftGive_OnClickSortCheckBox::IsChecked' has a wrong offset!");

// Function MirMobile.MM_Pass_Reward_Slot.OnClickSlot
// 0x0008 (0x0008 - 0x0000)
struct MM_Pass_Reward_Slot_OnClickSlot final
{
public:
	class UMM_Slot_Base*                          PSlot;                                             // 0x0000(0x0008)(Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(MM_Pass_Reward_Slot_OnClickSlot) == 0x000008, "Wrong alignment on MM_Pass_Reward_Slot_OnClickSlot");
static_assert(sizeof(MM_Pass_Reward_Slot_OnClickSlot) == 0x000008, "Wrong size on MM_Pass_Reward_Slot_OnClickSlot");
static_assert(offsetof(MM_Pass_Reward_Slot_OnClickSlot, PSlot) == 0x000000, "Member 'MM_Pass_Reward_Slot_OnClickSlot::PSlot' has a wrong offset!");

// Function MirMobile.MM_Popup_GuestContinue.OnCommitEditCode
// 0x0020 (0x0020 - 0x0000)
struct MM_Popup_GuestContinue_OnCommitEditCode final
{
public:
	class FText                                   Text;                                              // 0x0000(0x0018)(ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
	ETextCommit                                   CommitMethod;                                      // 0x0018(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_19[0x7];                                       // 0x0019(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(MM_Popup_GuestContinue_OnCommitEditCode) == 0x000008, "Wrong alignment on MM_Popup_GuestContinue_OnCommitEditCode");
static_assert(sizeof(MM_Popup_GuestContinue_OnCommitEditCode) == 0x000020, "Wrong size on MM_Popup_GuestContinue_OnCommitEditCode");
static_assert(offsetof(MM_Popup_GuestContinue_OnCommitEditCode, Text) == 0x000000, "Member 'MM_Popup_GuestContinue_OnCommitEditCode::Text' has a wrong offset!");
static_assert(offsetof(MM_Popup_GuestContinue_OnCommitEditCode, CommitMethod) == 0x000018, "Member 'MM_Popup_GuestContinue_OnCommitEditCode::CommitMethod' has a wrong offset!");

// Function MirMobile.MM_Popup_GuestContinue.OnCommitEditPassword
// 0x0020 (0x0020 - 0x0000)
struct MM_Popup_GuestContinue_OnCommitEditPassword final
{
public:
	class FText                                   Text;                                              // 0x0000(0x0018)(ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
	ETextCommit                                   CommitMethod;                                      // 0x0018(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_19[0x7];                                       // 0x0019(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(MM_Popup_GuestContinue_OnCommitEditPassword) == 0x000008, "Wrong alignment on MM_Popup_GuestContinue_OnCommitEditPassword");
static_assert(sizeof(MM_Popup_GuestContinue_OnCommitEditPassword) == 0x000020, "Wrong size on MM_Popup_GuestContinue_OnCommitEditPassword");
static_assert(offsetof(MM_Popup_GuestContinue_OnCommitEditPassword, Text) == 0x000000, "Member 'MM_Popup_GuestContinue_OnCommitEditPassword::Text' has a wrong offset!");
static_assert(offsetof(MM_Popup_GuestContinue_OnCommitEditPassword, CommitMethod) == 0x000018, "Member 'MM_Popup_GuestContinue_OnCommitEditPassword::CommitMethod' has a wrong offset!");

// Function MirMobile.MM_Popup_GuestContinue.OnGuestRestoreComplete
// 0x0018 (0x0018 - 0x0000)
struct MM_Popup_GuestContinue_OnGuestRestoreComplete final
{
public:
	bool                                          Success;                                           // 0x0000(0x0001)(ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1[0x7];                                        // 0x0001(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	class FString                                 Message;                                           // 0x0008(0x0010)(Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(MM_Popup_GuestContinue_OnGuestRestoreComplete) == 0x000008, "Wrong alignment on MM_Popup_GuestContinue_OnGuestRestoreComplete");
static_assert(sizeof(MM_Popup_GuestContinue_OnGuestRestoreComplete) == 0x000018, "Wrong size on MM_Popup_GuestContinue_OnGuestRestoreComplete");
static_assert(offsetof(MM_Popup_GuestContinue_OnGuestRestoreComplete, Success) == 0x000000, "Member 'MM_Popup_GuestContinue_OnGuestRestoreComplete::Success' has a wrong offset!");
static_assert(offsetof(MM_Popup_GuestContinue_OnGuestRestoreComplete, Message) == 0x000008, "Member 'MM_Popup_GuestContinue_OnGuestRestoreComplete::Message' has a wrong offset!");

// Function MirMobile.MM_Popup_GuestContinue.OnTextCommitted
// 0x0020 (0x0020 - 0x0000)
struct MM_Popup_GuestContinue_OnTextCommitted final
{
public:
	class FText                                   Text_;                                             // 0x0000(0x0018)(ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
	ETextCommit                                   Commit_method_;                                    // 0x0018(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_19[0x7];                                       // 0x0019(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(MM_Popup_GuestContinue_OnTextCommitted) == 0x000008, "Wrong alignment on MM_Popup_GuestContinue_OnTextCommitted");
static_assert(sizeof(MM_Popup_GuestContinue_OnTextCommitted) == 0x000020, "Wrong size on MM_Popup_GuestContinue_OnTextCommitted");
static_assert(offsetof(MM_Popup_GuestContinue_OnTextCommitted, Text_) == 0x000000, "Member 'MM_Popup_GuestContinue_OnTextCommitted::Text_' has a wrong offset!");
static_assert(offsetof(MM_Popup_GuestContinue_OnTextCommitted, Commit_method_) == 0x000018, "Member 'MM_Popup_GuestContinue_OnTextCommitted::Commit_method_' has a wrong offset!");

// Function MirMobile.MM_PawnMovementComponent.GetMovementMode
// 0x0001 (0x0001 - 0x0000)
struct MM_PawnMovementComponent_GetMovementMode final
{
public:
	EMovementMode                                 ReturnValue;                                       // 0x0000(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(MM_PawnMovementComponent_GetMovementMode) == 0x000001, "Wrong alignment on MM_PawnMovementComponent_GetMovementMode");
static_assert(sizeof(MM_PawnMovementComponent_GetMovementMode) == 0x000001, "Wrong size on MM_PawnMovementComponent_GetMovementMode");
static_assert(offsetof(MM_PawnMovementComponent_GetMovementMode, ReturnValue) == 0x000000, "Member 'MM_PawnMovementComponent_GetMovementMode::ReturnValue' has a wrong offset!");

// Function MirMobile.MM_PawnMovementComponent.SetMovementMode
// 0x0002 (0x0002 - 0x0000)
struct MM_PawnMovementComponent_SetMovementMode final
{
public:
	EMovementMode                                 NewMovementMode;                                   // 0x0000(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         NewCustomMode;                                     // 0x0001(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(MM_PawnMovementComponent_SetMovementMode) == 0x000001, "Wrong alignment on MM_PawnMovementComponent_SetMovementMode");
static_assert(sizeof(MM_PawnMovementComponent_SetMovementMode) == 0x000002, "Wrong size on MM_PawnMovementComponent_SetMovementMode");
static_assert(offsetof(MM_PawnMovementComponent_SetMovementMode, NewMovementMode) == 0x000000, "Member 'MM_PawnMovementComponent_SetMovementMode::NewMovementMode' has a wrong offset!");
static_assert(offsetof(MM_PawnMovementComponent_SetMovementMode, NewCustomMode) == 0x000001, "Member 'MM_PawnMovementComponent_SetMovementMode::NewCustomMode' has a wrong offset!");

// Function MirMobile.MM_UIShopShoppingBagSlot.OnClickCheckBox
// 0x0001 (0x0001 - 0x0000)
struct MM_UIShopShoppingBagSlot_OnClickCheckBox final
{
public:
	bool                                          Checked;                                           // 0x0000(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(MM_UIShopShoppingBagSlot_OnClickCheckBox) == 0x000001, "Wrong alignment on MM_UIShopShoppingBagSlot_OnClickCheckBox");
static_assert(sizeof(MM_UIShopShoppingBagSlot_OnClickCheckBox) == 0x000001, "Wrong size on MM_UIShopShoppingBagSlot_OnClickCheckBox");
static_assert(offsetof(MM_UIShopShoppingBagSlot_OnClickCheckBox, Checked) == 0x000000, "Member 'MM_UIShopShoppingBagSlot_OnClickCheckBox::Checked' has a wrong offset!");

// Function MirMobile.MM_UIShopShoppingBagSlot.SetCurValueReturn
// 0x0008 (0x0008 - 0x0000)
struct MM_UIShopShoppingBagSlot_SetCurValueReturn final
{
public:
	int64                                         Value;                                             // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(MM_UIShopShoppingBagSlot_SetCurValueReturn) == 0x000008, "Wrong alignment on MM_UIShopShoppingBagSlot_SetCurValueReturn");
static_assert(sizeof(MM_UIShopShoppingBagSlot_SetCurValueReturn) == 0x000008, "Wrong size on MM_UIShopShoppingBagSlot_SetCurValueReturn");
static_assert(offsetof(MM_UIShopShoppingBagSlot_SetCurValueReturn, Value) == 0x000000, "Member 'MM_UIShopShoppingBagSlot_SetCurValueReturn::Value' has a wrong offset!");

// Function MirMobile.MM_PhotoModeCharacter.SaveAndroidTextureEvent
// 0x0018 (0x0018 - 0x0000)
struct MM_PhotoModeCharacter_SaveAndroidTextureEvent final
{
public:
	class UTexture2D*                             ScreenShotTexture;                                 // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 Filename;                                          // 0x0008(0x0010)(Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(MM_PhotoModeCharacter_SaveAndroidTextureEvent) == 0x000008, "Wrong alignment on MM_PhotoModeCharacter_SaveAndroidTextureEvent");
static_assert(sizeof(MM_PhotoModeCharacter_SaveAndroidTextureEvent) == 0x000018, "Wrong size on MM_PhotoModeCharacter_SaveAndroidTextureEvent");
static_assert(offsetof(MM_PhotoModeCharacter_SaveAndroidTextureEvent, ScreenShotTexture) == 0x000000, "Member 'MM_PhotoModeCharacter_SaveAndroidTextureEvent::ScreenShotTexture' has a wrong offset!");
static_assert(offsetof(MM_PhotoModeCharacter_SaveAndroidTextureEvent, Filename) == 0x000008, "Member 'MM_PhotoModeCharacter_SaveAndroidTextureEvent::Filename' has a wrong offset!");

// Function MirMobile.MM_PhotoModeCharacter.ScreenShotCaptured
// 0x0018 (0x0018 - 0x0000)
struct MM_PhotoModeCharacter_ScreenShotCaptured final
{
public:
	int32                                         ScreenWidth;                                       // 0x0000(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         ScreenHeight;                                      // 0x0004(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<struct FColor>                         ScreenColors;                                      // 0x0008(0x0010)(ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, NativeAccessSpecifierPublic)
};
static_assert(alignof(MM_PhotoModeCharacter_ScreenShotCaptured) == 0x000008, "Wrong alignment on MM_PhotoModeCharacter_ScreenShotCaptured");
static_assert(sizeof(MM_PhotoModeCharacter_ScreenShotCaptured) == 0x000018, "Wrong size on MM_PhotoModeCharacter_ScreenShotCaptured");
static_assert(offsetof(MM_PhotoModeCharacter_ScreenShotCaptured, ScreenWidth) == 0x000000, "Member 'MM_PhotoModeCharacter_ScreenShotCaptured::ScreenWidth' has a wrong offset!");
static_assert(offsetof(MM_PhotoModeCharacter_ScreenShotCaptured, ScreenHeight) == 0x000004, "Member 'MM_PhotoModeCharacter_ScreenShotCaptured::ScreenHeight' has a wrong offset!");
static_assert(offsetof(MM_PhotoModeCharacter_ScreenShotCaptured, ScreenColors) == 0x000008, "Member 'MM_PhotoModeCharacter_ScreenShotCaptured::ScreenColors' has a wrong offset!");

// Function MirMobile.MM_PhotoModeWidget.CreateSubButtonEvent
// 0x0004 (0x0004 - 0x0000)
struct MM_PhotoModeWidget_CreateSubButtonEvent final
{
public:
	int32                                         CreateCount;                                       // 0x0000(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(MM_PhotoModeWidget_CreateSubButtonEvent) == 0x000004, "Wrong alignment on MM_PhotoModeWidget_CreateSubButtonEvent");
static_assert(sizeof(MM_PhotoModeWidget_CreateSubButtonEvent) == 0x000004, "Wrong size on MM_PhotoModeWidget_CreateSubButtonEvent");
static_assert(offsetof(MM_PhotoModeWidget_CreateSubButtonEvent, CreateCount) == 0x000000, "Member 'MM_PhotoModeWidget_CreateSubButtonEvent::CreateCount' has a wrong offset!");

// Function MirMobile.MM_PhotoModeWidget.OnCameraMoveButton
// 0x0002 (0x0002 - 0x0000)
struct MM_PhotoModeWidget_OnCameraMoveButton final
{
public:
	EPhotoModeCameraMoveButton                    ClickButton;                                       // 0x0000(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bPressed;                                          // 0x0001(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(MM_PhotoModeWidget_OnCameraMoveButton) == 0x000001, "Wrong alignment on MM_PhotoModeWidget_OnCameraMoveButton");
static_assert(sizeof(MM_PhotoModeWidget_OnCameraMoveButton) == 0x000002, "Wrong size on MM_PhotoModeWidget_OnCameraMoveButton");
static_assert(offsetof(MM_PhotoModeWidget_OnCameraMoveButton, ClickButton) == 0x000000, "Member 'MM_PhotoModeWidget_OnCameraMoveButton::ClickButton' has a wrong offset!");
static_assert(offsetof(MM_PhotoModeWidget_OnCameraMoveButton, bPressed) == 0x000001, "Member 'MM_PhotoModeWidget_OnCameraMoveButton::bPressed' has a wrong offset!");

// Function MirMobile.MM_PhotoModeWidget.OnChangedSliderValue
// 0x0004 (0x0004 - 0x0000)
struct MM_PhotoModeWidget_OnChangedSliderValue final
{
public:
	float                                         SliderValue;                                       // 0x0000(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(MM_PhotoModeWidget_OnChangedSliderValue) == 0x000004, "Wrong alignment on MM_PhotoModeWidget_OnChangedSliderValue");
static_assert(sizeof(MM_PhotoModeWidget_OnChangedSliderValue) == 0x000004, "Wrong size on MM_PhotoModeWidget_OnChangedSliderValue");
static_assert(offsetof(MM_PhotoModeWidget_OnChangedSliderValue, SliderValue) == 0x000000, "Member 'MM_PhotoModeWidget_OnChangedSliderValue::SliderValue' has a wrong offset!");

// Function MirMobile.MM_PhotoModeWidget.OnCheckeOption
// 0x0002 (0x0002 - 0x0000)
struct MM_PhotoModeWidget_OnCheckeOption final
{
public:
	EPhotoModeOptionType                          CheckOption;                                       // 0x0000(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bChecked;                                          // 0x0001(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(MM_PhotoModeWidget_OnCheckeOption) == 0x000001, "Wrong alignment on MM_PhotoModeWidget_OnCheckeOption");
static_assert(sizeof(MM_PhotoModeWidget_OnCheckeOption) == 0x000002, "Wrong size on MM_PhotoModeWidget_OnCheckeOption");
static_assert(offsetof(MM_PhotoModeWidget_OnCheckeOption, CheckOption) == 0x000000, "Member 'MM_PhotoModeWidget_OnCheckeOption::CheckOption' has a wrong offset!");
static_assert(offsetof(MM_PhotoModeWidget_OnCheckeOption, bChecked) == 0x000001, "Member 'MM_PhotoModeWidget_OnCheckeOption::bChecked' has a wrong offset!");

// Function MirMobile.MM_PhotoModeWidget.OnClickMainButton
// 0x0002 (0x0002 - 0x0000)
struct MM_PhotoModeWidget_OnClickMainButton final
{
public:
	EPhotoModeType                                ClickPhotoModeState;                               // 0x0000(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bChecked;                                          // 0x0001(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(MM_PhotoModeWidget_OnClickMainButton) == 0x000001, "Wrong alignment on MM_PhotoModeWidget_OnClickMainButton");
static_assert(sizeof(MM_PhotoModeWidget_OnClickMainButton) == 0x000002, "Wrong size on MM_PhotoModeWidget_OnClickMainButton");
static_assert(offsetof(MM_PhotoModeWidget_OnClickMainButton, ClickPhotoModeState) == 0x000000, "Member 'MM_PhotoModeWidget_OnClickMainButton::ClickPhotoModeState' has a wrong offset!");
static_assert(offsetof(MM_PhotoModeWidget_OnClickMainButton, bChecked) == 0x000001, "Member 'MM_PhotoModeWidget_OnClickMainButton::bChecked' has a wrong offset!");

// Function MirMobile.MM_PhotoModeWidget.OnClickOptionSave
// 0x0001 (0x0001 - 0x0000)
struct MM_PhotoModeWidget_OnClickOptionSave final
{
public:
	bool                                          bSave;                                             // 0x0000(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(MM_PhotoModeWidget_OnClickOptionSave) == 0x000001, "Wrong alignment on MM_PhotoModeWidget_OnClickOptionSave");
static_assert(sizeof(MM_PhotoModeWidget_OnClickOptionSave) == 0x000001, "Wrong size on MM_PhotoModeWidget_OnClickOptionSave");
static_assert(offsetof(MM_PhotoModeWidget_OnClickOptionSave, bSave) == 0x000000, "Member 'MM_PhotoModeWidget_OnClickOptionSave::bSave' has a wrong offset!");

// Function MirMobile.MM_PhotoModeWidget.OnClickSubButton
// 0x0008 (0x0008 - 0x0000)
struct MM_PhotoModeWidget_OnClickSubButton final
{
public:
	EPhotoModeType                                PhotoModeState;                                    // 0x0000(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1[0x3];                                        // 0x0001(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         SlotIndex;                                         // 0x0004(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(MM_PhotoModeWidget_OnClickSubButton) == 0x000004, "Wrong alignment on MM_PhotoModeWidget_OnClickSubButton");
static_assert(sizeof(MM_PhotoModeWidget_OnClickSubButton) == 0x000008, "Wrong size on MM_PhotoModeWidget_OnClickSubButton");
static_assert(offsetof(MM_PhotoModeWidget_OnClickSubButton, PhotoModeState) == 0x000000, "Member 'MM_PhotoModeWidget_OnClickSubButton::PhotoModeState' has a wrong offset!");
static_assert(offsetof(MM_PhotoModeWidget_OnClickSubButton, SlotIndex) == 0x000004, "Member 'MM_PhotoModeWidget_OnClickSubButton::SlotIndex' has a wrong offset!");

// Function MirMobile.MM_PhotoModeWidget.SetFilterSubButtonEvent
// 0x0020 (0x0020 - 0x0000)
struct MM_PhotoModeWidget_SetFilterSubButtonEvent final
{
public:
	TArray<struct FColor>                         ColorList;                                         // 0x0000(0x0010)(ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, NativeAccessSpecifierPublic)
	TArray<class FText>                           StringList;                                        // 0x0010(0x0010)(ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, NativeAccessSpecifierPublic)
};
static_assert(alignof(MM_PhotoModeWidget_SetFilterSubButtonEvent) == 0x000008, "Wrong alignment on MM_PhotoModeWidget_SetFilterSubButtonEvent");
static_assert(sizeof(MM_PhotoModeWidget_SetFilterSubButtonEvent) == 0x000020, "Wrong size on MM_PhotoModeWidget_SetFilterSubButtonEvent");
static_assert(offsetof(MM_PhotoModeWidget_SetFilterSubButtonEvent, ColorList) == 0x000000, "Member 'MM_PhotoModeWidget_SetFilterSubButtonEvent::ColorList' has a wrong offset!");
static_assert(offsetof(MM_PhotoModeWidget_SetFilterSubButtonEvent, StringList) == 0x000010, "Member 'MM_PhotoModeWidget_SetFilterSubButtonEvent::StringList' has a wrong offset!");

// Function MirMobile.MM_PhotoModeWidget.SetOptionDataEvent
// 0x0050 (0x0050 - 0x0000)
struct MM_PhotoModeWidget_SetOptionDataEvent final
{
public:
	TMap<EPhotoModeOptionType, struct FPhotoMode_Option> MapOption;                                         // 0x0000(0x0050)(ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, NativeAccessSpecifierPublic)
};
static_assert(alignof(MM_PhotoModeWidget_SetOptionDataEvent) == 0x000008, "Wrong alignment on MM_PhotoModeWidget_SetOptionDataEvent");
static_assert(sizeof(MM_PhotoModeWidget_SetOptionDataEvent) == 0x000050, "Wrong size on MM_PhotoModeWidget_SetOptionDataEvent");
static_assert(offsetof(MM_PhotoModeWidget_SetOptionDataEvent, MapOption) == 0x000000, "Member 'MM_PhotoModeWidget_SetOptionDataEvent::MapOption' has a wrong offset!");

// Function MirMobile.MM_PhotoModeWidget.SetPoseSubButtonEvent
// 0x0010 (0x0010 - 0x0000)
struct MM_PhotoModeWidget_SetPoseSubButtonEvent final
{
public:
	TArray<class FString>                         IconPathList;                                      // 0x0000(0x0010)(ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, NativeAccessSpecifierPublic)
};
static_assert(alignof(MM_PhotoModeWidget_SetPoseSubButtonEvent) == 0x000008, "Wrong alignment on MM_PhotoModeWidget_SetPoseSubButtonEvent");
static_assert(sizeof(MM_PhotoModeWidget_SetPoseSubButtonEvent) == 0x000010, "Wrong size on MM_PhotoModeWidget_SetPoseSubButtonEvent");
static_assert(offsetof(MM_PhotoModeWidget_SetPoseSubButtonEvent, IconPathList) == 0x000000, "Member 'MM_PhotoModeWidget_SetPoseSubButtonEvent::IconPathList' has a wrong offset!");

// Function MirMobile.MM_PhotoModeWidget.SetSliderDataEvent
// 0x0038 (0x0038 - 0x0000)
struct MM_PhotoModeWidget_SetSliderDataEvent final
{
public:
	class FText                                   SubTapTitle;                                       // 0x0000(0x0018)(ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
	class FText                                   Text_SliderValue;                                  // 0x0018(0x0018)(ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
	float                                         SlideValue;                                        // 0x0030(0x0004)(ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_34[0x4];                                       // 0x0034(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(MM_PhotoModeWidget_SetSliderDataEvent) == 0x000008, "Wrong alignment on MM_PhotoModeWidget_SetSliderDataEvent");
static_assert(sizeof(MM_PhotoModeWidget_SetSliderDataEvent) == 0x000038, "Wrong size on MM_PhotoModeWidget_SetSliderDataEvent");
static_assert(offsetof(MM_PhotoModeWidget_SetSliderDataEvent, SubTapTitle) == 0x000000, "Member 'MM_PhotoModeWidget_SetSliderDataEvent::SubTapTitle' has a wrong offset!");
static_assert(offsetof(MM_PhotoModeWidget_SetSliderDataEvent, Text_SliderValue) == 0x000018, "Member 'MM_PhotoModeWidget_SetSliderDataEvent::Text_SliderValue' has a wrong offset!");
static_assert(offsetof(MM_PhotoModeWidget_SetSliderDataEvent, SlideValue) == 0x000030, "Member 'MM_PhotoModeWidget_SetSliderDataEvent::SlideValue' has a wrong offset!");

// Function MirMobile.MM_PhotoModeWidget.ShowLogoImageEvent
// 0x0001 (0x0001 - 0x0000)
struct MM_PhotoModeWidget_ShowLogoImageEvent final
{
public:
	bool                                          bShow;                                             // 0x0000(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(MM_PhotoModeWidget_ShowLogoImageEvent) == 0x000001, "Wrong alignment on MM_PhotoModeWidget_ShowLogoImageEvent");
static_assert(sizeof(MM_PhotoModeWidget_ShowLogoImageEvent) == 0x000001, "Wrong size on MM_PhotoModeWidget_ShowLogoImageEvent");
static_assert(offsetof(MM_PhotoModeWidget_ShowLogoImageEvent, bShow) == 0x000000, "Member 'MM_PhotoModeWidget_ShowLogoImageEvent::bShow' has a wrong offset!");

// Function MirMobile.MM_PhotoModeWidget.ShowSlideControlEvent
// 0x0001 (0x0001 - 0x0000)
struct MM_PhotoModeWidget_ShowSlideControlEvent final
{
public:
	bool                                          bShow;                                             // 0x0000(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(MM_PhotoModeWidget_ShowSlideControlEvent) == 0x000001, "Wrong alignment on MM_PhotoModeWidget_ShowSlideControlEvent");
static_assert(sizeof(MM_PhotoModeWidget_ShowSlideControlEvent) == 0x000001, "Wrong size on MM_PhotoModeWidget_ShowSlideControlEvent");
static_assert(offsetof(MM_PhotoModeWidget_ShowSlideControlEvent, bShow) == 0x000000, "Member 'MM_PhotoModeWidget_ShowSlideControlEvent::bShow' has a wrong offset!");

// Function MirMobile.MM_PhotoModeWidget.ShowSubButton
// 0x0028 (0x0028 - 0x0000)
struct MM_PhotoModeWidget_ShowSubButton final
{
public:
	int32                                         ButtonLength;                                      // 0x0000(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_4[0x4];                                        // 0x0004(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<class UWidget*>                        ButtonArray;                                       // 0x0008(0x0010)(Parm, ZeroConstructor, ContainsInstancedReference, NativeAccessSpecifierPublic)
	TArray<class UWidget*>                        ReturnValue;                                       // 0x0018(0x0010)(ExportObject, Parm, OutParm, ZeroConstructor, ReturnParm, ContainsInstancedReference, NativeAccessSpecifierPublic)
};
static_assert(alignof(MM_PhotoModeWidget_ShowSubButton) == 0x000008, "Wrong alignment on MM_PhotoModeWidget_ShowSubButton");
static_assert(sizeof(MM_PhotoModeWidget_ShowSubButton) == 0x000028, "Wrong size on MM_PhotoModeWidget_ShowSubButton");
static_assert(offsetof(MM_PhotoModeWidget_ShowSubButton, ButtonLength) == 0x000000, "Member 'MM_PhotoModeWidget_ShowSubButton::ButtonLength' has a wrong offset!");
static_assert(offsetof(MM_PhotoModeWidget_ShowSubButton, ButtonArray) == 0x000008, "Member 'MM_PhotoModeWidget_ShowSubButton::ButtonArray' has a wrong offset!");
static_assert(offsetof(MM_PhotoModeWidget_ShowSubButton, ReturnValue) == 0x000018, "Member 'MM_PhotoModeWidget_ShowSubButton::ReturnValue' has a wrong offset!");

// Function MirMobile.MM_PhotoModeWidget.ShowSubButtonEvent
// 0x0028 (0x0028 - 0x0000)
struct MM_PhotoModeWidget_ShowSubButtonEvent final
{
public:
	class FText                                   SubTapTitle;                                       // 0x0000(0x0018)(ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
	EPhotoModeType                                PhotoModeState;                                    // 0x0018(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_19[0x3];                                       // 0x0019(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         SubButtonCount;                                    // 0x001C(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         SelectedButtonIndex;                               // 0x0020(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_24[0x4];                                       // 0x0024(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(MM_PhotoModeWidget_ShowSubButtonEvent) == 0x000008, "Wrong alignment on MM_PhotoModeWidget_ShowSubButtonEvent");
static_assert(sizeof(MM_PhotoModeWidget_ShowSubButtonEvent) == 0x000028, "Wrong size on MM_PhotoModeWidget_ShowSubButtonEvent");
static_assert(offsetof(MM_PhotoModeWidget_ShowSubButtonEvent, SubTapTitle) == 0x000000, "Member 'MM_PhotoModeWidget_ShowSubButtonEvent::SubTapTitle' has a wrong offset!");
static_assert(offsetof(MM_PhotoModeWidget_ShowSubButtonEvent, PhotoModeState) == 0x000018, "Member 'MM_PhotoModeWidget_ShowSubButtonEvent::PhotoModeState' has a wrong offset!");
static_assert(offsetof(MM_PhotoModeWidget_ShowSubButtonEvent, SubButtonCount) == 0x00001C, "Member 'MM_PhotoModeWidget_ShowSubButtonEvent::SubButtonCount' has a wrong offset!");
static_assert(offsetof(MM_PhotoModeWidget_ShowSubButtonEvent, SelectedButtonIndex) == 0x000020, "Member 'MM_PhotoModeWidget_ShowSubButtonEvent::SelectedButtonIndex' has a wrong offset!");

// Function MirMobile.MM_PhotoModeWidget.ShowSubTapEvent
// 0x0001 (0x0001 - 0x0000)
struct MM_PhotoModeWidget_ShowSubTapEvent final
{
public:
	bool                                          bShow;                                             // 0x0000(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(MM_PhotoModeWidget_ShowSubTapEvent) == 0x000001, "Wrong alignment on MM_PhotoModeWidget_ShowSubTapEvent");
static_assert(sizeof(MM_PhotoModeWidget_ShowSubTapEvent) == 0x000001, "Wrong size on MM_PhotoModeWidget_ShowSubTapEvent");
static_assert(offsetof(MM_PhotoModeWidget_ShowSubTapEvent, bShow) == 0x000000, "Member 'MM_PhotoModeWidget_ShowSubTapEvent::bShow' has a wrong offset!");

// Function MirMobile.MM_PhotoModeWidget.UpdateSliderValueEvent
// 0x0018 (0x0018 - 0x0000)
struct MM_PhotoModeWidget_UpdateSliderValueEvent final
{
public:
	class FText                                   Text_SliderValue;                                  // 0x0000(0x0018)(ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
};
static_assert(alignof(MM_PhotoModeWidget_UpdateSliderValueEvent) == 0x000008, "Wrong alignment on MM_PhotoModeWidget_UpdateSliderValueEvent");
static_assert(sizeof(MM_PhotoModeWidget_UpdateSliderValueEvent) == 0x000018, "Wrong size on MM_PhotoModeWidget_UpdateSliderValueEvent");
static_assert(offsetof(MM_PhotoModeWidget_UpdateSliderValueEvent, Text_SliderValue) == 0x000000, "Member 'MM_PhotoModeWidget_UpdateSliderValueEvent::Text_SliderValue' has a wrong offset!");

// Function MirMobile.MM_PKMode.OnCheckStateChangedOnlyUserTarget
// 0x0001 (0x0001 - 0x0000)
struct MM_PKMode_OnCheckStateChangedOnlyUserTarget final
{
public:
	bool                                          IsChecked;                                         // 0x0000(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(MM_PKMode_OnCheckStateChangedOnlyUserTarget) == 0x000001, "Wrong alignment on MM_PKMode_OnCheckStateChangedOnlyUserTarget");
static_assert(sizeof(MM_PKMode_OnCheckStateChangedOnlyUserTarget) == 0x000001, "Wrong size on MM_PKMode_OnCheckStateChangedOnlyUserTarget");
static_assert(offsetof(MM_PKMode_OnCheckStateChangedOnlyUserTarget, IsChecked) == 0x000000, "Member 'MM_PKMode_OnCheckStateChangedOnlyUserTarget::IsChecked' has a wrong offset!");

// Function MirMobile.MM_PKMode.OnClickMain_Status
// 0x0010 (0x0010 - 0x0000)
struct MM_PKMode_OnClickMain_Status final
{
public:
	int32                                         StatusId;                                          // 0x0000(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_4[0x4];                                        // 0x0004(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class UMM_Option_Ability*                     PRefWidget;                                        // 0x0008(0x0008)(Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(MM_PKMode_OnClickMain_Status) == 0x000008, "Wrong alignment on MM_PKMode_OnClickMain_Status");
static_assert(sizeof(MM_PKMode_OnClickMain_Status) == 0x000010, "Wrong size on MM_PKMode_OnClickMain_Status");
static_assert(offsetof(MM_PKMode_OnClickMain_Status, StatusId) == 0x000000, "Member 'MM_PKMode_OnClickMain_Status::StatusId' has a wrong offset!");
static_assert(offsetof(MM_PKMode_OnClickMain_Status, PRefWidget) == 0x000008, "Member 'MM_PKMode_OnClickMain_Status::PRefWidget' has a wrong offset!");

// Function MirMobile.MM_PKMode.OnScrollEvent
// 0x0004 (0x0004 - 0x0000)
struct MM_PKMode_OnScrollEvent final
{
public:
	float                                         FOffset;                                           // 0x0000(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(MM_PKMode_OnScrollEvent) == 0x000004, "Wrong alignment on MM_PKMode_OnScrollEvent");
static_assert(sizeof(MM_PKMode_OnScrollEvent) == 0x000004, "Wrong size on MM_PKMode_OnScrollEvent");
static_assert(offsetof(MM_PKMode_OnScrollEvent, FOffset) == 0x000000, "Member 'MM_PKMode_OnScrollEvent::FOffset' has a wrong offset!");

// Function MirMobile.MM_PKMode.OnSelectedMode
// 0x0001 (0x0001 - 0x0000)
struct MM_PKMode_OnSelectedMode final
{
public:
	EPKModeType                                   SelectedMode;                                      // 0x0000(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(MM_PKMode_OnSelectedMode) == 0x000001, "Wrong alignment on MM_PKMode_OnSelectedMode");
static_assert(sizeof(MM_PKMode_OnSelectedMode) == 0x000001, "Wrong size on MM_PKMode_OnSelectedMode");
static_assert(offsetof(MM_PKMode_OnSelectedMode, SelectedMode) == 0x000000, "Member 'MM_PKMode_OnSelectedMode::SelectedMode' has a wrong offset!");

// Function MirMobile.MM_Popup_GuildTournament_Reward.OnClickedIndividualTab
// 0x0001 (0x0001 - 0x0000)
struct MM_Popup_GuildTournament_Reward_OnClickedIndividualTab final
{
public:
	bool                                          Checked_;                                          // 0x0000(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(MM_Popup_GuildTournament_Reward_OnClickedIndividualTab) == 0x000001, "Wrong alignment on MM_Popup_GuildTournament_Reward_OnClickedIndividualTab");
static_assert(sizeof(MM_Popup_GuildTournament_Reward_OnClickedIndividualTab) == 0x000001, "Wrong size on MM_Popup_GuildTournament_Reward_OnClickedIndividualTab");
static_assert(offsetof(MM_Popup_GuildTournament_Reward_OnClickedIndividualTab, Checked_) == 0x000000, "Member 'MM_Popup_GuildTournament_Reward_OnClickedIndividualTab::Checked_' has a wrong offset!");

// Function MirMobile.MM_Popup_GuildTournament_Reward.OnClickedNoramlTab
// 0x0001 (0x0001 - 0x0000)
struct MM_Popup_GuildTournament_Reward_OnClickedNoramlTab final
{
public:
	bool                                          Checked_;                                          // 0x0000(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(MM_Popup_GuildTournament_Reward_OnClickedNoramlTab) == 0x000001, "Wrong alignment on MM_Popup_GuildTournament_Reward_OnClickedNoramlTab");
static_assert(sizeof(MM_Popup_GuildTournament_Reward_OnClickedNoramlTab) == 0x000001, "Wrong size on MM_Popup_GuildTournament_Reward_OnClickedNoramlTab");
static_assert(offsetof(MM_Popup_GuildTournament_Reward_OnClickedNoramlTab, Checked_) == 0x000000, "Member 'MM_Popup_GuildTournament_Reward_OnClickedNoramlTab::Checked_' has a wrong offset!");

// Function MirMobile.MM_PlayerAnimInstance.IsAirwalkState
// 0x0002 (0x0002 - 0x0000)
struct MM_PlayerAnimInstance_IsAirwalkState final
{
public:
	EAIRWALK_STATE                                AirState;                                          // 0x0000(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          ReturnValue;                                       // 0x0001(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(MM_PlayerAnimInstance_IsAirwalkState) == 0x000001, "Wrong alignment on MM_PlayerAnimInstance_IsAirwalkState");
static_assert(sizeof(MM_PlayerAnimInstance_IsAirwalkState) == 0x000002, "Wrong size on MM_PlayerAnimInstance_IsAirwalkState");
static_assert(offsetof(MM_PlayerAnimInstance_IsAirwalkState, AirState) == 0x000000, "Member 'MM_PlayerAnimInstance_IsAirwalkState::AirState' has a wrong offset!");
static_assert(offsetof(MM_PlayerAnimInstance_IsAirwalkState, ReturnValue) == 0x000001, "Member 'MM_PlayerAnimInstance_IsAirwalkState::ReturnValue' has a wrong offset!");

// Function MirMobile.MM_PlayerAnimInstance.IsDashState
// 0x0001 (0x0001 - 0x0000)
struct MM_PlayerAnimInstance_IsDashState final
{
public:
	bool                                          ReturnValue;                                       // 0x0000(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(MM_PlayerAnimInstance_IsDashState) == 0x000001, "Wrong alignment on MM_PlayerAnimInstance_IsDashState");
static_assert(sizeof(MM_PlayerAnimInstance_IsDashState) == 0x000001, "Wrong size on MM_PlayerAnimInstance_IsDashState");
static_assert(offsetof(MM_PlayerAnimInstance_IsDashState, ReturnValue) == 0x000000, "Member 'MM_PlayerAnimInstance_IsDashState::ReturnValue' has a wrong offset!");

// Function MirMobile.MM_PlayerAnimInstance.NotAirwalkState
// 0x0002 (0x0002 - 0x0000)
struct MM_PlayerAnimInstance_NotAirwalkState final
{
public:
	EAIRWALK_STATE                                AirState;                                          // 0x0000(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          ReturnValue;                                       // 0x0001(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(MM_PlayerAnimInstance_NotAirwalkState) == 0x000001, "Wrong alignment on MM_PlayerAnimInstance_NotAirwalkState");
static_assert(sizeof(MM_PlayerAnimInstance_NotAirwalkState) == 0x000002, "Wrong size on MM_PlayerAnimInstance_NotAirwalkState");
static_assert(offsetof(MM_PlayerAnimInstance_NotAirwalkState, AirState) == 0x000000, "Member 'MM_PlayerAnimInstance_NotAirwalkState::AirState' has a wrong offset!");
static_assert(offsetof(MM_PlayerAnimInstance_NotAirwalkState, ReturnValue) == 0x000001, "Member 'MM_PlayerAnimInstance_NotAirwalkState::ReturnValue' has a wrong offset!");

// Function MirMobile.MM_PlayerAnimInstance.SetStandLand
// 0x0001 (0x0001 - 0x0000)
struct MM_PlayerAnimInstance_SetStandLand final
{
public:
	bool                                          IsStandLand;                                       // 0x0000(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(MM_PlayerAnimInstance_SetStandLand) == 0x000001, "Wrong alignment on MM_PlayerAnimInstance_SetStandLand");
static_assert(sizeof(MM_PlayerAnimInstance_SetStandLand) == 0x000001, "Wrong size on MM_PlayerAnimInstance_SetStandLand");
static_assert(offsetof(MM_PlayerAnimInstance_SetStandLand, IsStandLand) == 0x000000, "Member 'MM_PlayerAnimInstance_SetStandLand::IsStandLand' has a wrong offset!");

// Function MirMobile.MM_Popup_Acceleration.OnChangePoint
// 0x0008 (0x0008 - 0x0000)
struct MM_Popup_Acceleration_OnChangePoint final
{
public:
	int64                                         UsePoint;                                          // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(MM_Popup_Acceleration_OnChangePoint) == 0x000008, "Wrong alignment on MM_Popup_Acceleration_OnChangePoint");
static_assert(sizeof(MM_Popup_Acceleration_OnChangePoint) == 0x000008, "Wrong size on MM_Popup_Acceleration_OnChangePoint");
static_assert(offsetof(MM_Popup_Acceleration_OnChangePoint, UsePoint) == 0x000000, "Member 'MM_Popup_Acceleration_OnChangePoint::UsePoint' has a wrong offset!");

// Function MirMobile.MM_Popup_AccountSelect.LoginSvnID
// 0x0018 (0x0018 - 0x0000)
struct MM_Popup_AccountSelect_LoginSvnID final
{
public:
	class FText                                   LoginIDText;                                       // 0x0000(0x0018)(Parm, NativeAccessSpecifierPublic)
};
static_assert(alignof(MM_Popup_AccountSelect_LoginSvnID) == 0x000008, "Wrong alignment on MM_Popup_AccountSelect_LoginSvnID");
static_assert(sizeof(MM_Popup_AccountSelect_LoginSvnID) == 0x000018, "Wrong size on MM_Popup_AccountSelect_LoginSvnID");
static_assert(offsetof(MM_Popup_AccountSelect_LoginSvnID, LoginIDText) == 0x000000, "Member 'MM_Popup_AccountSelect_LoginSvnID::LoginIDText' has a wrong offset!");

// Function MirMobile.MM_Popup_AccountSelect.OnCommitEditText
// 0x0020 (0x0020 - 0x0000)
struct MM_Popup_AccountSelect_OnCommitEditText final
{
public:
	class FText                                   Text;                                              // 0x0000(0x0018)(ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
	ETextCommit                                   CommitMethod;                                      // 0x0018(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_19[0x7];                                       // 0x0019(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(MM_Popup_AccountSelect_OnCommitEditText) == 0x000008, "Wrong alignment on MM_Popup_AccountSelect_OnCommitEditText");
static_assert(sizeof(MM_Popup_AccountSelect_OnCommitEditText) == 0x000020, "Wrong size on MM_Popup_AccountSelect_OnCommitEditText");
static_assert(offsetof(MM_Popup_AccountSelect_OnCommitEditText, Text) == 0x000000, "Member 'MM_Popup_AccountSelect_OnCommitEditText::Text' has a wrong offset!");
static_assert(offsetof(MM_Popup_AccountSelect_OnCommitEditText, CommitMethod) == 0x000018, "Member 'MM_Popup_AccountSelect_OnCommitEditText::CommitMethod' has a wrong offset!");

// Function MirMobile.MM_Popup_ExchangeItem.OnSliderValueChanged
// 0x0008 (0x0008 - 0x0000)
struct MM_Popup_ExchangeItem_OnSliderValueChanged final
{
public:
	int64                                         IValue;                                            // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(MM_Popup_ExchangeItem_OnSliderValueChanged) == 0x000008, "Wrong alignment on MM_Popup_ExchangeItem_OnSliderValueChanged");
static_assert(sizeof(MM_Popup_ExchangeItem_OnSliderValueChanged) == 0x000008, "Wrong size on MM_Popup_ExchangeItem_OnSliderValueChanged");
static_assert(offsetof(MM_Popup_ExchangeItem_OnSliderValueChanged, IValue) == 0x000000, "Member 'MM_Popup_ExchangeItem_OnSliderValueChanged::IValue' has a wrong offset!");

// Function MirMobile.MM_Popup_Addressbook_Slot.OnClickCheckBoxSelect
// 0x0001 (0x0001 - 0x0000)
struct MM_Popup_Addressbook_Slot_OnClickCheckBoxSelect final
{
public:
	bool                                          bChecked;                                          // 0x0000(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(MM_Popup_Addressbook_Slot_OnClickCheckBoxSelect) == 0x000001, "Wrong alignment on MM_Popup_Addressbook_Slot_OnClickCheckBoxSelect");
static_assert(sizeof(MM_Popup_Addressbook_Slot_OnClickCheckBoxSelect) == 0x000001, "Wrong size on MM_Popup_Addressbook_Slot_OnClickCheckBoxSelect");
static_assert(offsetof(MM_Popup_Addressbook_Slot_OnClickCheckBoxSelect, bChecked) == 0x000000, "Member 'MM_Popup_Addressbook_Slot_OnClickCheckBoxSelect::bChecked' has a wrong offset!");

// Function MirMobile.MM_Popup_AdsReward.OnClickCheckBox
// 0x0001 (0x0001 - 0x0000)
struct MM_Popup_AdsReward_OnClickCheckBox final
{
public:
	bool                                          Checked;                                           // 0x0000(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(MM_Popup_AdsReward_OnClickCheckBox) == 0x000001, "Wrong alignment on MM_Popup_AdsReward_OnClickCheckBox");
static_assert(sizeof(MM_Popup_AdsReward_OnClickCheckBox) == 0x000001, "Wrong size on MM_Popup_AdsReward_OnClickCheckBox");
static_assert(offsetof(MM_Popup_AdsReward_OnClickCheckBox, Checked) == 0x000000, "Member 'MM_Popup_AdsReward_OnClickCheckBox::Checked' has a wrong offset!");

// Function MirMobile.MM_Popup_AutoSmelt.OnChangeSmeltLV
// 0x0008 (0x0008 - 0x0000)
struct MM_Popup_AutoSmelt_OnChangeSmeltLV final
{
public:
	int64                                         SmeltLV;                                           // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(MM_Popup_AutoSmelt_OnChangeSmeltLV) == 0x000008, "Wrong alignment on MM_Popup_AutoSmelt_OnChangeSmeltLV");
static_assert(sizeof(MM_Popup_AutoSmelt_OnChangeSmeltLV) == 0x000008, "Wrong size on MM_Popup_AutoSmelt_OnChangeSmeltLV");
static_assert(offsetof(MM_Popup_AutoSmelt_OnChangeSmeltLV, SmeltLV) == 0x000000, "Member 'MM_Popup_AutoSmelt_OnChangeSmeltLV::SmeltLV' has a wrong offset!");

// Function MirMobile.MM_Popup_AutoSmelt.OnClickInvenSlot
// 0x0010 (0x0010 - 0x0000)
struct MM_Popup_AutoSmelt_OnClickInvenSlot final
{
public:
	int64                                         IUID;                                              // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         ITID;                                              // 0x0008(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         IEquipPos;                                         // 0x000C(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(MM_Popup_AutoSmelt_OnClickInvenSlot) == 0x000008, "Wrong alignment on MM_Popup_AutoSmelt_OnClickInvenSlot");
static_assert(sizeof(MM_Popup_AutoSmelt_OnClickInvenSlot) == 0x000010, "Wrong size on MM_Popup_AutoSmelt_OnClickInvenSlot");
static_assert(offsetof(MM_Popup_AutoSmelt_OnClickInvenSlot, IUID) == 0x000000, "Member 'MM_Popup_AutoSmelt_OnClickInvenSlot::IUID' has a wrong offset!");
static_assert(offsetof(MM_Popup_AutoSmelt_OnClickInvenSlot, ITID) == 0x000008, "Member 'MM_Popup_AutoSmelt_OnClickInvenSlot::ITID' has a wrong offset!");
static_assert(offsetof(MM_Popup_AutoSmelt_OnClickInvenSlot, IEquipPos) == 0x00000C, "Member 'MM_Popup_AutoSmelt_OnClickInvenSlot::IEquipPos' has a wrong offset!");

// Function MirMobile.MM_Popup_BattlePsss_BuyInfo.OnClickCheckBoxCryptocurrency
// 0x0001 (0x0001 - 0x0000)
struct MM_Popup_BattlePsss_BuyInfo_OnClickCheckBoxCryptocurrency final
{
public:
	bool                                          Checked;                                           // 0x0000(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(MM_Popup_BattlePsss_BuyInfo_OnClickCheckBoxCryptocurrency) == 0x000001, "Wrong alignment on MM_Popup_BattlePsss_BuyInfo_OnClickCheckBoxCryptocurrency");
static_assert(sizeof(MM_Popup_BattlePsss_BuyInfo_OnClickCheckBoxCryptocurrency) == 0x000001, "Wrong size on MM_Popup_BattlePsss_BuyInfo_OnClickCheckBoxCryptocurrency");
static_assert(offsetof(MM_Popup_BattlePsss_BuyInfo_OnClickCheckBoxCryptocurrency, Checked) == 0x000000, "Member 'MM_Popup_BattlePsss_BuyInfo_OnClickCheckBoxCryptocurrency::Checked' has a wrong offset!");

// Function MirMobile.MM_Popup_BattlePsss_BuyInfo.OnClickCheckBoxItem
// 0x0001 (0x0001 - 0x0000)
struct MM_Popup_BattlePsss_BuyInfo_OnClickCheckBoxItem final
{
public:
	bool                                          bChecked;                                          // 0x0000(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(MM_Popup_BattlePsss_BuyInfo_OnClickCheckBoxItem) == 0x000001, "Wrong alignment on MM_Popup_BattlePsss_BuyInfo_OnClickCheckBoxItem");
static_assert(sizeof(MM_Popup_BattlePsss_BuyInfo_OnClickCheckBoxItem) == 0x000001, "Wrong size on MM_Popup_BattlePsss_BuyInfo_OnClickCheckBoxItem");
static_assert(offsetof(MM_Popup_BattlePsss_BuyInfo_OnClickCheckBoxItem, bChecked) == 0x000000, "Member 'MM_Popup_BattlePsss_BuyInfo_OnClickCheckBoxItem::bChecked' has a wrong offset!");

// Function MirMobile.MM_Popup_BattlePsss_BuyInfo.OnClickCheckBoxUSD
// 0x0001 (0x0001 - 0x0000)
struct MM_Popup_BattlePsss_BuyInfo_OnClickCheckBoxUSD final
{
public:
	bool                                          bChecked;                                          // 0x0000(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(MM_Popup_BattlePsss_BuyInfo_OnClickCheckBoxUSD) == 0x000001, "Wrong alignment on MM_Popup_BattlePsss_BuyInfo_OnClickCheckBoxUSD");
static_assert(sizeof(MM_Popup_BattlePsss_BuyInfo_OnClickCheckBoxUSD) == 0x000001, "Wrong size on MM_Popup_BattlePsss_BuyInfo_OnClickCheckBoxUSD");
static_assert(offsetof(MM_Popup_BattlePsss_BuyInfo_OnClickCheckBoxUSD, bChecked) == 0x000000, "Member 'MM_Popup_BattlePsss_BuyInfo_OnClickCheckBoxUSD::bChecked' has a wrong offset!");

// Function MirMobile.MM_Popup_BlackIronShop_Move.OnChangeCount
// 0x0008 (0x0008 - 0x0000)
struct MM_Popup_BlackIronShop_Move_OnChangeCount final
{
public:
	int64                                         Count_;                                            // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(MM_Popup_BlackIronShop_Move_OnChangeCount) == 0x000008, "Wrong alignment on MM_Popup_BlackIronShop_Move_OnChangeCount");
static_assert(sizeof(MM_Popup_BlackIronShop_Move_OnChangeCount) == 0x000008, "Wrong size on MM_Popup_BlackIronShop_Move_OnChangeCount");
static_assert(offsetof(MM_Popup_BlackIronShop_Move_OnChangeCount, Count_) == 0x000000, "Member 'MM_Popup_BlackIronShop_Move_OnChangeCount::Count_' has a wrong offset!");

// Function MirMobile.MM_Popup_BlackIronShop_Sell.OnChangeCount
// 0x0008 (0x0008 - 0x0000)
struct MM_Popup_BlackIronShop_Sell_OnChangeCount final
{
public:
	int64                                         Count_;                                            // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(MM_Popup_BlackIronShop_Sell_OnChangeCount) == 0x000008, "Wrong alignment on MM_Popup_BlackIronShop_Sell_OnChangeCount");
static_assert(sizeof(MM_Popup_BlackIronShop_Sell_OnChangeCount) == 0x000008, "Wrong size on MM_Popup_BlackIronShop_Sell_OnChangeCount");
static_assert(offsetof(MM_Popup_BlackIronShop_Sell_OnChangeCount, Count_) == 0x000000, "Member 'MM_Popup_BlackIronShop_Sell_OnChangeCount::Count_' has a wrong offset!");

// Function MirMobile.MM_Popup_BlackIronShop_Sell.OnChangePrice
// 0x0008 (0x0008 - 0x0000)
struct MM_Popup_BlackIronShop_Sell_OnChangePrice final
{
public:
	int64                                         Count_;                                            // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(MM_Popup_BlackIronShop_Sell_OnChangePrice) == 0x000008, "Wrong alignment on MM_Popup_BlackIronShop_Sell_OnChangePrice");
static_assert(sizeof(MM_Popup_BlackIronShop_Sell_OnChangePrice) == 0x000008, "Wrong size on MM_Popup_BlackIronShop_Sell_OnChangePrice");
static_assert(offsetof(MM_Popup_BlackIronShop_Sell_OnChangePrice, Count_) == 0x000000, "Member 'MM_Popup_BlackIronShop_Sell_OnChangePrice::Count_' has a wrong offset!");

// Function MirMobile.MM_Popup_Chat_VoiceOption.OnToggleVoiceChatMicrophone
// 0x0001 (0x0001 - 0x0000)
struct MM_Popup_Chat_VoiceOption_OnToggleVoiceChatMicrophone final
{
public:
	bool                                          CheckState;                                        // 0x0000(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(MM_Popup_Chat_VoiceOption_OnToggleVoiceChatMicrophone) == 0x000001, "Wrong alignment on MM_Popup_Chat_VoiceOption_OnToggleVoiceChatMicrophone");
static_assert(sizeof(MM_Popup_Chat_VoiceOption_OnToggleVoiceChatMicrophone) == 0x000001, "Wrong size on MM_Popup_Chat_VoiceOption_OnToggleVoiceChatMicrophone");
static_assert(offsetof(MM_Popup_Chat_VoiceOption_OnToggleVoiceChatMicrophone, CheckState) == 0x000000, "Member 'MM_Popup_Chat_VoiceOption_OnToggleVoiceChatMicrophone::CheckState' has a wrong offset!");

// Function MirMobile.MM_Popup_Chat_VoiceOption.OnToggleVoiceChatSound
// 0x0001 (0x0001 - 0x0000)
struct MM_Popup_Chat_VoiceOption_OnToggleVoiceChatSound final
{
public:
	bool                                          CheckState;                                        // 0x0000(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(MM_Popup_Chat_VoiceOption_OnToggleVoiceChatSound) == 0x000001, "Wrong alignment on MM_Popup_Chat_VoiceOption_OnToggleVoiceChatSound");
static_assert(sizeof(MM_Popup_Chat_VoiceOption_OnToggleVoiceChatSound) == 0x000001, "Wrong size on MM_Popup_Chat_VoiceOption_OnToggleVoiceChatSound");
static_assert(offsetof(MM_Popup_Chat_VoiceOption_OnToggleVoiceChatSound, CheckState) == 0x000000, "Member 'MM_Popup_Chat_VoiceOption_OnToggleVoiceChatSound::CheckState' has a wrong offset!");

// Function MirMobile.MM_Popup_ClosedTraining_CollectResult.ShowOnlyTitle
// 0x0001 (0x0001 - 0x0000)
struct MM_Popup_ClosedTraining_CollectResult_ShowOnlyTitle final
{
public:
	bool                                          bOnly;                                             // 0x0000(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(MM_Popup_ClosedTraining_CollectResult_ShowOnlyTitle) == 0x000001, "Wrong alignment on MM_Popup_ClosedTraining_CollectResult_ShowOnlyTitle");
static_assert(sizeof(MM_Popup_ClosedTraining_CollectResult_ShowOnlyTitle) == 0x000001, "Wrong size on MM_Popup_ClosedTraining_CollectResult_ShowOnlyTitle");
static_assert(offsetof(MM_Popup_ClosedTraining_CollectResult_ShowOnlyTitle, bOnly) == 0x000000, "Member 'MM_Popup_ClosedTraining_CollectResult_ShowOnlyTitle::bOnly' has a wrong offset!");

// Function MirMobile.MM_Popup_CommonCheckBox.OnToggleDoNotAgain
// 0x0001 (0x0001 - 0x0000)
struct MM_Popup_CommonCheckBox_OnToggleDoNotAgain final
{
public:
	bool                                          CheckState;                                        // 0x0000(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(MM_Popup_CommonCheckBox_OnToggleDoNotAgain) == 0x000001, "Wrong alignment on MM_Popup_CommonCheckBox_OnToggleDoNotAgain");
static_assert(sizeof(MM_Popup_CommonCheckBox_OnToggleDoNotAgain) == 0x000001, "Wrong size on MM_Popup_CommonCheckBox_OnToggleDoNotAgain");
static_assert(offsetof(MM_Popup_CommonCheckBox_OnToggleDoNotAgain, CheckState) == 0x000000, "Member 'MM_Popup_CommonCheckBox_OnToggleDoNotAgain::CheckState' has a wrong offset!");

// Function MirMobile.MM_PopUp_Costume_Palette.OnClickColorCH1
// 0x0004 (0x0004 - 0x0000)
struct MM_PopUp_Costume_Palette_OnClickColorCH1 final
{
public:
	int32                                         PaletteIndex;                                      // 0x0000(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(MM_PopUp_Costume_Palette_OnClickColorCH1) == 0x000004, "Wrong alignment on MM_PopUp_Costume_Palette_OnClickColorCH1");
static_assert(sizeof(MM_PopUp_Costume_Palette_OnClickColorCH1) == 0x000004, "Wrong size on MM_PopUp_Costume_Palette_OnClickColorCH1");
static_assert(offsetof(MM_PopUp_Costume_Palette_OnClickColorCH1, PaletteIndex) == 0x000000, "Member 'MM_PopUp_Costume_Palette_OnClickColorCH1::PaletteIndex' has a wrong offset!");

// Function MirMobile.MM_PopUp_Costume_Palette.OnClickColorCH2
// 0x0004 (0x0004 - 0x0000)
struct MM_PopUp_Costume_Palette_OnClickColorCH2 final
{
public:
	int32                                         PaletteIndex;                                      // 0x0000(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(MM_PopUp_Costume_Palette_OnClickColorCH2) == 0x000004, "Wrong alignment on MM_PopUp_Costume_Palette_OnClickColorCH2");
static_assert(sizeof(MM_PopUp_Costume_Palette_OnClickColorCH2) == 0x000004, "Wrong size on MM_PopUp_Costume_Palette_OnClickColorCH2");
static_assert(offsetof(MM_PopUp_Costume_Palette_OnClickColorCH2, PaletteIndex) == 0x000000, "Member 'MM_PopUp_Costume_Palette_OnClickColorCH2::PaletteIndex' has a wrong offset!");

// Function MirMobile.MM_PopUp_Costume_Palette.OnClickSlot
// 0x0010 (0x0010 - 0x0000)
struct MM_PopUp_Costume_Palette_OnClickSlot final
{
public:
	int32                                         Palette_CostumeID;                                 // 0x0000(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         Palette_Number_Ch1;                                // 0x0004(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         Palette_Number_Ch2;                                // 0x0008(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bEnable;                                           // 0x000C(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_D[0x3];                                        // 0x000D(0x0003)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(MM_PopUp_Costume_Palette_OnClickSlot) == 0x000004, "Wrong alignment on MM_PopUp_Costume_Palette_OnClickSlot");
static_assert(sizeof(MM_PopUp_Costume_Palette_OnClickSlot) == 0x000010, "Wrong size on MM_PopUp_Costume_Palette_OnClickSlot");
static_assert(offsetof(MM_PopUp_Costume_Palette_OnClickSlot, Palette_CostumeID) == 0x000000, "Member 'MM_PopUp_Costume_Palette_OnClickSlot::Palette_CostumeID' has a wrong offset!");
static_assert(offsetof(MM_PopUp_Costume_Palette_OnClickSlot, Palette_Number_Ch1) == 0x000004, "Member 'MM_PopUp_Costume_Palette_OnClickSlot::Palette_Number_Ch1' has a wrong offset!");
static_assert(offsetof(MM_PopUp_Costume_Palette_OnClickSlot, Palette_Number_Ch2) == 0x000008, "Member 'MM_PopUp_Costume_Palette_OnClickSlot::Palette_Number_Ch2' has a wrong offset!");
static_assert(offsetof(MM_PopUp_Costume_Palette_OnClickSlot, bEnable) == 0x00000C, "Member 'MM_PopUp_Costume_Palette_OnClickSlot::bEnable' has a wrong offset!");

// Function MirMobile.MM_PopUp_Costume_Palette.OnClickSlot_Direct_CH1
// 0x0010 (0x0010 - 0x0000)
struct MM_PopUp_Costume_Palette_OnClickSlot_Direct_CH1 final
{
public:
	int32                                         Palette_CostumeID;                                 // 0x0000(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         Palette_Number_Ch1;                                // 0x0004(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         Palette_Number_Ch2;                                // 0x0008(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bEnable;                                           // 0x000C(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_D[0x3];                                        // 0x000D(0x0003)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(MM_PopUp_Costume_Palette_OnClickSlot_Direct_CH1) == 0x000004, "Wrong alignment on MM_PopUp_Costume_Palette_OnClickSlot_Direct_CH1");
static_assert(sizeof(MM_PopUp_Costume_Palette_OnClickSlot_Direct_CH1) == 0x000010, "Wrong size on MM_PopUp_Costume_Palette_OnClickSlot_Direct_CH1");
static_assert(offsetof(MM_PopUp_Costume_Palette_OnClickSlot_Direct_CH1, Palette_CostumeID) == 0x000000, "Member 'MM_PopUp_Costume_Palette_OnClickSlot_Direct_CH1::Palette_CostumeID' has a wrong offset!");
static_assert(offsetof(MM_PopUp_Costume_Palette_OnClickSlot_Direct_CH1, Palette_Number_Ch1) == 0x000004, "Member 'MM_PopUp_Costume_Palette_OnClickSlot_Direct_CH1::Palette_Number_Ch1' has a wrong offset!");
static_assert(offsetof(MM_PopUp_Costume_Palette_OnClickSlot_Direct_CH1, Palette_Number_Ch2) == 0x000008, "Member 'MM_PopUp_Costume_Palette_OnClickSlot_Direct_CH1::Palette_Number_Ch2' has a wrong offset!");
static_assert(offsetof(MM_PopUp_Costume_Palette_OnClickSlot_Direct_CH1, bEnable) == 0x00000C, "Member 'MM_PopUp_Costume_Palette_OnClickSlot_Direct_CH1::bEnable' has a wrong offset!");

// Function MirMobile.MM_PopUp_Costume_Palette.OnClickSlot_Direct_CH2
// 0x0010 (0x0010 - 0x0000)
struct MM_PopUp_Costume_Palette_OnClickSlot_Direct_CH2 final
{
public:
	int32                                         Palette_CostumeID;                                 // 0x0000(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         Palette_Number_Ch1;                                // 0x0004(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         Palette_Number_Ch2;                                // 0x0008(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bEnable;                                           // 0x000C(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_D[0x3];                                        // 0x000D(0x0003)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(MM_PopUp_Costume_Palette_OnClickSlot_Direct_CH2) == 0x000004, "Wrong alignment on MM_PopUp_Costume_Palette_OnClickSlot_Direct_CH2");
static_assert(sizeof(MM_PopUp_Costume_Palette_OnClickSlot_Direct_CH2) == 0x000010, "Wrong size on MM_PopUp_Costume_Palette_OnClickSlot_Direct_CH2");
static_assert(offsetof(MM_PopUp_Costume_Palette_OnClickSlot_Direct_CH2, Palette_CostumeID) == 0x000000, "Member 'MM_PopUp_Costume_Palette_OnClickSlot_Direct_CH2::Palette_CostumeID' has a wrong offset!");
static_assert(offsetof(MM_PopUp_Costume_Palette_OnClickSlot_Direct_CH2, Palette_Number_Ch1) == 0x000004, "Member 'MM_PopUp_Costume_Palette_OnClickSlot_Direct_CH2::Palette_Number_Ch1' has a wrong offset!");
static_assert(offsetof(MM_PopUp_Costume_Palette_OnClickSlot_Direct_CH2, Palette_Number_Ch2) == 0x000008, "Member 'MM_PopUp_Costume_Palette_OnClickSlot_Direct_CH2::Palette_Number_Ch2' has a wrong offset!");
static_assert(offsetof(MM_PopUp_Costume_Palette_OnClickSlot_Direct_CH2, bEnable) == 0x00000C, "Member 'MM_PopUp_Costume_Palette_OnClickSlot_Direct_CH2::bEnable' has a wrong offset!");

// Function MirMobile.MM_PopUp_Costume_Palette.PlayEndAnimation
// 0x0004 (0x0004 - 0x0000)
struct MM_PopUp_Costume_Palette_PlayEndAnimation final
{
public:
	float                                         ReturnValue;                                       // 0x0000(0x0004)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(MM_PopUp_Costume_Palette_PlayEndAnimation) == 0x000004, "Wrong alignment on MM_PopUp_Costume_Palette_PlayEndAnimation");
static_assert(sizeof(MM_PopUp_Costume_Palette_PlayEndAnimation) == 0x000004, "Wrong size on MM_PopUp_Costume_Palette_PlayEndAnimation");
static_assert(offsetof(MM_PopUp_Costume_Palette_PlayEndAnimation, ReturnValue) == 0x000000, "Member 'MM_PopUp_Costume_Palette_PlayEndAnimation::ReturnValue' has a wrong offset!");

// Function MirMobile.MM_PopUp_Costume_Palette.PlayStartAnimation
// 0x0004 (0x0004 - 0x0000)
struct MM_PopUp_Costume_Palette_PlayStartAnimation final
{
public:
	float                                         ReturnValue;                                       // 0x0000(0x0004)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(MM_PopUp_Costume_Palette_PlayStartAnimation) == 0x000004, "Wrong alignment on MM_PopUp_Costume_Palette_PlayStartAnimation");
static_assert(sizeof(MM_PopUp_Costume_Palette_PlayStartAnimation) == 0x000004, "Wrong size on MM_PopUp_Costume_Palette_PlayStartAnimation");
static_assert(offsetof(MM_PopUp_Costume_Palette_PlayStartAnimation, ReturnValue) == 0x000000, "Member 'MM_PopUp_Costume_Palette_PlayStartAnimation::ReturnValue' has a wrong offset!");

// Function MirMobile.MM_Popup_Coupon.OnTextChanged_EditInput
// 0x0018 (0x0018 - 0x0000)
struct MM_Popup_Coupon_OnTextChanged_EditInput final
{
public:
	class FText                                   Text;                                              // 0x0000(0x0018)(ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
};
static_assert(alignof(MM_Popup_Coupon_OnTextChanged_EditInput) == 0x000008, "Wrong alignment on MM_Popup_Coupon_OnTextChanged_EditInput");
static_assert(sizeof(MM_Popup_Coupon_OnTextChanged_EditInput) == 0x000018, "Wrong size on MM_Popup_Coupon_OnTextChanged_EditInput");
static_assert(offsetof(MM_Popup_Coupon_OnTextChanged_EditInput, Text) == 0x000000, "Member 'MM_Popup_Coupon_OnTextChanged_EditInput::Text' has a wrong offset!");

// Function MirMobile.MM_Popup_Coupon.OnTextCommitted
// 0x0020 (0x0020 - 0x0000)
struct MM_Popup_Coupon_OnTextCommitted final
{
public:
	class FText                                   Text;                                              // 0x0000(0x0018)(ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
	ETextCommit                                   ETextCommit;                                       // 0x0018(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_19[0x7];                                       // 0x0019(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(MM_Popup_Coupon_OnTextCommitted) == 0x000008, "Wrong alignment on MM_Popup_Coupon_OnTextCommitted");
static_assert(sizeof(MM_Popup_Coupon_OnTextCommitted) == 0x000020, "Wrong size on MM_Popup_Coupon_OnTextCommitted");
static_assert(offsetof(MM_Popup_Coupon_OnTextCommitted, Text) == 0x000000, "Member 'MM_Popup_Coupon_OnTextCommitted::Text' has a wrong offset!");
static_assert(offsetof(MM_Popup_Coupon_OnTextCommitted, ETextCommit) == 0x000018, "Member 'MM_Popup_Coupon_OnTextCommitted::ETextCommit' has a wrong offset!");

// Function MirMobile.MM_Popup_DominionTitle.OnSelectDelegate
// 0x0004 (0x0004 - 0x0000)
struct MM_Popup_DominionTitle_OnSelectDelegate final
{
public:
	int32                                         IPBS_ID;                                           // 0x0000(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(MM_Popup_DominionTitle_OnSelectDelegate) == 0x000004, "Wrong alignment on MM_Popup_DominionTitle_OnSelectDelegate");
static_assert(sizeof(MM_Popup_DominionTitle_OnSelectDelegate) == 0x000004, "Wrong size on MM_Popup_DominionTitle_OnSelectDelegate");
static_assert(offsetof(MM_Popup_DominionTitle_OnSelectDelegate, IPBS_ID) == 0x000000, "Member 'MM_Popup_DominionTitle_OnSelectDelegate::IPBS_ID' has a wrong offset!");

// Function MirMobile.MM_Popup_DominionWithDrawal.OnGoldDelegate
// 0x0004 (0x0004 - 0x0000)
struct MM_Popup_DominionWithDrawal_OnGoldDelegate final
{
public:
	int32                                         IValue;                                            // 0x0000(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(MM_Popup_DominionWithDrawal_OnGoldDelegate) == 0x000004, "Wrong alignment on MM_Popup_DominionWithDrawal_OnGoldDelegate");
static_assert(sizeof(MM_Popup_DominionWithDrawal_OnGoldDelegate) == 0x000004, "Wrong size on MM_Popup_DominionWithDrawal_OnGoldDelegate");
static_assert(offsetof(MM_Popup_DominionWithDrawal_OnGoldDelegate, IValue) == 0x000000, "Member 'MM_Popup_DominionWithDrawal_OnGoldDelegate::IValue' has a wrong offset!");

// Function MirMobile.MM_Popup_EventPsss_BuyInfo.OnClickCheckBoxCryptocurrency
// 0x0001 (0x0001 - 0x0000)
struct MM_Popup_EventPsss_BuyInfo_OnClickCheckBoxCryptocurrency final
{
public:
	bool                                          Checked;                                           // 0x0000(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(MM_Popup_EventPsss_BuyInfo_OnClickCheckBoxCryptocurrency) == 0x000001, "Wrong alignment on MM_Popup_EventPsss_BuyInfo_OnClickCheckBoxCryptocurrency");
static_assert(sizeof(MM_Popup_EventPsss_BuyInfo_OnClickCheckBoxCryptocurrency) == 0x000001, "Wrong size on MM_Popup_EventPsss_BuyInfo_OnClickCheckBoxCryptocurrency");
static_assert(offsetof(MM_Popup_EventPsss_BuyInfo_OnClickCheckBoxCryptocurrency, Checked) == 0x000000, "Member 'MM_Popup_EventPsss_BuyInfo_OnClickCheckBoxCryptocurrency::Checked' has a wrong offset!");

// Function MirMobile.MM_Popup_Filter.OnClick_FilterBtn
// 0x0004 (0x0004 - 0x0000)
struct MM_Popup_Filter_OnClick_FilterBtn final
{
public:
	int32                                         IKey;                                              // 0x0000(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(MM_Popup_Filter_OnClick_FilterBtn) == 0x000004, "Wrong alignment on MM_Popup_Filter_OnClick_FilterBtn");
static_assert(sizeof(MM_Popup_Filter_OnClick_FilterBtn) == 0x000004, "Wrong size on MM_Popup_Filter_OnClick_FilterBtn");
static_assert(offsetof(MM_Popup_Filter_OnClick_FilterBtn, IKey) == 0x000000, "Member 'MM_Popup_Filter_OnClick_FilterBtn::IKey' has a wrong offset!");

// Function MirMobile.MM_Popup_Filter.OnClick_OptionBtn
// 0x0004 (0x0004 - 0x0000)
struct MM_Popup_Filter_OnClick_OptionBtn final
{
public:
	int32                                         IKey;                                              // 0x0000(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(MM_Popup_Filter_OnClick_OptionBtn) == 0x000004, "Wrong alignment on MM_Popup_Filter_OnClick_OptionBtn");
static_assert(sizeof(MM_Popup_Filter_OnClick_OptionBtn) == 0x000004, "Wrong size on MM_Popup_Filter_OnClick_OptionBtn");
static_assert(offsetof(MM_Popup_Filter_OnClick_OptionBtn, IKey) == 0x000000, "Member 'MM_Popup_Filter_OnClick_OptionBtn::IKey' has a wrong offset!");

// Function MirMobile.MM_Popup_FrontBanner.OnClickCheckBox
// 0x0001 (0x0001 - 0x0000)
struct MM_Popup_FrontBanner_OnClickCheckBox final
{
public:
	bool                                          Checked;                                           // 0x0000(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(MM_Popup_FrontBanner_OnClickCheckBox) == 0x000001, "Wrong alignment on MM_Popup_FrontBanner_OnClickCheckBox");
static_assert(sizeof(MM_Popup_FrontBanner_OnClickCheckBox) == 0x000001, "Wrong size on MM_Popup_FrontBanner_OnClickCheckBox");
static_assert(offsetof(MM_Popup_FrontBanner_OnClickCheckBox, Checked) == 0x000000, "Member 'MM_Popup_FrontBanner_OnClickCheckBox::Checked' has a wrong offset!");

// Function MirMobile.MM_Popup_FrontBanner.OnFailDownloadImage
// 0x0008 (0x0008 - 0x0000)
struct MM_Popup_FrontBanner_OnFailDownloadImage final
{
public:
	class UTexture2DDynamic*                      Texture;                                           // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(MM_Popup_FrontBanner_OnFailDownloadImage) == 0x000008, "Wrong alignment on MM_Popup_FrontBanner_OnFailDownloadImage");
static_assert(sizeof(MM_Popup_FrontBanner_OnFailDownloadImage) == 0x000008, "Wrong size on MM_Popup_FrontBanner_OnFailDownloadImage");
static_assert(offsetof(MM_Popup_FrontBanner_OnFailDownloadImage, Texture) == 0x000000, "Member 'MM_Popup_FrontBanner_OnFailDownloadImage::Texture' has a wrong offset!");

// Function MirMobile.MM_Popup_FrontBanner.OnSuccessDownloadImage
// 0x0008 (0x0008 - 0x0000)
struct MM_Popup_FrontBanner_OnSuccessDownloadImage final
{
public:
	class UTexture2DDynamic*                      Texture;                                           // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(MM_Popup_FrontBanner_OnSuccessDownloadImage) == 0x000008, "Wrong alignment on MM_Popup_FrontBanner_OnSuccessDownloadImage");
static_assert(sizeof(MM_Popup_FrontBanner_OnSuccessDownloadImage) == 0x000008, "Wrong size on MM_Popup_FrontBanner_OnSuccessDownloadImage");
static_assert(offsetof(MM_Popup_FrontBanner_OnSuccessDownloadImage, Texture) == 0x000000, "Member 'MM_Popup_FrontBanner_OnSuccessDownloadImage::Texture' has a wrong offset!");

// Function MirMobile.MM_Popup_GuildDevInfo.PlayEndAnimation
// 0x0004 (0x0004 - 0x0000)
struct MM_Popup_GuildDevInfo_PlayEndAnimation final
{
public:
	float                                         ReturnValue;                                       // 0x0000(0x0004)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(MM_Popup_GuildDevInfo_PlayEndAnimation) == 0x000004, "Wrong alignment on MM_Popup_GuildDevInfo_PlayEndAnimation");
static_assert(sizeof(MM_Popup_GuildDevInfo_PlayEndAnimation) == 0x000004, "Wrong size on MM_Popup_GuildDevInfo_PlayEndAnimation");
static_assert(offsetof(MM_Popup_GuildDevInfo_PlayEndAnimation, ReturnValue) == 0x000000, "Member 'MM_Popup_GuildDevInfo_PlayEndAnimation::ReturnValue' has a wrong offset!");

// Function MirMobile.MM_Popup_GuildInvite.OnTextCommitted
// 0x0020 (0x0020 - 0x0000)
struct MM_Popup_GuildInvite_OnTextCommitted final
{
public:
	class FText                                   Text_;                                             // 0x0000(0x0018)(ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
	ETextCommit                                   Commit_method_;                                    // 0x0018(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_19[0x7];                                       // 0x0019(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(MM_Popup_GuildInvite_OnTextCommitted) == 0x000008, "Wrong alignment on MM_Popup_GuildInvite_OnTextCommitted");
static_assert(sizeof(MM_Popup_GuildInvite_OnTextCommitted) == 0x000020, "Wrong size on MM_Popup_GuildInvite_OnTextCommitted");
static_assert(offsetof(MM_Popup_GuildInvite_OnTextCommitted, Text_) == 0x000000, "Member 'MM_Popup_GuildInvite_OnTextCommitted::Text_' has a wrong offset!");
static_assert(offsetof(MM_Popup_GuildInvite_OnTextCommitted, Commit_method_) == 0x000018, "Member 'MM_Popup_GuildInvite_OnTextCommitted::Commit_method_' has a wrong offset!");

// Function MirMobile.MM_Popup_GuildList.OnClickGuildSlot
// 0x0008 (0x0008 - 0x0000)
struct MM_Popup_GuildList_OnClickGuildSlot final
{
public:
	int64                                         IGuildUID;                                         // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(MM_Popup_GuildList_OnClickGuildSlot) == 0x000008, "Wrong alignment on MM_Popup_GuildList_OnClickGuildSlot");
static_assert(sizeof(MM_Popup_GuildList_OnClickGuildSlot) == 0x000008, "Wrong size on MM_Popup_GuildList_OnClickGuildSlot");
static_assert(offsetof(MM_Popup_GuildList_OnClickGuildSlot, IGuildUID) == 0x000000, "Member 'MM_Popup_GuildList_OnClickGuildSlot::IGuildUID' has a wrong offset!");

// Function MirMobile.MM_Popup_GuildTournament_Enter.OnClickedMatchInfo
// 0x0001 (0x0001 - 0x0000)
struct MM_Popup_GuildTournament_Enter_OnClickedMatchInfo final
{
public:
	bool                                          Checked_;                                          // 0x0000(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(MM_Popup_GuildTournament_Enter_OnClickedMatchInfo) == 0x000001, "Wrong alignment on MM_Popup_GuildTournament_Enter_OnClickedMatchInfo");
static_assert(sizeof(MM_Popup_GuildTournament_Enter_OnClickedMatchInfo) == 0x000001, "Wrong size on MM_Popup_GuildTournament_Enter_OnClickedMatchInfo");
static_assert(offsetof(MM_Popup_GuildTournament_Enter_OnClickedMatchInfo, Checked_) == 0x000000, "Member 'MM_Popup_GuildTournament_Enter_OnClickedMatchInfo::Checked_' has a wrong offset!");

// Function MirMobile.MM_Popup_GuildTournament_Enter.OnClickedSkillInfo
// 0x0001 (0x0001 - 0x0000)
struct MM_Popup_GuildTournament_Enter_OnClickedSkillInfo final
{
public:
	bool                                          Checked_;                                          // 0x0000(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(MM_Popup_GuildTournament_Enter_OnClickedSkillInfo) == 0x000001, "Wrong alignment on MM_Popup_GuildTournament_Enter_OnClickedSkillInfo");
static_assert(sizeof(MM_Popup_GuildTournament_Enter_OnClickedSkillInfo) == 0x000001, "Wrong size on MM_Popup_GuildTournament_Enter_OnClickedSkillInfo");
static_assert(offsetof(MM_Popup_GuildTournament_Enter_OnClickedSkillInfo, Checked_) == 0x000000, "Member 'MM_Popup_GuildTournament_Enter_OnClickedSkillInfo::Checked_' has a wrong offset!");

// Function MirMobile.MM_Popup_HeavenTrainingTotalInfo.OnClickCheckBoxPassiveTab
// 0x0001 (0x0001 - 0x0000)
struct MM_Popup_HeavenTrainingTotalInfo_OnClickCheckBoxPassiveTab final
{
public:
	bool                                          bChecked;                                          // 0x0000(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(MM_Popup_HeavenTrainingTotalInfo_OnClickCheckBoxPassiveTab) == 0x000001, "Wrong alignment on MM_Popup_HeavenTrainingTotalInfo_OnClickCheckBoxPassiveTab");
static_assert(sizeof(MM_Popup_HeavenTrainingTotalInfo_OnClickCheckBoxPassiveTab) == 0x000001, "Wrong size on MM_Popup_HeavenTrainingTotalInfo_OnClickCheckBoxPassiveTab");
static_assert(offsetof(MM_Popup_HeavenTrainingTotalInfo_OnClickCheckBoxPassiveTab, bChecked) == 0x000000, "Member 'MM_Popup_HeavenTrainingTotalInfo_OnClickCheckBoxPassiveTab::bChecked' has a wrong offset!");

// Function MirMobile.MM_Popup_HeavenTrainingTotalInfo.OnClickCheckBoxStatusTab
// 0x0001 (0x0001 - 0x0000)
struct MM_Popup_HeavenTrainingTotalInfo_OnClickCheckBoxStatusTab final
{
public:
	bool                                          bChecked;                                          // 0x0000(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(MM_Popup_HeavenTrainingTotalInfo_OnClickCheckBoxStatusTab) == 0x000001, "Wrong alignment on MM_Popup_HeavenTrainingTotalInfo_OnClickCheckBoxStatusTab");
static_assert(sizeof(MM_Popup_HeavenTrainingTotalInfo_OnClickCheckBoxStatusTab) == 0x000001, "Wrong size on MM_Popup_HeavenTrainingTotalInfo_OnClickCheckBoxStatusTab");
static_assert(offsetof(MM_Popup_HeavenTrainingTotalInfo_OnClickCheckBoxStatusTab, bChecked) == 0x000000, "Member 'MM_Popup_HeavenTrainingTotalInfo_OnClickCheckBoxStatusTab::bChecked' has a wrong offset!");

// Function MirMobile.MM_Popup_HTOptionChange.OnClickItemInfo
// 0x0008 (0x0008 - 0x0000)
struct MM_Popup_HTOptionChange_OnClickItemInfo final
{
public:
	class UMM_Slot_Base*                          _Slot;                                             // 0x0000(0x0008)(Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(MM_Popup_HTOptionChange_OnClickItemInfo) == 0x000008, "Wrong alignment on MM_Popup_HTOptionChange_OnClickItemInfo");
static_assert(sizeof(MM_Popup_HTOptionChange_OnClickItemInfo) == 0x000008, "Wrong size on MM_Popup_HTOptionChange_OnClickItemInfo");
static_assert(offsetof(MM_Popup_HTOptionChange_OnClickItemInfo, _Slot) == 0x000000, "Member 'MM_Popup_HTOptionChange_OnClickItemInfo::_Slot' has a wrong offset!");

// Function MirMobile.MM_Popup_HTOptionChange.PlayCloseAni
// 0x0004 (0x0004 - 0x0000)
struct MM_Popup_HTOptionChange_PlayCloseAni final
{
public:
	float                                         ReturnValue;                                       // 0x0000(0x0004)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(MM_Popup_HTOptionChange_PlayCloseAni) == 0x000004, "Wrong alignment on MM_Popup_HTOptionChange_PlayCloseAni");
static_assert(sizeof(MM_Popup_HTOptionChange_PlayCloseAni) == 0x000004, "Wrong size on MM_Popup_HTOptionChange_PlayCloseAni");
static_assert(offsetof(MM_Popup_HTOptionChange_PlayCloseAni, ReturnValue) == 0x000000, "Member 'MM_Popup_HTOptionChange_PlayCloseAni::ReturnValue' has a wrong offset!");

// Function MirMobile.MM_Popup_MailWrite.OnChangeEditableTxt_Contents
// 0x0018 (0x0018 - 0x0000)
struct MM_Popup_MailWrite_OnChangeEditableTxt_Contents final
{
public:
	class FText                                   Text;                                              // 0x0000(0x0018)(ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
};
static_assert(alignof(MM_Popup_MailWrite_OnChangeEditableTxt_Contents) == 0x000008, "Wrong alignment on MM_Popup_MailWrite_OnChangeEditableTxt_Contents");
static_assert(sizeof(MM_Popup_MailWrite_OnChangeEditableTxt_Contents) == 0x000018, "Wrong size on MM_Popup_MailWrite_OnChangeEditableTxt_Contents");
static_assert(offsetof(MM_Popup_MailWrite_OnChangeEditableTxt_Contents, Text) == 0x000000, "Member 'MM_Popup_MailWrite_OnChangeEditableTxt_Contents::Text' has a wrong offset!");

// Function MirMobile.MM_Popup_MailWrite.OnChangeEditableTxt_Title
// 0x0018 (0x0018 - 0x0000)
struct MM_Popup_MailWrite_OnChangeEditableTxt_Title final
{
public:
	class FText                                   Text;                                              // 0x0000(0x0018)(ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
};
static_assert(alignof(MM_Popup_MailWrite_OnChangeEditableTxt_Title) == 0x000008, "Wrong alignment on MM_Popup_MailWrite_OnChangeEditableTxt_Title");
static_assert(sizeof(MM_Popup_MailWrite_OnChangeEditableTxt_Title) == 0x000018, "Wrong size on MM_Popup_MailWrite_OnChangeEditableTxt_Title");
static_assert(offsetof(MM_Popup_MailWrite_OnChangeEditableTxt_Title, Text) == 0x000000, "Member 'MM_Popup_MailWrite_OnChangeEditableTxt_Title::Text' has a wrong offset!");

// Function MirMobile.MM_Popup_MailWrite.OnEditableTxtContentsCommitted
// 0x0020 (0x0020 - 0x0000)
struct MM_Popup_MailWrite_OnEditableTxtContentsCommitted final
{
public:
	class FText                                   Text;                                              // 0x0000(0x0018)(ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
	ETextCommit                                   CommitMethod;                                      // 0x0018(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_19[0x7];                                       // 0x0019(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(MM_Popup_MailWrite_OnEditableTxtContentsCommitted) == 0x000008, "Wrong alignment on MM_Popup_MailWrite_OnEditableTxtContentsCommitted");
static_assert(sizeof(MM_Popup_MailWrite_OnEditableTxtContentsCommitted) == 0x000020, "Wrong size on MM_Popup_MailWrite_OnEditableTxtContentsCommitted");
static_assert(offsetof(MM_Popup_MailWrite_OnEditableTxtContentsCommitted, Text) == 0x000000, "Member 'MM_Popup_MailWrite_OnEditableTxtContentsCommitted::Text' has a wrong offset!");
static_assert(offsetof(MM_Popup_MailWrite_OnEditableTxtContentsCommitted, CommitMethod) == 0x000018, "Member 'MM_Popup_MailWrite_OnEditableTxtContentsCommitted::CommitMethod' has a wrong offset!");

// Function MirMobile.MM_Popup_MailWrite.OnEditableTxtTitleCommitted
// 0x0020 (0x0020 - 0x0000)
struct MM_Popup_MailWrite_OnEditableTxtTitleCommitted final
{
public:
	class FText                                   Text;                                              // 0x0000(0x0018)(ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
	ETextCommit                                   CommitMethod;                                      // 0x0018(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_19[0x7];                                       // 0x0019(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(MM_Popup_MailWrite_OnEditableTxtTitleCommitted) == 0x000008, "Wrong alignment on MM_Popup_MailWrite_OnEditableTxtTitleCommitted");
static_assert(sizeof(MM_Popup_MailWrite_OnEditableTxtTitleCommitted) == 0x000020, "Wrong size on MM_Popup_MailWrite_OnEditableTxtTitleCommitted");
static_assert(offsetof(MM_Popup_MailWrite_OnEditableTxtTitleCommitted, Text) == 0x000000, "Member 'MM_Popup_MailWrite_OnEditableTxtTitleCommitted::Text' has a wrong offset!");
static_assert(offsetof(MM_Popup_MailWrite_OnEditableTxtTitleCommitted, CommitMethod) == 0x000018, "Member 'MM_Popup_MailWrite_OnEditableTxtTitleCommitted::CommitMethod' has a wrong offset!");

// Function MirMobile.MM_Popup_NpcItemCraftMaterial.OnClickSlot
// 0x0008 (0x0008 - 0x0000)
struct MM_Popup_NpcItemCraftMaterial_OnClickSlot final
{
public:
	class UMM_Slot_Base*                          SlotBase;                                          // 0x0000(0x0008)(Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(MM_Popup_NpcItemCraftMaterial_OnClickSlot) == 0x000008, "Wrong alignment on MM_Popup_NpcItemCraftMaterial_OnClickSlot");
static_assert(sizeof(MM_Popup_NpcItemCraftMaterial_OnClickSlot) == 0x000008, "Wrong size on MM_Popup_NpcItemCraftMaterial_OnClickSlot");
static_assert(offsetof(MM_Popup_NpcItemCraftMaterial_OnClickSlot, SlotBase) == 0x000000, "Member 'MM_Popup_NpcItemCraftMaterial_OnClickSlot::SlotBase' has a wrong offset!");

// Function MirMobile.MM_Popup_NPCShopBuyCount.OnChangeCount
// 0x0008 (0x0008 - 0x0000)
struct MM_Popup_NPCShopBuyCount_OnChangeCount final
{
public:
	int64                                         IChangeValue;                                      // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(MM_Popup_NPCShopBuyCount_OnChangeCount) == 0x000008, "Wrong alignment on MM_Popup_NPCShopBuyCount_OnChangeCount");
static_assert(sizeof(MM_Popup_NPCShopBuyCount_OnChangeCount) == 0x000008, "Wrong size on MM_Popup_NPCShopBuyCount_OnChangeCount");
static_assert(offsetof(MM_Popup_NPCShopBuyCount_OnChangeCount, IChangeValue) == 0x000000, "Member 'MM_Popup_NPCShopBuyCount_OnChangeCount::IChangeValue' has a wrong offset!");

// Function MirMobile.MM_Popup_Profile.AddDeviceProfileImage
// 0x0018 (0x0018 - 0x0000)
struct MM_Popup_Profile_AddDeviceProfileImage final
{
public:
	class UTexture2D*                             PPhotoTexture;                                     // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 FailMessage;                                       // 0x0008(0x0010)(ConstParm, Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(MM_Popup_Profile_AddDeviceProfileImage) == 0x000008, "Wrong alignment on MM_Popup_Profile_AddDeviceProfileImage");
static_assert(sizeof(MM_Popup_Profile_AddDeviceProfileImage) == 0x000018, "Wrong size on MM_Popup_Profile_AddDeviceProfileImage");
static_assert(offsetof(MM_Popup_Profile_AddDeviceProfileImage, PPhotoTexture) == 0x000000, "Member 'MM_Popup_Profile_AddDeviceProfileImage::PPhotoTexture' has a wrong offset!");
static_assert(offsetof(MM_Popup_Profile_AddDeviceProfileImage, FailMessage) == 0x000008, "Member 'MM_Popup_Profile_AddDeviceProfileImage::FailMessage' has a wrong offset!");

// Function MirMobile.MM_Popup_Profile.CreateIcon
// 0x0018 (0x0018 - 0x0000)
struct MM_Popup_Profile_CreateIcon final
{
public:
	int32                                         Count;                                             // 0x0000(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_4[0x4];                                        // 0x0004(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<class UMM_ProfileSlot*>                ReturnValue;                                       // 0x0008(0x0010)(ExportObject, Parm, OutParm, ZeroConstructor, ReturnParm, ContainsInstancedReference, NativeAccessSpecifierPublic)
};
static_assert(alignof(MM_Popup_Profile_CreateIcon) == 0x000008, "Wrong alignment on MM_Popup_Profile_CreateIcon");
static_assert(sizeof(MM_Popup_Profile_CreateIcon) == 0x000018, "Wrong size on MM_Popup_Profile_CreateIcon");
static_assert(offsetof(MM_Popup_Profile_CreateIcon, Count) == 0x000000, "Member 'MM_Popup_Profile_CreateIcon::Count' has a wrong offset!");
static_assert(offsetof(MM_Popup_Profile_CreateIcon, ReturnValue) == 0x000008, "Member 'MM_Popup_Profile_CreateIcon::ReturnValue' has a wrong offset!");

// Function MirMobile.MM_Popup_Profile.SetUserProfileImage
// 0x0008 (0x0008 - 0x0000)
struct MM_Popup_Profile_SetUserProfileImage final
{
public:
	class UTexture2D*                             PProfileTexture;                                   // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(MM_Popup_Profile_SetUserProfileImage) == 0x000008, "Wrong alignment on MM_Popup_Profile_SetUserProfileImage");
static_assert(sizeof(MM_Popup_Profile_SetUserProfileImage) == 0x000008, "Wrong size on MM_Popup_Profile_SetUserProfileImage");
static_assert(offsetof(MM_Popup_Profile_SetUserProfileImage, PProfileTexture) == 0x000000, "Member 'MM_Popup_Profile_SetUserProfileImage::PProfileTexture' has a wrong offset!");

// Function MirMobile.MM_Popup_Profile.ShowUploadingBlockScreen
// 0x0001 (0x0001 - 0x0000)
struct MM_Popup_Profile_ShowUploadingBlockScreen final
{
public:
	bool                                          bShow;                                             // 0x0000(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(MM_Popup_Profile_ShowUploadingBlockScreen) == 0x000001, "Wrong alignment on MM_Popup_Profile_ShowUploadingBlockScreen");
static_assert(sizeof(MM_Popup_Profile_ShowUploadingBlockScreen) == 0x000001, "Wrong size on MM_Popup_Profile_ShowUploadingBlockScreen");
static_assert(offsetof(MM_Popup_Profile_ShowUploadingBlockScreen, bShow) == 0x000000, "Member 'MM_Popup_Profile_ShowUploadingBlockScreen::bShow' has a wrong offset!");

// Function MirMobile.MM_Popup_Profile.UploadProfileImageResult
// 0x0001 (0x0001 - 0x0000)
struct MM_Popup_Profile_UploadProfileImageResult final
{
public:
	bool                                          bSuccess;                                          // 0x0000(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(MM_Popup_Profile_UploadProfileImageResult) == 0x000001, "Wrong alignment on MM_Popup_Profile_UploadProfileImageResult");
static_assert(sizeof(MM_Popup_Profile_UploadProfileImageResult) == 0x000001, "Wrong size on MM_Popup_Profile_UploadProfileImageResult");
static_assert(offsetof(MM_Popup_Profile_UploadProfileImageResult, bSuccess) == 0x000000, "Member 'MM_Popup_Profile_UploadProfileImageResult::bSuccess' has a wrong offset!");

// Function MirMobile.MM_Popup_Restore_Exp.OnClickTab_Advanced
// 0x0001 (0x0001 - 0x0000)
struct MM_Popup_Restore_Exp_OnClickTab_Advanced final
{
public:
	bool                                          Checked;                                           // 0x0000(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(MM_Popup_Restore_Exp_OnClickTab_Advanced) == 0x000001, "Wrong alignment on MM_Popup_Restore_Exp_OnClickTab_Advanced");
static_assert(sizeof(MM_Popup_Restore_Exp_OnClickTab_Advanced) == 0x000001, "Wrong size on MM_Popup_Restore_Exp_OnClickTab_Advanced");
static_assert(offsetof(MM_Popup_Restore_Exp_OnClickTab_Advanced, Checked) == 0x000000, "Member 'MM_Popup_Restore_Exp_OnClickTab_Advanced::Checked' has a wrong offset!");

// Function MirMobile.MM_Popup_Restore_Exp.OnClickTab_General
// 0x0001 (0x0001 - 0x0000)
struct MM_Popup_Restore_Exp_OnClickTab_General final
{
public:
	bool                                          Checked;                                           // 0x0000(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(MM_Popup_Restore_Exp_OnClickTab_General) == 0x000001, "Wrong alignment on MM_Popup_Restore_Exp_OnClickTab_General");
static_assert(sizeof(MM_Popup_Restore_Exp_OnClickTab_General) == 0x000001, "Wrong size on MM_Popup_Restore_Exp_OnClickTab_General");
static_assert(offsetof(MM_Popup_Restore_Exp_OnClickTab_General, Checked) == 0x000000, "Member 'MM_Popup_Restore_Exp_OnClickTab_General::Checked' has a wrong offset!");

// Function MirMobile.MM_Popup_Restore_Exp.OnDeleteSlot
// 0x0004 (0x0004 - 0x0000)
struct MM_Popup_Restore_Exp_OnDeleteSlot final
{
public:
	int32                                         ISlotIndex;                                        // 0x0000(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(MM_Popup_Restore_Exp_OnDeleteSlot) == 0x000004, "Wrong alignment on MM_Popup_Restore_Exp_OnDeleteSlot");
static_assert(sizeof(MM_Popup_Restore_Exp_OnDeleteSlot) == 0x000004, "Wrong size on MM_Popup_Restore_Exp_OnDeleteSlot");
static_assert(offsetof(MM_Popup_Restore_Exp_OnDeleteSlot, ISlotIndex) == 0x000000, "Member 'MM_Popup_Restore_Exp_OnDeleteSlot::ISlotIndex' has a wrong offset!");

// Function MirMobile.MM_Popup_Restore_Exp.OnSelectSlot
// 0x0004 (0x0004 - 0x0000)
struct MM_Popup_Restore_Exp_OnSelectSlot final
{
public:
	int32                                         ISlotIndex;                                        // 0x0000(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(MM_Popup_Restore_Exp_OnSelectSlot) == 0x000004, "Wrong alignment on MM_Popup_Restore_Exp_OnSelectSlot");
static_assert(sizeof(MM_Popup_Restore_Exp_OnSelectSlot) == 0x000004, "Wrong size on MM_Popup_Restore_Exp_OnSelectSlot");
static_assert(offsetof(MM_Popup_Restore_Exp_OnSelectSlot, ISlotIndex) == 0x000000, "Member 'MM_Popup_Restore_Exp_OnSelectSlot::ISlotIndex' has a wrong offset!");

// Function MirMobile.MM_Popup_Sabuk_EmperorOrder_List_Slot.Bind_ClickDelegate
// 0x0018 (0x0018 - 0x0000)
struct MM_Popup_Sabuk_EmperorOrder_List_Slot_Bind_ClickDelegate final
{
public:
	int32                                         IIndex;                                            // 0x0000(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_4[0x4];                                        // 0x0004(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class UObject*                                PObj;                                              // 0x0008(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   FunctionName;                                      // 0x0010(0x0008)(ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(MM_Popup_Sabuk_EmperorOrder_List_Slot_Bind_ClickDelegate) == 0x000008, "Wrong alignment on MM_Popup_Sabuk_EmperorOrder_List_Slot_Bind_ClickDelegate");
static_assert(sizeof(MM_Popup_Sabuk_EmperorOrder_List_Slot_Bind_ClickDelegate) == 0x000018, "Wrong size on MM_Popup_Sabuk_EmperorOrder_List_Slot_Bind_ClickDelegate");
static_assert(offsetof(MM_Popup_Sabuk_EmperorOrder_List_Slot_Bind_ClickDelegate, IIndex) == 0x000000, "Member 'MM_Popup_Sabuk_EmperorOrder_List_Slot_Bind_ClickDelegate::IIndex' has a wrong offset!");
static_assert(offsetof(MM_Popup_Sabuk_EmperorOrder_List_Slot_Bind_ClickDelegate, PObj) == 0x000008, "Member 'MM_Popup_Sabuk_EmperorOrder_List_Slot_Bind_ClickDelegate::PObj' has a wrong offset!");
static_assert(offsetof(MM_Popup_Sabuk_EmperorOrder_List_Slot_Bind_ClickDelegate, FunctionName) == 0x000010, "Member 'MM_Popup_Sabuk_EmperorOrder_List_Slot_Bind_ClickDelegate::FunctionName' has a wrong offset!");

// Function MirMobile.MM_Popup_Sabuk_TaxRate_Adjust.OnChangeCheck
// 0x0008 (0x0008 - 0x0000)
struct MM_Popup_Sabuk_TaxRate_Adjust_OnChangeCheck final
{
public:
	int32                                         InWorldID;                                         // 0x0000(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          InChecked;                                         // 0x0004(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_5[0x3];                                        // 0x0005(0x0003)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(MM_Popup_Sabuk_TaxRate_Adjust_OnChangeCheck) == 0x000004, "Wrong alignment on MM_Popup_Sabuk_TaxRate_Adjust_OnChangeCheck");
static_assert(sizeof(MM_Popup_Sabuk_TaxRate_Adjust_OnChangeCheck) == 0x000008, "Wrong size on MM_Popup_Sabuk_TaxRate_Adjust_OnChangeCheck");
static_assert(offsetof(MM_Popup_Sabuk_TaxRate_Adjust_OnChangeCheck, InWorldID) == 0x000000, "Member 'MM_Popup_Sabuk_TaxRate_Adjust_OnChangeCheck::InWorldID' has a wrong offset!");
static_assert(offsetof(MM_Popup_Sabuk_TaxRate_Adjust_OnChangeCheck, InChecked) == 0x000004, "Member 'MM_Popup_Sabuk_TaxRate_Adjust_OnChangeCheck::InChecked' has a wrong offset!");

// Function MirMobile.MM_Popup_Sabuk_TaxRate_Adjust.OnChangeTaxRate
// 0x0008 (0x0008 - 0x0000)
struct MM_Popup_Sabuk_TaxRate_Adjust_OnChangeTaxRate final
{
public:
	int32                                         InWorldID;                                         // 0x0000(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         InTaxRate;                                         // 0x0004(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(MM_Popup_Sabuk_TaxRate_Adjust_OnChangeTaxRate) == 0x000004, "Wrong alignment on MM_Popup_Sabuk_TaxRate_Adjust_OnChangeTaxRate");
static_assert(sizeof(MM_Popup_Sabuk_TaxRate_Adjust_OnChangeTaxRate) == 0x000008, "Wrong size on MM_Popup_Sabuk_TaxRate_Adjust_OnChangeTaxRate");
static_assert(offsetof(MM_Popup_Sabuk_TaxRate_Adjust_OnChangeTaxRate, InWorldID) == 0x000000, "Member 'MM_Popup_Sabuk_TaxRate_Adjust_OnChangeTaxRate::InWorldID' has a wrong offset!");
static_assert(offsetof(MM_Popup_Sabuk_TaxRate_Adjust_OnChangeTaxRate, InTaxRate) == 0x000004, "Member 'MM_Popup_Sabuk_TaxRate_Adjust_OnChangeTaxRate::InTaxRate' has a wrong offset!");

// Function MirMobile.MM_Popup_Sabuk_TaxRate_Adjust.OnClickAllCheck
// 0x0001 (0x0001 - 0x0000)
struct MM_Popup_Sabuk_TaxRate_Adjust_OnClickAllCheck final
{
public:
	bool                                          bChecked;                                          // 0x0000(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(MM_Popup_Sabuk_TaxRate_Adjust_OnClickAllCheck) == 0x000001, "Wrong alignment on MM_Popup_Sabuk_TaxRate_Adjust_OnClickAllCheck");
static_assert(sizeof(MM_Popup_Sabuk_TaxRate_Adjust_OnClickAllCheck) == 0x000001, "Wrong size on MM_Popup_Sabuk_TaxRate_Adjust_OnClickAllCheck");
static_assert(offsetof(MM_Popup_Sabuk_TaxRate_Adjust_OnClickAllCheck, bChecked) == 0x000000, "Member 'MM_Popup_Sabuk_TaxRate_Adjust_OnClickAllCheck::bChecked' has a wrong offset!");

// Function MirMobile.MM_Popup_Sabuk_TaxRate_Adjust.OnSetAllTaxRate
// 0x0004 (0x0004 - 0x0000)
struct MM_Popup_Sabuk_TaxRate_Adjust_OnSetAllTaxRate final
{
public:
	int32                                         ITaxRate;                                          // 0x0000(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(MM_Popup_Sabuk_TaxRate_Adjust_OnSetAllTaxRate) == 0x000004, "Wrong alignment on MM_Popup_Sabuk_TaxRate_Adjust_OnSetAllTaxRate");
static_assert(sizeof(MM_Popup_Sabuk_TaxRate_Adjust_OnSetAllTaxRate) == 0x000004, "Wrong size on MM_Popup_Sabuk_TaxRate_Adjust_OnSetAllTaxRate");
static_assert(offsetof(MM_Popup_Sabuk_TaxRate_Adjust_OnSetAllTaxRate, ITaxRate) == 0x000000, "Member 'MM_Popup_Sabuk_TaxRate_Adjust_OnSetAllTaxRate::ITaxRate' has a wrong offset!");

// Function MirMobile.MM_Popup_Sabuk_TaxRate_Adjust_Slot.OnCheckSelect
// 0x0001 (0x0001 - 0x0000)
struct MM_Popup_Sabuk_TaxRate_Adjust_Slot_OnCheckSelect final
{
public:
	bool                                          bChecked;                                          // 0x0000(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(MM_Popup_Sabuk_TaxRate_Adjust_Slot_OnCheckSelect) == 0x000001, "Wrong alignment on MM_Popup_Sabuk_TaxRate_Adjust_Slot_OnCheckSelect");
static_assert(sizeof(MM_Popup_Sabuk_TaxRate_Adjust_Slot_OnCheckSelect) == 0x000001, "Wrong size on MM_Popup_Sabuk_TaxRate_Adjust_Slot_OnCheckSelect");
static_assert(offsetof(MM_Popup_Sabuk_TaxRate_Adjust_Slot_OnCheckSelect, bChecked) == 0x000000, "Member 'MM_Popup_Sabuk_TaxRate_Adjust_Slot_OnCheckSelect::bChecked' has a wrong offset!");

// Function MirMobile.MM_Popup_Sabuk_TaxRate_Adjust_Slot.OnSetTaxRate
// 0x0004 (0x0004 - 0x0000)
struct MM_Popup_Sabuk_TaxRate_Adjust_Slot_OnSetTaxRate final
{
public:
	int32                                         ITaxRate;                                          // 0x0000(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(MM_Popup_Sabuk_TaxRate_Adjust_Slot_OnSetTaxRate) == 0x000004, "Wrong alignment on MM_Popup_Sabuk_TaxRate_Adjust_Slot_OnSetTaxRate");
static_assert(sizeof(MM_Popup_Sabuk_TaxRate_Adjust_Slot_OnSetTaxRate) == 0x000004, "Wrong size on MM_Popup_Sabuk_TaxRate_Adjust_Slot_OnSetTaxRate");
static_assert(offsetof(MM_Popup_Sabuk_TaxRate_Adjust_Slot_OnSetTaxRate, ITaxRate) == 0x000000, "Member 'MM_Popup_Sabuk_TaxRate_Adjust_Slot_OnSetTaxRate::ITaxRate' has a wrong offset!");

// Function MirMobile.MM_PopUp_SaleItem.OnChangeCount
// 0x0008 (0x0008 - 0x0000)
struct MM_PopUp_SaleItem_OnChangeCount final
{
public:
	int64                                         IChangeValue;                                      // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(MM_PopUp_SaleItem_OnChangeCount) == 0x000008, "Wrong alignment on MM_PopUp_SaleItem_OnChangeCount");
static_assert(sizeof(MM_PopUp_SaleItem_OnChangeCount) == 0x000008, "Wrong size on MM_PopUp_SaleItem_OnChangeCount");
static_assert(offsetof(MM_PopUp_SaleItem_OnChangeCount, IChangeValue) == 0x000000, "Member 'MM_PopUp_SaleItem_OnChangeCount::IChangeValue' has a wrong offset!");

// Function MirMobile.TownAlarmWidget.ShowTownAlarm
// 0x0004 (0x0004 - 0x0000)
struct TownAlarmWidget_ShowTownAlarm final
{
public:
	int32                                         AreaId;                                            // 0x0000(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(TownAlarmWidget_ShowTownAlarm) == 0x000004, "Wrong alignment on TownAlarmWidget_ShowTownAlarm");
static_assert(sizeof(TownAlarmWidget_ShowTownAlarm) == 0x000004, "Wrong size on TownAlarmWidget_ShowTownAlarm");
static_assert(offsetof(TownAlarmWidget_ShowTownAlarm, AreaId) == 0x000000, "Member 'TownAlarmWidget_ShowTownAlarm::AreaId' has a wrong offset!");

// Function MirMobile.MM_PopUp_StatusContents.OnClickContents_Go
// 0x0004 (0x0004 - 0x0000)
struct MM_PopUp_StatusContents_OnClickContents_Go final
{
public:
	int32                                         ContentsId;                                        // 0x0000(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(MM_PopUp_StatusContents_OnClickContents_Go) == 0x000004, "Wrong alignment on MM_PopUp_StatusContents_OnClickContents_Go");
static_assert(sizeof(MM_PopUp_StatusContents_OnClickContents_Go) == 0x000004, "Wrong size on MM_PopUp_StatusContents_OnClickContents_Go");
static_assert(offsetof(MM_PopUp_StatusContents_OnClickContents_Go, ContentsId) == 0x000000, "Member 'MM_PopUp_StatusContents_OnClickContents_Go::ContentsId' has a wrong offset!");

// Function MirMobile.MM_Popup_UIShopBuyGoods.OnFailDownloadImage
// 0x0008 (0x0008 - 0x0000)
struct MM_Popup_UIShopBuyGoods_OnFailDownloadImage final
{
public:
	class UTexture2DDynamic*                      Texture;                                           // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(MM_Popup_UIShopBuyGoods_OnFailDownloadImage) == 0x000008, "Wrong alignment on MM_Popup_UIShopBuyGoods_OnFailDownloadImage");
static_assert(sizeof(MM_Popup_UIShopBuyGoods_OnFailDownloadImage) == 0x000008, "Wrong size on MM_Popup_UIShopBuyGoods_OnFailDownloadImage");
static_assert(offsetof(MM_Popup_UIShopBuyGoods_OnFailDownloadImage, Texture) == 0x000000, "Member 'MM_Popup_UIShopBuyGoods_OnFailDownloadImage::Texture' has a wrong offset!");

// Function MirMobile.MM_Popup_UIShopBuyGoods.OnSuccessDownloadImage
// 0x0008 (0x0008 - 0x0000)
struct MM_Popup_UIShopBuyGoods_OnSuccessDownloadImage final
{
public:
	class UTexture2DDynamic*                      Texture;                                           // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(MM_Popup_UIShopBuyGoods_OnSuccessDownloadImage) == 0x000008, "Wrong alignment on MM_Popup_UIShopBuyGoods_OnSuccessDownloadImage");
static_assert(sizeof(MM_Popup_UIShopBuyGoods_OnSuccessDownloadImage) == 0x000008, "Wrong size on MM_Popup_UIShopBuyGoods_OnSuccessDownloadImage");
static_assert(offsetof(MM_Popup_UIShopBuyGoods_OnSuccessDownloadImage, Texture) == 0x000000, "Member 'MM_Popup_UIShopBuyGoods_OnSuccessDownloadImage::Texture' has a wrong offset!");

// Function MirMobile.MM_Popup_WantedRegist.OnSetValueByKeypad
// 0x0008 (0x0008 - 0x0000)
struct MM_Popup_WantedRegist_OnSetValueByKeypad final
{
public:
	int64                                         Value;                                             // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(MM_Popup_WantedRegist_OnSetValueByKeypad) == 0x000008, "Wrong alignment on MM_Popup_WantedRegist_OnSetValueByKeypad");
static_assert(sizeof(MM_Popup_WantedRegist_OnSetValueByKeypad) == 0x000008, "Wrong size on MM_Popup_WantedRegist_OnSetValueByKeypad");
static_assert(offsetof(MM_Popup_WantedRegist_OnSetValueByKeypad, Value) == 0x000000, "Member 'MM_Popup_WantedRegist_OnSetValueByKeypad::Value' has a wrong offset!");

// Function MirMobile.MM_PopupCharacterSearchEdit.OnTextCommitted
// 0x0020 (0x0020 - 0x0000)
struct MM_PopupCharacterSearchEdit_OnTextCommitted final
{
public:
	class FText                                   Text_;                                             // 0x0000(0x0018)(ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
	ETextCommit                                   Commit_method_;                                    // 0x0018(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_19[0x7];                                       // 0x0019(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(MM_PopupCharacterSearchEdit_OnTextCommitted) == 0x000008, "Wrong alignment on MM_PopupCharacterSearchEdit_OnTextCommitted");
static_assert(sizeof(MM_PopupCharacterSearchEdit_OnTextCommitted) == 0x000020, "Wrong size on MM_PopupCharacterSearchEdit_OnTextCommitted");
static_assert(offsetof(MM_PopupCharacterSearchEdit_OnTextCommitted, Text_) == 0x000000, "Member 'MM_PopupCharacterSearchEdit_OnTextCommitted::Text_' has a wrong offset!");
static_assert(offsetof(MM_PopupCharacterSearchEdit_OnTextCommitted, Commit_method_) == 0x000018, "Member 'MM_PopupCharacterSearchEdit_OnTextCommitted::Commit_method_' has a wrong offset!");

// Function MirMobile.MM_PopupExpBoosterCharge.OnChangeCount
// 0x0008 (0x0008 - 0x0000)
struct MM_PopupExpBoosterCharge_OnChangeCount final
{
public:
	int64                                         Count_;                                            // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(MM_PopupExpBoosterCharge_OnChangeCount) == 0x000008, "Wrong alignment on MM_PopupExpBoosterCharge_OnChangeCount");
static_assert(sizeof(MM_PopupExpBoosterCharge_OnChangeCount) == 0x000008, "Wrong size on MM_PopupExpBoosterCharge_OnChangeCount");
static_assert(offsetof(MM_PopupExpBoosterCharge_OnChangeCount, Count_) == 0x000000, "Member 'MM_PopupExpBoosterCharge_OnChangeCount::Count_' has a wrong offset!");

// Function MirMobile.MM_PopupExpBoosterCharge.OnClickSlot
// 0x0010 (0x0010 - 0x0000)
struct MM_PopupExpBoosterCharge_OnClickSlot final
{
public:
	int64                                         Item_uid_;                                         // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         Item_tid_;                                         // 0x0008(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         Equip_id_;                                         // 0x000C(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(MM_PopupExpBoosterCharge_OnClickSlot) == 0x000008, "Wrong alignment on MM_PopupExpBoosterCharge_OnClickSlot");
static_assert(sizeof(MM_PopupExpBoosterCharge_OnClickSlot) == 0x000010, "Wrong size on MM_PopupExpBoosterCharge_OnClickSlot");
static_assert(offsetof(MM_PopupExpBoosterCharge_OnClickSlot, Item_uid_) == 0x000000, "Member 'MM_PopupExpBoosterCharge_OnClickSlot::Item_uid_' has a wrong offset!");
static_assert(offsetof(MM_PopupExpBoosterCharge_OnClickSlot, Item_tid_) == 0x000008, "Member 'MM_PopupExpBoosterCharge_OnClickSlot::Item_tid_' has a wrong offset!");
static_assert(offsetof(MM_PopupExpBoosterCharge_OnClickSlot, Equip_id_) == 0x00000C, "Member 'MM_PopupExpBoosterCharge_OnClickSlot::Equip_id_' has a wrong offset!");

// Function MirMobile.MM_PopupGuildDonationDetails.OnClickDaily
// 0x0001 (0x0001 - 0x0000)
struct MM_PopupGuildDonationDetails_OnClickDaily final
{
public:
	bool                                          Check_;                                            // 0x0000(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(MM_PopupGuildDonationDetails_OnClickDaily) == 0x000001, "Wrong alignment on MM_PopupGuildDonationDetails_OnClickDaily");
static_assert(sizeof(MM_PopupGuildDonationDetails_OnClickDaily) == 0x000001, "Wrong size on MM_PopupGuildDonationDetails_OnClickDaily");
static_assert(offsetof(MM_PopupGuildDonationDetails_OnClickDaily, Check_) == 0x000000, "Member 'MM_PopupGuildDonationDetails_OnClickDaily::Check_' has a wrong offset!");

// Function MirMobile.MM_PopupGuildDonationDetails.OnClickSort
// 0x0001 (0x0001 - 0x0000)
struct MM_PopupGuildDonationDetails_OnClickSort final
{
public:
	bool                                          Check_;                                            // 0x0000(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(MM_PopupGuildDonationDetails_OnClickSort) == 0x000001, "Wrong alignment on MM_PopupGuildDonationDetails_OnClickSort");
static_assert(sizeof(MM_PopupGuildDonationDetails_OnClickSort) == 0x000001, "Wrong size on MM_PopupGuildDonationDetails_OnClickSort");
static_assert(offsetof(MM_PopupGuildDonationDetails_OnClickSort, Check_) == 0x000000, "Member 'MM_PopupGuildDonationDetails_OnClickSort::Check_' has a wrong offset!");

// Function MirMobile.MM_PopupGuildDonationDetails.OnClickWeekly
// 0x0001 (0x0001 - 0x0000)
struct MM_PopupGuildDonationDetails_OnClickWeekly final
{
public:
	bool                                          Check_;                                            // 0x0000(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(MM_PopupGuildDonationDetails_OnClickWeekly) == 0x000001, "Wrong alignment on MM_PopupGuildDonationDetails_OnClickWeekly");
static_assert(sizeof(MM_PopupGuildDonationDetails_OnClickWeekly) == 0x000001, "Wrong size on MM_PopupGuildDonationDetails_OnClickWeekly");
static_assert(offsetof(MM_PopupGuildDonationDetails_OnClickWeekly, Check_) == 0x000000, "Member 'MM_PopupGuildDonationDetails_OnClickWeekly::Check_' has a wrong offset!");

// Function MirMobile.MM_PopupGuildGiveAlliance.OnClickAllSelect
// 0x0001 (0x0001 - 0x0000)
struct MM_PopupGuildGiveAlliance_OnClickAllSelect final
{
public:
	bool                                          Checked_;                                          // 0x0000(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(MM_PopupGuildGiveAlliance_OnClickAllSelect) == 0x000001, "Wrong alignment on MM_PopupGuildGiveAlliance_OnClickAllSelect");
static_assert(sizeof(MM_PopupGuildGiveAlliance_OnClickAllSelect) == 0x000001, "Wrong size on MM_PopupGuildGiveAlliance_OnClickAllSelect");
static_assert(offsetof(MM_PopupGuildGiveAlliance_OnClickAllSelect, Checked_) == 0x000000, "Member 'MM_PopupGuildGiveAlliance_OnClickAllSelect::Checked_' has a wrong offset!");

// Function MirMobile.MM_PopupGuildGiveAlliance.OnClickSortCheckBox
// 0x0001 (0x0001 - 0x0000)
struct MM_PopupGuildGiveAlliance_OnClickSortCheckBox final
{
public:
	bool                                          Checked_;                                          // 0x0000(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(MM_PopupGuildGiveAlliance_OnClickSortCheckBox) == 0x000001, "Wrong alignment on MM_PopupGuildGiveAlliance_OnClickSortCheckBox");
static_assert(sizeof(MM_PopupGuildGiveAlliance_OnClickSortCheckBox) == 0x000001, "Wrong size on MM_PopupGuildGiveAlliance_OnClickSortCheckBox");
static_assert(offsetof(MM_PopupGuildGiveAlliance_OnClickSortCheckBox, Checked_) == 0x000000, "Member 'MM_PopupGuildGiveAlliance_OnClickSortCheckBox::Checked_' has a wrong offset!");

// Function MirMobile.MM_PopupGuildGiveAllianceSlot.OnClickCheckBox
// 0x0001 (0x0001 - 0x0000)
struct MM_PopupGuildGiveAllianceSlot_OnClickCheckBox final
{
public:
	bool                                          Check_;                                            // 0x0000(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(MM_PopupGuildGiveAllianceSlot_OnClickCheckBox) == 0x000001, "Wrong alignment on MM_PopupGuildGiveAllianceSlot_OnClickCheckBox");
static_assert(sizeof(MM_PopupGuildGiveAllianceSlot_OnClickCheckBox) == 0x000001, "Wrong size on MM_PopupGuildGiveAllianceSlot_OnClickCheckBox");
static_assert(offsetof(MM_PopupGuildGiveAllianceSlot_OnClickCheckBox, Check_) == 0x000000, "Member 'MM_PopupGuildGiveAllianceSlot_OnClickCheckBox::Check_' has a wrong offset!");

// Function MirMobile.MM_Xdraco_SealingInfo.OnClickMaterialItemSlot
// 0x0008 (0x0008 - 0x0000)
struct MM_Xdraco_SealingInfo_OnClickMaterialItemSlot final
{
public:
	class UMM_Slot_Base*                          PSlot;                                             // 0x0000(0x0008)(Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(MM_Xdraco_SealingInfo_OnClickMaterialItemSlot) == 0x000008, "Wrong alignment on MM_Xdraco_SealingInfo_OnClickMaterialItemSlot");
static_assert(sizeof(MM_Xdraco_SealingInfo_OnClickMaterialItemSlot) == 0x000008, "Wrong size on MM_Xdraco_SealingInfo_OnClickMaterialItemSlot");
static_assert(offsetof(MM_Xdraco_SealingInfo_OnClickMaterialItemSlot, PSlot) == 0x000000, "Member 'MM_Xdraco_SealingInfo_OnClickMaterialItemSlot::PSlot' has a wrong offset!");

// Function MirMobile.MM_Xdraco_SealingInfo.OnClickSealingItem
// 0x0010 (0x0010 - 0x0000)
struct MM_Xdraco_SealingInfo_OnClickSealingItem final
{
public:
	int64                                         _UID;                                              // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         _TID;                                              // 0x0008(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         _Pos;                                              // 0x000C(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(MM_Xdraco_SealingInfo_OnClickSealingItem) == 0x000008, "Wrong alignment on MM_Xdraco_SealingInfo_OnClickSealingItem");
static_assert(sizeof(MM_Xdraco_SealingInfo_OnClickSealingItem) == 0x000010, "Wrong size on MM_Xdraco_SealingInfo_OnClickSealingItem");
static_assert(offsetof(MM_Xdraco_SealingInfo_OnClickSealingItem, _UID) == 0x000000, "Member 'MM_Xdraco_SealingInfo_OnClickSealingItem::_UID' has a wrong offset!");
static_assert(offsetof(MM_Xdraco_SealingInfo_OnClickSealingItem, _TID) == 0x000008, "Member 'MM_Xdraco_SealingInfo_OnClickSealingItem::_TID' has a wrong offset!");
static_assert(offsetof(MM_Xdraco_SealingInfo_OnClickSealingItem, _Pos) == 0x00000C, "Member 'MM_Xdraco_SealingInfo_OnClickSealingItem::_Pos' has a wrong offset!");

// Function MirMobile.MM_PopupGuildGivePersonalSlot.OnClickCheckBox
// 0x0001 (0x0001 - 0x0000)
struct MM_PopupGuildGivePersonalSlot_OnClickCheckBox final
{
public:
	bool                                          Check_;                                            // 0x0000(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(MM_PopupGuildGivePersonalSlot_OnClickCheckBox) == 0x000001, "Wrong alignment on MM_PopupGuildGivePersonalSlot_OnClickCheckBox");
static_assert(sizeof(MM_PopupGuildGivePersonalSlot_OnClickCheckBox) == 0x000001, "Wrong size on MM_PopupGuildGivePersonalSlot_OnClickCheckBox");
static_assert(offsetof(MM_PopupGuildGivePersonalSlot_OnClickCheckBox, Check_) == 0x000000, "Member 'MM_PopupGuildGivePersonalSlot_OnClickCheckBox::Check_' has a wrong offset!");

// Function MirMobile.MM_PopupGuildMembers.OnChangeCustomTitle
// 0x0018 (0x0018 - 0x0000)
struct MM_PopupGuildMembers_OnChangeCustomTitle final
{
public:
	class FText                                   Text_;                                             // 0x0000(0x0018)(ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
};
static_assert(alignof(MM_PopupGuildMembers_OnChangeCustomTitle) == 0x000008, "Wrong alignment on MM_PopupGuildMembers_OnChangeCustomTitle");
static_assert(sizeof(MM_PopupGuildMembers_OnChangeCustomTitle) == 0x000018, "Wrong size on MM_PopupGuildMembers_OnChangeCustomTitle");
static_assert(offsetof(MM_PopupGuildMembers_OnChangeCustomTitle, Text_) == 0x000000, "Member 'MM_PopupGuildMembers_OnChangeCustomTitle::Text_' has a wrong offset!");

// Function MirMobile.MM_PopupGuildMembers.OnClickSetCustomTitle
// 0x0010 (0x0010 - 0x0000)
struct MM_PopupGuildMembers_OnClickSetCustomTitle final
{
public:
	class FString                                 Edit_text_;                                        // 0x0000(0x0010)(Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(MM_PopupGuildMembers_OnClickSetCustomTitle) == 0x000008, "Wrong alignment on MM_PopupGuildMembers_OnClickSetCustomTitle");
static_assert(sizeof(MM_PopupGuildMembers_OnClickSetCustomTitle) == 0x000010, "Wrong size on MM_PopupGuildMembers_OnClickSetCustomTitle");
static_assert(offsetof(MM_PopupGuildMembers_OnClickSetCustomTitle, Edit_text_) == 0x000000, "Member 'MM_PopupGuildMembers_OnClickSetCustomTitle::Edit_text_' has a wrong offset!");

// Function MirMobile.MM_PopupGuildMembers.OnClickSetCustomTitleReset
// 0x0010 (0x0010 - 0x0000)
struct MM_PopupGuildMembers_OnClickSetCustomTitleReset final
{
public:
	class FString                                 Edit_text_;                                        // 0x0000(0x0010)(Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(MM_PopupGuildMembers_OnClickSetCustomTitleReset) == 0x000008, "Wrong alignment on MM_PopupGuildMembers_OnClickSetCustomTitleReset");
static_assert(sizeof(MM_PopupGuildMembers_OnClickSetCustomTitleReset) == 0x000010, "Wrong size on MM_PopupGuildMembers_OnClickSetCustomTitleReset");
static_assert(offsetof(MM_PopupGuildMembers_OnClickSetCustomTitleReset, Edit_text_) == 0x000000, "Member 'MM_PopupGuildMembers_OnClickSetCustomTitleReset::Edit_text_' has a wrong offset!");

// Function MirMobile.MM_PopupGuildMembers.OnClickToggle00
// 0x0001 (0x0001 - 0x0000)
struct MM_PopupGuildMembers_OnClickToggle00 final
{
public:
	bool                                          Check_;                                            // 0x0000(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(MM_PopupGuildMembers_OnClickToggle00) == 0x000001, "Wrong alignment on MM_PopupGuildMembers_OnClickToggle00");
static_assert(sizeof(MM_PopupGuildMembers_OnClickToggle00) == 0x000001, "Wrong size on MM_PopupGuildMembers_OnClickToggle00");
static_assert(offsetof(MM_PopupGuildMembers_OnClickToggle00, Check_) == 0x000000, "Member 'MM_PopupGuildMembers_OnClickToggle00::Check_' has a wrong offset!");

// Function MirMobile.MM_PopupGuildMembers.OnClickToggle01
// 0x0001 (0x0001 - 0x0000)
struct MM_PopupGuildMembers_OnClickToggle01 final
{
public:
	bool                                          Check_;                                            // 0x0000(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(MM_PopupGuildMembers_OnClickToggle01) == 0x000001, "Wrong alignment on MM_PopupGuildMembers_OnClickToggle01");
static_assert(sizeof(MM_PopupGuildMembers_OnClickToggle01) == 0x000001, "Wrong size on MM_PopupGuildMembers_OnClickToggle01");
static_assert(offsetof(MM_PopupGuildMembers_OnClickToggle01, Check_) == 0x000000, "Member 'MM_PopupGuildMembers_OnClickToggle01::Check_' has a wrong offset!");

// Function MirMobile.MM_PopupGuildMembers.OnClickToggle02
// 0x0001 (0x0001 - 0x0000)
struct MM_PopupGuildMembers_OnClickToggle02 final
{
public:
	bool                                          Check_;                                            // 0x0000(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(MM_PopupGuildMembers_OnClickToggle02) == 0x000001, "Wrong alignment on MM_PopupGuildMembers_OnClickToggle02");
static_assert(sizeof(MM_PopupGuildMembers_OnClickToggle02) == 0x000001, "Wrong size on MM_PopupGuildMembers_OnClickToggle02");
static_assert(offsetof(MM_PopupGuildMembers_OnClickToggle02, Check_) == 0x000000, "Member 'MM_PopupGuildMembers_OnClickToggle02::Check_' has a wrong offset!");

// Function MirMobile.MM_PopupGuildMembers.OnClickToggle03
// 0x0001 (0x0001 - 0x0000)
struct MM_PopupGuildMembers_OnClickToggle03 final
{
public:
	bool                                          Check_;                                            // 0x0000(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(MM_PopupGuildMembers_OnClickToggle03) == 0x000001, "Wrong alignment on MM_PopupGuildMembers_OnClickToggle03");
static_assert(sizeof(MM_PopupGuildMembers_OnClickToggle03) == 0x000001, "Wrong size on MM_PopupGuildMembers_OnClickToggle03");
static_assert(offsetof(MM_PopupGuildMembers_OnClickToggle03, Check_) == 0x000000, "Member 'MM_PopupGuildMembers_OnClickToggle03::Check_' has a wrong offset!");

// Function MirMobile.MM_PopupGuildMembers.OnEditCommitCustomTitle
// 0x0020 (0x0020 - 0x0000)
struct MM_PopupGuildMembers_OnEditCommitCustomTitle final
{
public:
	class FText                                   Text_;                                             // 0x0000(0x0018)(ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
	ETextCommit                                   Type_;                                             // 0x0018(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_19[0x7];                                       // 0x0019(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(MM_PopupGuildMembers_OnEditCommitCustomTitle) == 0x000008, "Wrong alignment on MM_PopupGuildMembers_OnEditCommitCustomTitle");
static_assert(sizeof(MM_PopupGuildMembers_OnEditCommitCustomTitle) == 0x000020, "Wrong size on MM_PopupGuildMembers_OnEditCommitCustomTitle");
static_assert(offsetof(MM_PopupGuildMembers_OnEditCommitCustomTitle, Text_) == 0x000000, "Member 'MM_PopupGuildMembers_OnEditCommitCustomTitle::Text_' has a wrong offset!");
static_assert(offsetof(MM_PopupGuildMembers_OnEditCommitCustomTitle, Type_) == 0x000018, "Member 'MM_PopupGuildMembers_OnEditCommitCustomTitle::Type_' has a wrong offset!");

// Function MirMobile.MM_PopupGuildPartner.OnClickCheckBoxSort
// 0x0001 (0x0001 - 0x0000)
struct MM_PopupGuildPartner_OnClickCheckBoxSort final
{
public:
	bool                                          Checked_;                                          // 0x0000(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(MM_PopupGuildPartner_OnClickCheckBoxSort) == 0x000001, "Wrong alignment on MM_PopupGuildPartner_OnClickCheckBoxSort");
static_assert(sizeof(MM_PopupGuildPartner_OnClickCheckBoxSort) == 0x000001, "Wrong size on MM_PopupGuildPartner_OnClickCheckBoxSort");
static_assert(offsetof(MM_PopupGuildPartner_OnClickCheckBoxSort, Checked_) == 0x000000, "Member 'MM_PopupGuildPartner_OnClickCheckBoxSort::Checked_' has a wrong offset!");

// Function MirMobile.MM_Potential_Node.AdjustPos_LevelText
// 0x0010 (0x0010 - 0x0000)
struct MM_Potential_Node_AdjustPos_LevelText final
{
public:
	class UMirTextBlock*                          PTxt_Level;                                        // 0x0000(0x0008)(Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UMirImage*                              PImg_Node;                                         // 0x0008(0x0008)(Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(MM_Potential_Node_AdjustPos_LevelText) == 0x000008, "Wrong alignment on MM_Potential_Node_AdjustPos_LevelText");
static_assert(sizeof(MM_Potential_Node_AdjustPos_LevelText) == 0x000010, "Wrong size on MM_Potential_Node_AdjustPos_LevelText");
static_assert(offsetof(MM_Potential_Node_AdjustPos_LevelText, PTxt_Level) == 0x000000, "Member 'MM_Potential_Node_AdjustPos_LevelText::PTxt_Level' has a wrong offset!");
static_assert(offsetof(MM_Potential_Node_AdjustPos_LevelText, PImg_Node) == 0x000008, "Member 'MM_Potential_Node_AdjustPos_LevelText::PImg_Node' has a wrong offset!");

// Function MirMobile.MM_ProfileImageEditor.SetBrushTextureEvent
// 0x0008 (0x0008 - 0x0000)
struct MM_ProfileImageEditor_SetBrushTextureEvent final
{
public:
	class UTexture2D*                             PPhotoTexture;                                     // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(MM_ProfileImageEditor_SetBrushTextureEvent) == 0x000008, "Wrong alignment on MM_ProfileImageEditor_SetBrushTextureEvent");
static_assert(sizeof(MM_ProfileImageEditor_SetBrushTextureEvent) == 0x000008, "Wrong size on MM_ProfileImageEditor_SetBrushTextureEvent");
static_assert(offsetof(MM_ProfileImageEditor_SetBrushTextureEvent, PPhotoTexture) == 0x000000, "Member 'MM_ProfileImageEditor_SetBrushTextureEvent::PPhotoTexture' has a wrong offset!");

// Function MirMobile.MM_ProfileImageEditor.SetPhotoTexture
// 0x0008 (0x0008 - 0x0000)
struct MM_ProfileImageEditor_SetPhotoTexture final
{
public:
	class UTexture2D*                             PPhotoTexture;                                     // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(MM_ProfileImageEditor_SetPhotoTexture) == 0x000008, "Wrong alignment on MM_ProfileImageEditor_SetPhotoTexture");
static_assert(sizeof(MM_ProfileImageEditor_SetPhotoTexture) == 0x000008, "Wrong size on MM_ProfileImageEditor_SetPhotoTexture");
static_assert(offsetof(MM_ProfileImageEditor_SetPhotoTexture, PPhotoTexture) == 0x000000, "Member 'MM_ProfileImageEditor_SetPhotoTexture::PPhotoTexture' has a wrong offset!");

// Function MirMobile.MM_QuestNormal_Auto.OnClickAllCheckBox
// 0x0001 (0x0001 - 0x0000)
struct MM_QuestNormal_Auto_OnClickAllCheckBox final
{
public:
	bool                                          bChecked;                                          // 0x0000(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(MM_QuestNormal_Auto_OnClickAllCheckBox) == 0x000001, "Wrong alignment on MM_QuestNormal_Auto_OnClickAllCheckBox");
static_assert(sizeof(MM_QuestNormal_Auto_OnClickAllCheckBox) == 0x000001, "Wrong size on MM_QuestNormal_Auto_OnClickAllCheckBox");
static_assert(offsetof(MM_QuestNormal_Auto_OnClickAllCheckBox, bChecked) == 0x000000, "Member 'MM_QuestNormal_Auto_OnClickAllCheckBox::bChecked' has a wrong offset!");

// Function MirMobile.MM_RelationQuestDetailList.Request_ChildMax
// 0x0004 (0x0004 - 0x0000)
struct MM_RelationQuestDetailList_Request_ChildMax final
{
public:
	int32                                         ReturnValue;                                       // 0x0000(0x0004)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(MM_RelationQuestDetailList_Request_ChildMax) == 0x000004, "Wrong alignment on MM_RelationQuestDetailList_Request_ChildMax");
static_assert(sizeof(MM_RelationQuestDetailList_Request_ChildMax) == 0x000004, "Wrong size on MM_RelationQuestDetailList_Request_ChildMax");
static_assert(offsetof(MM_RelationQuestDetailList_Request_ChildMax, ReturnValue) == 0x000000, "Member 'MM_RelationQuestDetailList_Request_ChildMax::ReturnValue' has a wrong offset!");

// Function MirMobile.MM_Sabuk_Dominion_Office.OnClickGuildMember
// 0x0008 (0x0008 - 0x0000)
struct MM_Sabuk_Dominion_Office_OnClickGuildMember final
{
public:
	int64                                         IGuildMemberUID;                                   // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(MM_Sabuk_Dominion_Office_OnClickGuildMember) == 0x000008, "Wrong alignment on MM_Sabuk_Dominion_Office_OnClickGuildMember");
static_assert(sizeof(MM_Sabuk_Dominion_Office_OnClickGuildMember) == 0x000008, "Wrong size on MM_Sabuk_Dominion_Office_OnClickGuildMember");
static_assert(offsetof(MM_Sabuk_Dominion_Office_OnClickGuildMember, IGuildMemberUID) == 0x000000, "Member 'MM_Sabuk_Dominion_Office_OnClickGuildMember::IGuildMemberUID' has a wrong offset!");

// Function MirMobile.MM_Sabuk_Dominion_Office.OnSelectDelegate
// 0x0004 (0x0004 - 0x0000)
struct MM_Sabuk_Dominion_Office_OnSelectDelegate final
{
public:
	int32                                         IPBS_ID;                                           // 0x0000(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(MM_Sabuk_Dominion_Office_OnSelectDelegate) == 0x000004, "Wrong alignment on MM_Sabuk_Dominion_Office_OnSelectDelegate");
static_assert(sizeof(MM_Sabuk_Dominion_Office_OnSelectDelegate) == 0x000004, "Wrong size on MM_Sabuk_Dominion_Office_OnSelectDelegate");
static_assert(offsetof(MM_Sabuk_Dominion_Office_OnSelectDelegate, IPBS_ID) == 0x000000, "Member 'MM_Sabuk_Dominion_Office_OnSelectDelegate::IPBS_ID' has a wrong offset!");

// Function MirMobile.MM_Sabuk_Prize_Slot.Bind_ClickDelegate
// 0x0018 (0x0018 - 0x0000)
struct MM_Sabuk_Prize_Slot_Bind_ClickDelegate final
{
public:
	int32                                         IIndex;                                            // 0x0000(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_4[0x4];                                        // 0x0004(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class UObject*                                PObj;                                              // 0x0008(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   FunctionName;                                      // 0x0010(0x0008)(ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(MM_Sabuk_Prize_Slot_Bind_ClickDelegate) == 0x000008, "Wrong alignment on MM_Sabuk_Prize_Slot_Bind_ClickDelegate");
static_assert(sizeof(MM_Sabuk_Prize_Slot_Bind_ClickDelegate) == 0x000018, "Wrong size on MM_Sabuk_Prize_Slot_Bind_ClickDelegate");
static_assert(offsetof(MM_Sabuk_Prize_Slot_Bind_ClickDelegate, IIndex) == 0x000000, "Member 'MM_Sabuk_Prize_Slot_Bind_ClickDelegate::IIndex' has a wrong offset!");
static_assert(offsetof(MM_Sabuk_Prize_Slot_Bind_ClickDelegate, PObj) == 0x000008, "Member 'MM_Sabuk_Prize_Slot_Bind_ClickDelegate::PObj' has a wrong offset!");
static_assert(offsetof(MM_Sabuk_Prize_Slot_Bind_ClickDelegate, FunctionName) == 0x000010, "Member 'MM_Sabuk_Prize_Slot_Bind_ClickDelegate::FunctionName' has a wrong offset!");

// Function MirMobile.MM_Wanted_Slot.GetRemainTime
// 0x0008 (0x0008 - 0x0000)
struct MM_Wanted_Slot_GetRemainTime final
{
public:
	struct FTimespan                              ReturnValue;                                       // 0x0000(0x0008)(Parm, OutParm, ZeroConstructor, ReturnParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(MM_Wanted_Slot_GetRemainTime) == 0x000008, "Wrong alignment on MM_Wanted_Slot_GetRemainTime");
static_assert(sizeof(MM_Wanted_Slot_GetRemainTime) == 0x000008, "Wrong size on MM_Wanted_Slot_GetRemainTime");
static_assert(offsetof(MM_Wanted_Slot_GetRemainTime, ReturnValue) == 0x000000, "Member 'MM_Wanted_Slot_GetRemainTime::ReturnValue' has a wrong offset!");

// Function MirMobile.MM_UIAction_ClassSelect.OnClickClassSelect
// 0x0004 (0x0004 - 0x0000)
struct MM_UIAction_ClassSelect_OnClickClassSelect final
{
public:
	int32                                         ClassID;                                           // 0x0000(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(MM_UIAction_ClassSelect_OnClickClassSelect) == 0x000004, "Wrong alignment on MM_UIAction_ClassSelect_OnClickClassSelect");
static_assert(sizeof(MM_UIAction_ClassSelect_OnClickClassSelect) == 0x000004, "Wrong size on MM_UIAction_ClassSelect_OnClickClassSelect");
static_assert(offsetof(MM_UIAction_ClassSelect_OnClickClassSelect, ClassID) == 0x000000, "Member 'MM_UIAction_ClassSelect_OnClickClassSelect::ClassID' has a wrong offset!");

// Function MirMobile.MM_Slot_Quest.OnClickRewardSlot
// 0x0008 (0x0008 - 0x0000)
struct MM_Slot_Quest_OnClickRewardSlot final
{
public:
	class UMM_Slot_Base*                          PSlotBase;                                         // 0x0000(0x0008)(Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(MM_Slot_Quest_OnClickRewardSlot) == 0x000008, "Wrong alignment on MM_Slot_Quest_OnClickRewardSlot");
static_assert(sizeof(MM_Slot_Quest_OnClickRewardSlot) == 0x000008, "Wrong size on MM_Slot_Quest_OnClickRewardSlot");
static_assert(offsetof(MM_Slot_Quest_OnClickRewardSlot, PSlotBase) == 0x000000, "Member 'MM_Slot_Quest_OnClickRewardSlot::PSlotBase' has a wrong offset!");

// Function MirMobile.MM_Slot_Quest.SetFavoriteToggle
// 0x0001 (0x0001 - 0x0000)
struct MM_Slot_Quest_SetFavoriteToggle final
{
public:
	bool                                          State;                                             // 0x0000(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(MM_Slot_Quest_SetFavoriteToggle) == 0x000001, "Wrong alignment on MM_Slot_Quest_SetFavoriteToggle");
static_assert(sizeof(MM_Slot_Quest_SetFavoriteToggle) == 0x000001, "Wrong size on MM_Slot_Quest_SetFavoriteToggle");
static_assert(offsetof(MM_Slot_Quest_SetFavoriteToggle, State) == 0x000000, "Member 'MM_Slot_Quest_SetFavoriteToggle::State' has a wrong offset!");

// Function MirMobile.MM_Slot_Quest.SetRepeatToggle
// 0x0001 (0x0001 - 0x0000)
struct MM_Slot_Quest_SetRepeatToggle final
{
public:
	bool                                          State;                                             // 0x0000(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(MM_Slot_Quest_SetRepeatToggle) == 0x000001, "Wrong alignment on MM_Slot_Quest_SetRepeatToggle");
static_assert(sizeof(MM_Slot_Quest_SetRepeatToggle) == 0x000001, "Wrong size on MM_Slot_Quest_SetRepeatToggle");
static_assert(offsetof(MM_Slot_Quest_SetRepeatToggle, State) == 0x000000, "Member 'MM_Slot_Quest_SetRepeatToggle::State' has a wrong offset!");

// Function MirMobile.MM_Slot_Request.OnClickRewardSlot
// 0x0008 (0x0008 - 0x0000)
struct MM_Slot_Request_OnClickRewardSlot final
{
public:
	class UMM_Slot_Base*                          PSlotBase;                                         // 0x0000(0x0008)(Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(MM_Slot_Request_OnClickRewardSlot) == 0x000008, "Wrong alignment on MM_Slot_Request_OnClickRewardSlot");
static_assert(sizeof(MM_Slot_Request_OnClickRewardSlot) == 0x000008, "Wrong size on MM_Slot_Request_OnClickRewardSlot");
static_assert(offsetof(MM_Slot_Request_OnClickRewardSlot, PSlotBase) == 0x000000, "Member 'MM_Slot_Request_OnClickRewardSlot::PSlotBase' has a wrong offset!");

// Function MirMobile.MM_UIShopShoppingBag.OnClickCheckBoxAllSelected
// 0x0001 (0x0001 - 0x0000)
struct MM_UIShopShoppingBag_OnClickCheckBoxAllSelected final
{
public:
	bool                                          Checked;                                           // 0x0000(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(MM_UIShopShoppingBag_OnClickCheckBoxAllSelected) == 0x000001, "Wrong alignment on MM_UIShopShoppingBag_OnClickCheckBoxAllSelected");
static_assert(sizeof(MM_UIShopShoppingBag_OnClickCheckBoxAllSelected) == 0x000001, "Wrong size on MM_UIShopShoppingBag_OnClickCheckBoxAllSelected");
static_assert(offsetof(MM_UIShopShoppingBag_OnClickCheckBoxAllSelected, Checked) == 0x000000, "Member 'MM_UIShopShoppingBag_OnClickCheckBoxAllSelected::Checked' has a wrong offset!");

// Function MirMobile.MM_TotalMenu.OnClickCheckBoxGraphic
// 0x0001 (0x0001 - 0x0000)
struct MM_TotalMenu_OnClickCheckBoxGraphic final
{
public:
	bool                                          Checked;                                           // 0x0000(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(MM_TotalMenu_OnClickCheckBoxGraphic) == 0x000001, "Wrong alignment on MM_TotalMenu_OnClickCheckBoxGraphic");
static_assert(sizeof(MM_TotalMenu_OnClickCheckBoxGraphic) == 0x000001, "Wrong size on MM_TotalMenu_OnClickCheckBoxGraphic");
static_assert(offsetof(MM_TotalMenu_OnClickCheckBoxGraphic, Checked) == 0x000000, "Member 'MM_TotalMenu_OnClickCheckBoxGraphic::Checked' has a wrong offset!");

// Function MirMobile.MM_TotalMenu.OnClickCheckBoxGuildMark
// 0x0001 (0x0001 - 0x0000)
struct MM_TotalMenu_OnClickCheckBoxGuildMark final
{
public:
	bool                                          Checked;                                           // 0x0000(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(MM_TotalMenu_OnClickCheckBoxGuildMark) == 0x000001, "Wrong alignment on MM_TotalMenu_OnClickCheckBoxGuildMark");
static_assert(sizeof(MM_TotalMenu_OnClickCheckBoxGuildMark) == 0x000001, "Wrong size on MM_TotalMenu_OnClickCheckBoxGuildMark");
static_assert(offsetof(MM_TotalMenu_OnClickCheckBoxGuildMark, Checked) == 0x000000, "Member 'MM_TotalMenu_OnClickCheckBoxGuildMark::Checked' has a wrong offset!");

// Function MirMobile.MM_TotalMenu.OnClickCheckBoxName
// 0x0001 (0x0001 - 0x0000)
struct MM_TotalMenu_OnClickCheckBoxName final
{
public:
	bool                                          Checked;                                           // 0x0000(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(MM_TotalMenu_OnClickCheckBoxName) == 0x000001, "Wrong alignment on MM_TotalMenu_OnClickCheckBoxName");
static_assert(sizeof(MM_TotalMenu_OnClickCheckBoxName) == 0x000001, "Wrong size on MM_TotalMenu_OnClickCheckBoxName");
static_assert(offsetof(MM_TotalMenu_OnClickCheckBoxName, Checked) == 0x000000, "Member 'MM_TotalMenu_OnClickCheckBoxName::Checked' has a wrong offset!");

// Function MirMobile.MM_TutorialPage.OnClickPageIndicator
// 0x0008 (0x0008 - 0x0000)
struct MM_TutorialPage_OnClickPageIndicator final
{
public:
	int32                                         DotIndex;                                          // 0x0000(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          ReturnValue;                                       // 0x0004(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_5[0x3];                                        // 0x0005(0x0003)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(MM_TutorialPage_OnClickPageIndicator) == 0x000004, "Wrong alignment on MM_TutorialPage_OnClickPageIndicator");
static_assert(sizeof(MM_TutorialPage_OnClickPageIndicator) == 0x000008, "Wrong size on MM_TutorialPage_OnClickPageIndicator");
static_assert(offsetof(MM_TutorialPage_OnClickPageIndicator, DotIndex) == 0x000000, "Member 'MM_TutorialPage_OnClickPageIndicator::DotIndex' has a wrong offset!");
static_assert(offsetof(MM_TutorialPage_OnClickPageIndicator, ReturnValue) == 0x000004, "Member 'MM_TutorialPage_OnClickPageIndicator::ReturnValue' has a wrong offset!");

// Function MirMobile.MM_TutorialPetGuideWidget.SetDialogueSequenceEvent
// 0x0008 (0x0008 - 0x0000)
struct MM_TutorialPetGuideWidget_SetDialogueSequenceEvent final
{
public:
	int32                                         StringID;                                          // 0x0000(0x0004)(ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         PlaySoundID;                                       // 0x0004(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(MM_TutorialPetGuideWidget_SetDialogueSequenceEvent) == 0x000004, "Wrong alignment on MM_TutorialPetGuideWidget_SetDialogueSequenceEvent");
static_assert(sizeof(MM_TutorialPetGuideWidget_SetDialogueSequenceEvent) == 0x000008, "Wrong size on MM_TutorialPetGuideWidget_SetDialogueSequenceEvent");
static_assert(offsetof(MM_TutorialPetGuideWidget_SetDialogueSequenceEvent, StringID) == 0x000000, "Member 'MM_TutorialPetGuideWidget_SetDialogueSequenceEvent::StringID' has a wrong offset!");
static_assert(offsetof(MM_TutorialPetGuideWidget_SetDialogueSequenceEvent, PlaySoundID) == 0x000004, "Member 'MM_TutorialPetGuideWidget_SetDialogueSequenceEvent::PlaySoundID' has a wrong offset!");

// Function MirMobile.MM_TutorialPetGuideWidget.SetGuideTextEvent
// 0x0010 (0x0010 - 0x0000)
struct MM_TutorialPetGuideWidget_SetGuideTextEvent final
{
public:
	class FString                                 StrText;                                           // 0x0000(0x0010)(Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(MM_TutorialPetGuideWidget_SetGuideTextEvent) == 0x000008, "Wrong alignment on MM_TutorialPetGuideWidget_SetGuideTextEvent");
static_assert(sizeof(MM_TutorialPetGuideWidget_SetGuideTextEvent) == 0x000010, "Wrong size on MM_TutorialPetGuideWidget_SetGuideTextEvent");
static_assert(offsetof(MM_TutorialPetGuideWidget_SetGuideTextEvent, StrText) == 0x000000, "Member 'MM_TutorialPetGuideWidget_SetGuideTextEvent::StrText' has a wrong offset!");

// Function MirMobile.MM_TutorialPetGuideWidget.SetTargetWidget
// 0x0010 (0x0010 - 0x0000)
struct MM_TutorialPetGuideWidget_SetTargetWidget final
{
public:
	class UWidget*                                Targetwidget;                                      // 0x0000(0x0008)(Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EPetGuidePosType                              GuidePosType;                                      // 0x0008(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_9[0x7];                                        // 0x0009(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(MM_TutorialPetGuideWidget_SetTargetWidget) == 0x000008, "Wrong alignment on MM_TutorialPetGuideWidget_SetTargetWidget");
static_assert(sizeof(MM_TutorialPetGuideWidget_SetTargetWidget) == 0x000010, "Wrong size on MM_TutorialPetGuideWidget_SetTargetWidget");
static_assert(offsetof(MM_TutorialPetGuideWidget_SetTargetWidget, Targetwidget) == 0x000000, "Member 'MM_TutorialPetGuideWidget_SetTargetWidget::Targetwidget' has a wrong offset!");
static_assert(offsetof(MM_TutorialPetGuideWidget_SetTargetWidget, GuidePosType) == 0x000008, "Member 'MM_TutorialPetGuideWidget_SetTargetWidget::GuidePosType' has a wrong offset!");

// Function MirMobile.MM_UIAction_Labyrinth.StopAutoMission
// 0x0001 (0x0001 - 0x0000)
struct MM_UIAction_Labyrinth_StopAutoMission final
{
public:
	bool                                          IsEnter;                                           // 0x0000(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(MM_UIAction_Labyrinth_StopAutoMission) == 0x000001, "Wrong alignment on MM_UIAction_Labyrinth_StopAutoMission");
static_assert(sizeof(MM_UIAction_Labyrinth_StopAutoMission) == 0x000001, "Wrong size on MM_UIAction_Labyrinth_StopAutoMission");
static_assert(offsetof(MM_UIAction_Labyrinth_StopAutoMission, IsEnter) == 0x000000, "Member 'MM_UIAction_Labyrinth_StopAutoMission::IsEnter' has a wrong offset!");

// Function MirMobile.MM_UIAction_Costume.RequestEquipCostume
// 0x0004 (0x0004 - 0x0000)
struct MM_UIAction_Costume_RequestEquipCostume final
{
public:
	int32                                         CostumeID;                                         // 0x0000(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(MM_UIAction_Costume_RequestEquipCostume) == 0x000004, "Wrong alignment on MM_UIAction_Costume_RequestEquipCostume");
static_assert(sizeof(MM_UIAction_Costume_RequestEquipCostume) == 0x000004, "Wrong size on MM_UIAction_Costume_RequestEquipCostume");
static_assert(offsetof(MM_UIAction_Costume_RequestEquipCostume, CostumeID) == 0x000000, "Member 'MM_UIAction_Costume_RequestEquipCostume::CostumeID' has a wrong offset!");

// Function MirMobile.MM_UIAction_Customizing.UpdateData
// 0x0008 (0x0008 - 0x0000)
struct MM_UIAction_Customizing_UpdateData final
{
public:
	int32                                         CustomizingType;                                   // 0x0000(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         Value;                                             // 0x0004(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(MM_UIAction_Customizing_UpdateData) == 0x000004, "Wrong alignment on MM_UIAction_Customizing_UpdateData");
static_assert(sizeof(MM_UIAction_Customizing_UpdateData) == 0x000008, "Wrong size on MM_UIAction_Customizing_UpdateData");
static_assert(offsetof(MM_UIAction_Customizing_UpdateData, CustomizingType) == 0x000000, "Member 'MM_UIAction_Customizing_UpdateData::CustomizingType' has a wrong offset!");
static_assert(offsetof(MM_UIAction_Customizing_UpdateData, Value) == 0x000004, "Member 'MM_UIAction_Customizing_UpdateData::Value' has a wrong offset!");

// Function MirMobile.MM_UIAction_EliteDungeon.StopAutoMission
// 0x0001 (0x0001 - 0x0000)
struct MM_UIAction_EliteDungeon_StopAutoMission final
{
public:
	bool                                          IsEnter;                                           // 0x0000(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(MM_UIAction_EliteDungeon_StopAutoMission) == 0x000001, "Wrong alignment on MM_UIAction_EliteDungeon_StopAutoMission");
static_assert(sizeof(MM_UIAction_EliteDungeon_StopAutoMission) == 0x000001, "Wrong size on MM_UIAction_EliteDungeon_StopAutoMission");
static_assert(offsetof(MM_UIAction_EliteDungeon_StopAutoMission, IsEnter) == 0x000000, "Member 'MM_UIAction_EliteDungeon_StopAutoMission::IsEnter' has a wrong offset!");

// Function MirMobile.MM_UIAction_FT_Exchange.SetCurValue
// 0x0008 (0x0008 - 0x0000)
struct MM_UIAction_FT_Exchange_SetCurValue final
{
public:
	int64                                         Value;                                             // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(MM_UIAction_FT_Exchange_SetCurValue) == 0x000008, "Wrong alignment on MM_UIAction_FT_Exchange_SetCurValue");
static_assert(sizeof(MM_UIAction_FT_Exchange_SetCurValue) == 0x000008, "Wrong size on MM_UIAction_FT_Exchange_SetCurValue");
static_assert(offsetof(MM_UIAction_FT_Exchange_SetCurValue, Value) == 0x000000, "Member 'MM_UIAction_FT_Exchange_SetCurValue::Value' has a wrong offset!");

// Function MirMobile.MM_UIAction_HolyStuff.OnClosedLevelUpResult
// 0x0001 (0x0001 - 0x0000)
struct MM_UIAction_HolyStuff_OnClosedLevelUpResult final
{
public:
	bool                                          bIsSuccess;                                        // 0x0000(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(MM_UIAction_HolyStuff_OnClosedLevelUpResult) == 0x000001, "Wrong alignment on MM_UIAction_HolyStuff_OnClosedLevelUpResult");
static_assert(sizeof(MM_UIAction_HolyStuff_OnClosedLevelUpResult) == 0x000001, "Wrong size on MM_UIAction_HolyStuff_OnClosedLevelUpResult");
static_assert(offsetof(MM_UIAction_HolyStuff_OnClosedLevelUpResult, bIsSuccess) == 0x000000, "Member 'MM_UIAction_HolyStuff_OnClosedLevelUpResult::bIsSuccess' has a wrong offset!");

// Function MirMobile.MM_UIAction_Login.OnAuthenticationSignIn
// 0x0001 (0x0001 - 0x0000)
struct MM_UIAction_Login_OnAuthenticationSignIn final
{
public:
	bool                                          Success;                                           // 0x0000(0x0001)(ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(MM_UIAction_Login_OnAuthenticationSignIn) == 0x000001, "Wrong alignment on MM_UIAction_Login_OnAuthenticationSignIn");
static_assert(sizeof(MM_UIAction_Login_OnAuthenticationSignIn) == 0x000001, "Wrong size on MM_UIAction_Login_OnAuthenticationSignIn");
static_assert(offsetof(MM_UIAction_Login_OnAuthenticationSignIn, Success) == 0x000000, "Member 'MM_UIAction_Login_OnAuthenticationSignIn::Success' has a wrong offset!");

// Function MirMobile.MM_UIAction_Login.OnAuthenticationSignOut
// 0x0001 (0x0001 - 0x0000)
struct MM_UIAction_Login_OnAuthenticationSignOut final
{
public:
	bool                                          Success;                                           // 0x0000(0x0001)(ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(MM_UIAction_Login_OnAuthenticationSignOut) == 0x000001, "Wrong alignment on MM_UIAction_Login_OnAuthenticationSignOut");
static_assert(sizeof(MM_UIAction_Login_OnAuthenticationSignOut) == 0x000001, "Wrong size on MM_UIAction_Login_OnAuthenticationSignOut");
static_assert(offsetof(MM_UIAction_Login_OnAuthenticationSignOut, Success) == 0x000000, "Member 'MM_UIAction_Login_OnAuthenticationSignOut::Success' has a wrong offset!");

// Function MirMobile.MM_UIAction_Login.OnCertCheck
// 0x0018 (0x0018 - 0x0000)
struct MM_UIAction_Login_OnCertCheck final
{
public:
	bool                                          Success;                                           // 0x0000(0x0001)(ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1[0x7];                                        // 0x0001(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	class FString                                 Message;                                           // 0x0008(0x0010)(Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(MM_UIAction_Login_OnCertCheck) == 0x000008, "Wrong alignment on MM_UIAction_Login_OnCertCheck");
static_assert(sizeof(MM_UIAction_Login_OnCertCheck) == 0x000018, "Wrong size on MM_UIAction_Login_OnCertCheck");
static_assert(offsetof(MM_UIAction_Login_OnCertCheck, Success) == 0x000000, "Member 'MM_UIAction_Login_OnCertCheck::Success' has a wrong offset!");
static_assert(offsetof(MM_UIAction_Login_OnCertCheck, Message) == 0x000008, "Member 'MM_UIAction_Login_OnCertCheck::Message' has a wrong offset!");

// Function MirMobile.MM_UIAction_Login.OnClickAccess
// 0x0001 (0x0001 - 0x0000)
struct MM_UIAction_Login_OnClickAccess final
{
public:
	bool                                          ReturnValue;                                       // 0x0000(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(MM_UIAction_Login_OnClickAccess) == 0x000001, "Wrong alignment on MM_UIAction_Login_OnClickAccess");
static_assert(sizeof(MM_UIAction_Login_OnClickAccess) == 0x000001, "Wrong size on MM_UIAction_Login_OnClickAccess");
static_assert(offsetof(MM_UIAction_Login_OnClickAccess, ReturnValue) == 0x000000, "Member 'MM_UIAction_Login_OnClickAccess::ReturnValue' has a wrong offset!");

// Function MirMobile.MM_UIAction_Login.OnGuestRestore
// 0x0018 (0x0018 - 0x0000)
struct MM_UIAction_Login_OnGuestRestore final
{
public:
	bool                                          Success;                                           // 0x0000(0x0001)(ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1[0x7];                                        // 0x0001(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	class FString                                 Message;                                           // 0x0008(0x0010)(Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(MM_UIAction_Login_OnGuestRestore) == 0x000008, "Wrong alignment on MM_UIAction_Login_OnGuestRestore");
static_assert(sizeof(MM_UIAction_Login_OnGuestRestore) == 0x000018, "Wrong size on MM_UIAction_Login_OnGuestRestore");
static_assert(offsetof(MM_UIAction_Login_OnGuestRestore, Success) == 0x000000, "Member 'MM_UIAction_Login_OnGuestRestore::Success' has a wrong offset!");
static_assert(offsetof(MM_UIAction_Login_OnGuestRestore, Message) == 0x000008, "Member 'MM_UIAction_Login_OnGuestRestore::Message' has a wrong offset!");

// Function MirMobile.MM_UIAction_Login.OnWin64GoogleSignin
// 0x0010 (0x0010 - 0x0000)
struct MM_UIAction_Login_OnWin64GoogleSignin final
{
public:
	class FString                                 IdToken;                                           // 0x0000(0x0010)(Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(MM_UIAction_Login_OnWin64GoogleSignin) == 0x000008, "Wrong alignment on MM_UIAction_Login_OnWin64GoogleSignin");
static_assert(sizeof(MM_UIAction_Login_OnWin64GoogleSignin) == 0x000010, "Wrong size on MM_UIAction_Login_OnWin64GoogleSignin");
static_assert(offsetof(MM_UIAction_Login_OnWin64GoogleSignin, IdToken) == 0x000000, "Member 'MM_UIAction_Login_OnWin64GoogleSignin::IdToken' has a wrong offset!");

// Function MirMobile.MM_UIAction_Login.Show_LoginWidget
// 0x0001 (0x0001 - 0x0000)
struct MM_UIAction_Login_Show_LoginWidget final
{
public:
	bool                                          bShow;                                             // 0x0000(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(MM_UIAction_Login_Show_LoginWidget) == 0x000001, "Wrong alignment on MM_UIAction_Login_Show_LoginWidget");
static_assert(sizeof(MM_UIAction_Login_Show_LoginWidget) == 0x000001, "Wrong size on MM_UIAction_Login_Show_LoginWidget");
static_assert(offsetof(MM_UIAction_Login_Show_LoginWidget, bShow) == 0x000000, "Member 'MM_UIAction_Login_Show_LoginWidget::bShow' has a wrong offset!");

// Function MirMobile.MM_UIAction_NPCShop.OnBattleStateChanged
// 0x0001 (0x0001 - 0x0000)
struct MM_UIAction_NPCShop_OnBattleStateChanged final
{
public:
	bool                                          NewBattleState;                                    // 0x0000(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(MM_UIAction_NPCShop_OnBattleStateChanged) == 0x000001, "Wrong alignment on MM_UIAction_NPCShop_OnBattleStateChanged");
static_assert(sizeof(MM_UIAction_NPCShop_OnBattleStateChanged) == 0x000001, "Wrong size on MM_UIAction_NPCShop_OnBattleStateChanged");
static_assert(offsetof(MM_UIAction_NPCShop_OnBattleStateChanged, NewBattleState) == 0x000000, "Member 'MM_UIAction_NPCShop_OnBattleStateChanged::NewBattleState' has a wrong offset!");

// Function MirMobile.MM_UIAction_NPCShop.OnBuy
// 0x0004 (0x0004 - 0x0000)
struct MM_UIAction_NPCShop_OnBuy final
{
public:
	int32                                         Count_;                                            // 0x0000(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(MM_UIAction_NPCShop_OnBuy) == 0x000004, "Wrong alignment on MM_UIAction_NPCShop_OnBuy");
static_assert(sizeof(MM_UIAction_NPCShop_OnBuy) == 0x000004, "Wrong size on MM_UIAction_NPCShop_OnBuy");
static_assert(offsetof(MM_UIAction_NPCShop_OnBuy, Count_) == 0x000000, "Member 'MM_UIAction_NPCShop_OnBuy::Count_' has a wrong offset!");

// Function MirMobile.MM_UIAction_NPCShop.OnClickedBuy
// 0x0004 (0x0004 - 0x0000)
struct MM_UIAction_NPCShop_OnClickedBuy final
{
public:
	int32                                         Elemental_ID;                                      // 0x0000(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(MM_UIAction_NPCShop_OnClickedBuy) == 0x000004, "Wrong alignment on MM_UIAction_NPCShop_OnClickedBuy");
static_assert(sizeof(MM_UIAction_NPCShop_OnClickedBuy) == 0x000004, "Wrong size on MM_UIAction_NPCShop_OnClickedBuy");
static_assert(offsetof(MM_UIAction_NPCShop_OnClickedBuy, Elemental_ID) == 0x000000, "Member 'MM_UIAction_NPCShop_OnClickedBuy::Elemental_ID' has a wrong offset!");

// Function MirMobile.MM_UIAction_NPCShop.OnTryBuy
// 0x0004 (0x0004 - 0x0000)
struct MM_UIAction_NPCShop_OnTryBuy final
{
public:
	int32                                         Elemental_ID;                                      // 0x0000(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(MM_UIAction_NPCShop_OnTryBuy) == 0x000004, "Wrong alignment on MM_UIAction_NPCShop_OnTryBuy");
static_assert(sizeof(MM_UIAction_NPCShop_OnTryBuy) == 0x000004, "Wrong size on MM_UIAction_NPCShop_OnTryBuy");
static_assert(offsetof(MM_UIAction_NPCShop_OnTryBuy, Elemental_ID) == 0x000000, "Member 'MM_UIAction_NPCShop_OnTryBuy::Elemental_ID' has a wrong offset!");

// Function MirMobile.MM_UIAction_OccupationSabuk.UnBindEmperorAppointment
// 0x0008 (0x0008 - 0x0000)
struct MM_UIAction_OccupationSabuk_UnBindEmperorAppointment final
{
public:
	class UWidgetBase*                            Targetwidget;                                      // 0x0000(0x0008)(Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(MM_UIAction_OccupationSabuk_UnBindEmperorAppointment) == 0x000008, "Wrong alignment on MM_UIAction_OccupationSabuk_UnBindEmperorAppointment");
static_assert(sizeof(MM_UIAction_OccupationSabuk_UnBindEmperorAppointment) == 0x000008, "Wrong size on MM_UIAction_OccupationSabuk_UnBindEmperorAppointment");
static_assert(offsetof(MM_UIAction_OccupationSabuk_UnBindEmperorAppointment, Targetwidget) == 0x000000, "Member 'MM_UIAction_OccupationSabuk_UnBindEmperorAppointment::Targetwidget' has a wrong offset!");

// Function MirMobile.MM_UIAction_Party.DoLeave
// 0x0001 (0x0001 - 0x0000)
struct MM_UIAction_Party_DoLeave final
{
public:
	bool                                          bOccupation;                                       // 0x0000(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(MM_UIAction_Party_DoLeave) == 0x000001, "Wrong alignment on MM_UIAction_Party_DoLeave");
static_assert(sizeof(MM_UIAction_Party_DoLeave) == 0x000001, "Wrong size on MM_UIAction_Party_DoLeave");
static_assert(offsetof(MM_UIAction_Party_DoLeave, bOccupation) == 0x000000, "Member 'MM_UIAction_Party_DoLeave::bOccupation' has a wrong offset!");

// Function MirMobile.MM_UIAction_Pet.OnPopupExchangeItemConfirm
// 0x0008 (0x0008 - 0x0000)
struct MM_UIAction_Pet_OnPopupExchangeItemConfirm final
{
public:
	bool                                          bAbleExchange;                                     // 0x0000(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1[0x3];                                        // 0x0001(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         IExchangeCount;                                    // 0x0004(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(MM_UIAction_Pet_OnPopupExchangeItemConfirm) == 0x000004, "Wrong alignment on MM_UIAction_Pet_OnPopupExchangeItemConfirm");
static_assert(sizeof(MM_UIAction_Pet_OnPopupExchangeItemConfirm) == 0x000008, "Wrong size on MM_UIAction_Pet_OnPopupExchangeItemConfirm");
static_assert(offsetof(MM_UIAction_Pet_OnPopupExchangeItemConfirm, bAbleExchange) == 0x000000, "Member 'MM_UIAction_Pet_OnPopupExchangeItemConfirm::bAbleExchange' has a wrong offset!");
static_assert(offsetof(MM_UIAction_Pet_OnPopupExchangeItemConfirm, IExchangeCount) == 0x000004, "Member 'MM_UIAction_Pet_OnPopupExchangeItemConfirm::IExchangeCount' has a wrong offset!");

// Function MirMobile.MM_UIAction_QuestNormal.OnClickStage
// 0x0004 (0x0004 - 0x0000)
struct MM_UIAction_QuestNormal_OnClickStage final
{
public:
	int32                                         GroupId;                                           // 0x0000(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(MM_UIAction_QuestNormal_OnClickStage) == 0x000004, "Wrong alignment on MM_UIAction_QuestNormal_OnClickStage");
static_assert(sizeof(MM_UIAction_QuestNormal_OnClickStage) == 0x000004, "Wrong size on MM_UIAction_QuestNormal_OnClickStage");
static_assert(offsetof(MM_UIAction_QuestNormal_OnClickStage, GroupId) == 0x000000, "Member 'MM_UIAction_QuestNormal_OnClickStage::GroupId' has a wrong offset!");

// Function MirMobile.MM_UIAction_QuestNormal.OnClickStageType
// 0x0004 (0x0004 - 0x0000)
struct MM_UIAction_QuestNormal_OnClickStageType final
{
public:
	int32                                         StageType;                                         // 0x0000(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(MM_UIAction_QuestNormal_OnClickStageType) == 0x000004, "Wrong alignment on MM_UIAction_QuestNormal_OnClickStageType");
static_assert(sizeof(MM_UIAction_QuestNormal_OnClickStageType) == 0x000004, "Wrong size on MM_UIAction_QuestNormal_OnClickStageType");
static_assert(offsetof(MM_UIAction_QuestNormal_OnClickStageType, StageType) == 0x000000, "Member 'MM_UIAction_QuestNormal_OnClickStageType::StageType' has a wrong offset!");

// Function MirMobile.MM_UIAction_UIShop.OnCompleteIAP
// 0x00B0 (0x00B0 - 0x0000)
struct MM_UIAction_UIShop_OnCompleteIAP final
{
public:
	bool                                          Success;                                           // 0x0000(0x0001)(ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1[0x3];                                        // 0x0001(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         ErrorCode;                                         // 0x0004(0x0004)(ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FIAPProductData                        ProductData;                                       // 0x0008(0x00A8)(ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
};
static_assert(alignof(MM_UIAction_UIShop_OnCompleteIAP) == 0x000008, "Wrong alignment on MM_UIAction_UIShop_OnCompleteIAP");
static_assert(sizeof(MM_UIAction_UIShop_OnCompleteIAP) == 0x0000B0, "Wrong size on MM_UIAction_UIShop_OnCompleteIAP");
static_assert(offsetof(MM_UIAction_UIShop_OnCompleteIAP, Success) == 0x000000, "Member 'MM_UIAction_UIShop_OnCompleteIAP::Success' has a wrong offset!");
static_assert(offsetof(MM_UIAction_UIShop_OnCompleteIAP, ErrorCode) == 0x000004, "Member 'MM_UIAction_UIShop_OnCompleteIAP::ErrorCode' has a wrong offset!");
static_assert(offsetof(MM_UIAction_UIShop_OnCompleteIAP, ProductData) == 0x000008, "Member 'MM_UIAction_UIShop_OnCompleteIAP::ProductData' has a wrong offset!");

// Function MirMobile.MM_UIAction_UnderWorld.StopAutoMission
// 0x0001 (0x0001 - 0x0000)
struct MM_UIAction_UnderWorld_StopAutoMission final
{
public:
	bool                                          IsEnter;                                           // 0x0000(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(MM_UIAction_UnderWorld_StopAutoMission) == 0x000001, "Wrong alignment on MM_UIAction_UnderWorld_StopAutoMission");
static_assert(sizeof(MM_UIAction_UnderWorld_StopAutoMission) == 0x000001, "Wrong size on MM_UIAction_UnderWorld_StopAutoMission");
static_assert(offsetof(MM_UIAction_UnderWorld_StopAutoMission, IsEnter) == 0x000000, "Member 'MM_UIAction_UnderWorld_StopAutoMission::IsEnter' has a wrong offset!");

// Function MirMobile.MM_UIAction_UserEvent_BattlePass.OnImmediateOK
// 0x0004 (0x0004 - 0x0000)
struct MM_UIAction_UserEvent_BattlePass_OnImmediateOK final
{
public:
	int32                                         IMissionId;                                        // 0x0000(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(MM_UIAction_UserEvent_BattlePass_OnImmediateOK) == 0x000004, "Wrong alignment on MM_UIAction_UserEvent_BattlePass_OnImmediateOK");
static_assert(sizeof(MM_UIAction_UserEvent_BattlePass_OnImmediateOK) == 0x000004, "Wrong size on MM_UIAction_UserEvent_BattlePass_OnImmediateOK");
static_assert(offsetof(MM_UIAction_UserEvent_BattlePass_OnImmediateOK, IMissionId) == 0x000000, "Member 'MM_UIAction_UserEvent_BattlePass_OnImmediateOK::IMissionId' has a wrong offset!");

// Function MirMobile.MM_UIPreviewMode.CreateMyWidget
// 0x0018 (0x0018 - 0x0000)
struct MM_UIPreviewMode_CreateMyWidget final
{
public:
	class FString                                 StrFullPath;                                       // 0x0000(0x0010)(Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UUserWidget*                            ReturnValue;                                       // 0x0010(0x0008)(ExportObject, Parm, OutParm, ZeroConstructor, ReturnParm, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(MM_UIPreviewMode_CreateMyWidget) == 0x000008, "Wrong alignment on MM_UIPreviewMode_CreateMyWidget");
static_assert(sizeof(MM_UIPreviewMode_CreateMyWidget) == 0x000018, "Wrong size on MM_UIPreviewMode_CreateMyWidget");
static_assert(offsetof(MM_UIPreviewMode_CreateMyWidget, StrFullPath) == 0x000000, "Member 'MM_UIPreviewMode_CreateMyWidget::StrFullPath' has a wrong offset!");
static_assert(offsetof(MM_UIPreviewMode_CreateMyWidget, ReturnValue) == 0x000010, "Member 'MM_UIPreviewMode_CreateMyWidget::ReturnValue' has a wrong offset!");

// Function MirMobile.MM_UIPreviewMode.GetPathString
// 0x0030 (0x0030 - 0x0000)
struct MM_UIPreviewMode_GetPathString final
{
public:
	TArray<class FString>                         ArFile;                                            // 0x0000(0x0010)(Parm, OutParm, ZeroConstructor, NativeAccessSpecifierPublic)
	TArray<class FString>                         ArFolder;                                          // 0x0010(0x0010)(Parm, OutParm, ZeroConstructor, NativeAccessSpecifierPublic)
	class FString                                 StrFindPath;                                       // 0x0020(0x0010)(Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(MM_UIPreviewMode_GetPathString) == 0x000008, "Wrong alignment on MM_UIPreviewMode_GetPathString");
static_assert(sizeof(MM_UIPreviewMode_GetPathString) == 0x000030, "Wrong size on MM_UIPreviewMode_GetPathString");
static_assert(offsetof(MM_UIPreviewMode_GetPathString, ArFile) == 0x000000, "Member 'MM_UIPreviewMode_GetPathString::ArFile' has a wrong offset!");
static_assert(offsetof(MM_UIPreviewMode_GetPathString, ArFolder) == 0x000010, "Member 'MM_UIPreviewMode_GetPathString::ArFolder' has a wrong offset!");
static_assert(offsetof(MM_UIPreviewMode_GetPathString, StrFindPath) == 0x000020, "Member 'MM_UIPreviewMode_GetPathString::StrFindPath' has a wrong offset!");

// Function MirMobile.MM_UIShopBanner.OnClickCheckBox
// 0x0001 (0x0001 - 0x0000)
struct MM_UIShopBanner_OnClickCheckBox final
{
public:
	bool                                          Checked;                                           // 0x0000(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(MM_UIShopBanner_OnClickCheckBox) == 0x000001, "Wrong alignment on MM_UIShopBanner_OnClickCheckBox");
static_assert(sizeof(MM_UIShopBanner_OnClickCheckBox) == 0x000001, "Wrong size on MM_UIShopBanner_OnClickCheckBox");
static_assert(offsetof(MM_UIShopBanner_OnClickCheckBox, Checked) == 0x000000, "Member 'MM_UIShopBanner_OnClickCheckBox::Checked' has a wrong offset!");

// Function MirMobile.MM_UIShopBanner.OnFailDownloadImage
// 0x0008 (0x0008 - 0x0000)
struct MM_UIShopBanner_OnFailDownloadImage final
{
public:
	class UTexture2DDynamic*                      Texture;                                           // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(MM_UIShopBanner_OnFailDownloadImage) == 0x000008, "Wrong alignment on MM_UIShopBanner_OnFailDownloadImage");
static_assert(sizeof(MM_UIShopBanner_OnFailDownloadImage) == 0x000008, "Wrong size on MM_UIShopBanner_OnFailDownloadImage");
static_assert(offsetof(MM_UIShopBanner_OnFailDownloadImage, Texture) == 0x000000, "Member 'MM_UIShopBanner_OnFailDownloadImage::Texture' has a wrong offset!");

// Function MirMobile.MM_UIShopBanner.OnSuccessDownloadImage
// 0x0008 (0x0008 - 0x0000)
struct MM_UIShopBanner_OnSuccessDownloadImage final
{
public:
	class UTexture2DDynamic*                      Texture;                                           // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(MM_UIShopBanner_OnSuccessDownloadImage) == 0x000008, "Wrong alignment on MM_UIShopBanner_OnSuccessDownloadImage");
static_assert(sizeof(MM_UIShopBanner_OnSuccessDownloadImage) == 0x000008, "Wrong size on MM_UIShopBanner_OnSuccessDownloadImage");
static_assert(offsetof(MM_UIShopBanner_OnSuccessDownloadImage, Texture) == 0x000000, "Member 'MM_UIShopBanner_OnSuccessDownloadImage::Texture' has a wrong offset!");

// Function MirMobile.MM_UIShopCashBagSlot.OnClickCheckBox
// 0x0001 (0x0001 - 0x0000)
struct MM_UIShopCashBagSlot_OnClickCheckBox final
{
public:
	bool                                          IsCheck;                                           // 0x0000(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(MM_UIShopCashBagSlot_OnClickCheckBox) == 0x000001, "Wrong alignment on MM_UIShopCashBagSlot_OnClickCheckBox");
static_assert(sizeof(MM_UIShopCashBagSlot_OnClickCheckBox) == 0x000001, "Wrong size on MM_UIShopCashBagSlot_OnClickCheckBox");
static_assert(offsetof(MM_UIShopCashBagSlot_OnClickCheckBox, IsCheck) == 0x000000, "Member 'MM_UIShopCashBagSlot_OnClickCheckBox::IsCheck' has a wrong offset!");

// Function MirMobile.MM_UIShopGacha.OnClickCheckBoxGachaStop
// 0x0001 (0x0001 - 0x0000)
struct MM_UIShopGacha_OnClickCheckBoxGachaStop final
{
public:
	bool                                          Checked;                                           // 0x0000(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(MM_UIShopGacha_OnClickCheckBoxGachaStop) == 0x000001, "Wrong alignment on MM_UIShopGacha_OnClickCheckBoxGachaStop");
static_assert(sizeof(MM_UIShopGacha_OnClickCheckBoxGachaStop) == 0x000001, "Wrong size on MM_UIShopGacha_OnClickCheckBoxGachaStop");
static_assert(offsetof(MM_UIShopGacha_OnClickCheckBoxGachaStop, Checked) == 0x000000, "Member 'MM_UIShopGacha_OnClickCheckBoxGachaStop::Checked' has a wrong offset!");

// Function MirMobile.MM_UIShopGacha.OnClickCheckBoxSkip
// 0x0001 (0x0001 - 0x0000)
struct MM_UIShopGacha_OnClickCheckBoxSkip final
{
public:
	bool                                          Checked;                                           // 0x0000(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(MM_UIShopGacha_OnClickCheckBoxSkip) == 0x000001, "Wrong alignment on MM_UIShopGacha_OnClickCheckBoxSkip");
static_assert(sizeof(MM_UIShopGacha_OnClickCheckBoxSkip) == 0x000001, "Wrong size on MM_UIShopGacha_OnClickCheckBoxSkip");
static_assert(offsetof(MM_UIShopGacha_OnClickCheckBoxSkip, Checked) == 0x000000, "Member 'MM_UIShopGacha_OnClickCheckBoxSkip::Checked' has a wrong offset!");

// Function MirMobile.MM_UIShopGachaResult.OnClickCheckBoxGachaStop
// 0x0001 (0x0001 - 0x0000)
struct MM_UIShopGachaResult_OnClickCheckBoxGachaStop final
{
public:
	bool                                          Checked;                                           // 0x0000(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(MM_UIShopGachaResult_OnClickCheckBoxGachaStop) == 0x000001, "Wrong alignment on MM_UIShopGachaResult_OnClickCheckBoxGachaStop");
static_assert(sizeof(MM_UIShopGachaResult_OnClickCheckBoxGachaStop) == 0x000001, "Wrong size on MM_UIShopGachaResult_OnClickCheckBoxGachaStop");
static_assert(offsetof(MM_UIShopGachaResult_OnClickCheckBoxGachaStop, Checked) == 0x000000, "Member 'MM_UIShopGachaResult_OnClickCheckBoxGachaStop::Checked' has a wrong offset!");

// Function MirMobile.MM_UIShopGachaResult.OnClickCheckBoxSkip
// 0x0001 (0x0001 - 0x0000)
struct MM_UIShopGachaResult_OnClickCheckBoxSkip final
{
public:
	bool                                          Checked;                                           // 0x0000(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(MM_UIShopGachaResult_OnClickCheckBoxSkip) == 0x000001, "Wrong alignment on MM_UIShopGachaResult_OnClickCheckBoxSkip");
static_assert(sizeof(MM_UIShopGachaResult_OnClickCheckBoxSkip) == 0x000001, "Wrong size on MM_UIShopGachaResult_OnClickCheckBoxSkip");
static_assert(offsetof(MM_UIShopGachaResult_OnClickCheckBoxSkip, Checked) == 0x000000, "Member 'MM_UIShopGachaResult_OnClickCheckBoxSkip::Checked' has a wrong offset!");

// Function MirMobile.MM_UIShopGachaResult.PlayEndAnimation
// 0x0004 (0x0004 - 0x0000)
struct MM_UIShopGachaResult_PlayEndAnimation final
{
public:
	float                                         ReturnValue;                                       // 0x0000(0x0004)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(MM_UIShopGachaResult_PlayEndAnimation) == 0x000004, "Wrong alignment on MM_UIShopGachaResult_PlayEndAnimation");
static_assert(sizeof(MM_UIShopGachaResult_PlayEndAnimation) == 0x000004, "Wrong size on MM_UIShopGachaResult_PlayEndAnimation");
static_assert(offsetof(MM_UIShopGachaResult_PlayEndAnimation, ReturnValue) == 0x000000, "Member 'MM_UIShopGachaResult_PlayEndAnimation::ReturnValue' has a wrong offset!");

// Function MirMobile.MM_UserEvent_Attendance_Day_Slot.OnClickSlot
// 0x0008 (0x0008 - 0x0000)
struct MM_UserEvent_Attendance_Day_Slot_OnClickSlot final
{
public:
	class UMM_Slot_Base*                          PSlot;                                             // 0x0000(0x0008)(Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(MM_UserEvent_Attendance_Day_Slot_OnClickSlot) == 0x000008, "Wrong alignment on MM_UserEvent_Attendance_Day_Slot_OnClickSlot");
static_assert(sizeof(MM_UserEvent_Attendance_Day_Slot_OnClickSlot) == 0x000008, "Wrong size on MM_UserEvent_Attendance_Day_Slot_OnClickSlot");
static_assert(offsetof(MM_UserEvent_Attendance_Day_Slot_OnClickSlot, PSlot) == 0x000000, "Member 'MM_UserEvent_Attendance_Day_Slot_OnClickSlot::PSlot' has a wrong offset!");

// Function MirMobile.MM_UserEvent_ExchangeShop.OnClickedBuy
// 0x0004 (0x0004 - 0x0000)
struct MM_UserEvent_ExchangeShop_OnClickedBuy final
{
public:
	int32                                         InGoodsID;                                         // 0x0000(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(MM_UserEvent_ExchangeShop_OnClickedBuy) == 0x000004, "Wrong alignment on MM_UserEvent_ExchangeShop_OnClickedBuy");
static_assert(sizeof(MM_UserEvent_ExchangeShop_OnClickedBuy) == 0x000004, "Wrong size on MM_UserEvent_ExchangeShop_OnClickedBuy");
static_assert(offsetof(MM_UserEvent_ExchangeShop_OnClickedBuy, InGoodsID) == 0x000000, "Member 'MM_UserEvent_ExchangeShop_OnClickedBuy::InGoodsID' has a wrong offset!");

// Function MirMobile.MM_UserEvent_Goal_Slot.OnClickSlot
// 0x0008 (0x0008 - 0x0000)
struct MM_UserEvent_Goal_Slot_OnClickSlot final
{
public:
	class UMM_Slot_Base*                          PSlot;                                             // 0x0000(0x0008)(Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(MM_UserEvent_Goal_Slot_OnClickSlot) == 0x000008, "Wrong alignment on MM_UserEvent_Goal_Slot_OnClickSlot");
static_assert(sizeof(MM_UserEvent_Goal_Slot_OnClickSlot) == 0x000008, "Wrong size on MM_UserEvent_Goal_Slot_OnClickSlot");
static_assert(offsetof(MM_UserEvent_Goal_Slot_OnClickSlot, PSlot) == 0x000000, "Member 'MM_UserEvent_Goal_Slot_OnClickSlot::PSlot' has a wrong offset!");

// Function MirMobile.MM_UserEvent_Gold.OnClickSlot
// 0x0008 (0x0008 - 0x0000)
struct MM_UserEvent_Gold_OnClickSlot final
{
public:
	class UMM_Slot_Base*                          PSlot;                                             // 0x0000(0x0008)(Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(MM_UserEvent_Gold_OnClickSlot) == 0x000008, "Wrong alignment on MM_UserEvent_Gold_OnClickSlot");
static_assert(sizeof(MM_UserEvent_Gold_OnClickSlot) == 0x000008, "Wrong size on MM_UserEvent_Gold_OnClickSlot");
static_assert(offsetof(MM_UserEvent_Gold_OnClickSlot, PSlot) == 0x000000, "Member 'MM_UserEvent_Gold_OnClickSlot::PSlot' has a wrong offset!");

// Function MirMobile.MM_UserEvent_Gold_Slot.OnClickSlot
// 0x0008 (0x0008 - 0x0000)
struct MM_UserEvent_Gold_Slot_OnClickSlot final
{
public:
	class UMM_Slot_Base*                          PSlot;                                             // 0x0000(0x0008)(Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(MM_UserEvent_Gold_Slot_OnClickSlot) == 0x000008, "Wrong alignment on MM_UserEvent_Gold_Slot_OnClickSlot");
static_assert(sizeof(MM_UserEvent_Gold_Slot_OnClickSlot) == 0x000008, "Wrong size on MM_UserEvent_Gold_Slot_OnClickSlot");
static_assert(offsetof(MM_UserEvent_Gold_Slot_OnClickSlot, PSlot) == 0x000000, "Member 'MM_UserEvent_Gold_Slot_OnClickSlot::PSlot' has a wrong offset!");

// Function MirMobile.MM_UserEvent_Item_Slot.OnAbsentStepBuy
// 0x0008 (0x0008 - 0x0000)
struct MM_UserEvent_Item_Slot_OnAbsentStepBuy final
{
public:
	bool                                          IsLackCost;                                        // 0x0000(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1[0x3];                                        // 0x0001(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         CostType;                                          // 0x0004(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(MM_UserEvent_Item_Slot_OnAbsentStepBuy) == 0x000004, "Wrong alignment on MM_UserEvent_Item_Slot_OnAbsentStepBuy");
static_assert(sizeof(MM_UserEvent_Item_Slot_OnAbsentStepBuy) == 0x000008, "Wrong size on MM_UserEvent_Item_Slot_OnAbsentStepBuy");
static_assert(offsetof(MM_UserEvent_Item_Slot_OnAbsentStepBuy, IsLackCost) == 0x000000, "Member 'MM_UserEvent_Item_Slot_OnAbsentStepBuy::IsLackCost' has a wrong offset!");
static_assert(offsetof(MM_UserEvent_Item_Slot_OnAbsentStepBuy, CostType) == 0x000004, "Member 'MM_UserEvent_Item_Slot_OnAbsentStepBuy::CostType' has a wrong offset!");

// Function MirMobile.MM_UserEvent_Item_Slot.OnClickSlot
// 0x0008 (0x0008 - 0x0000)
struct MM_UserEvent_Item_Slot_OnClickSlot final
{
public:
	class UMM_Slot_Base*                          PSlot;                                             // 0x0000(0x0008)(Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(MM_UserEvent_Item_Slot_OnClickSlot) == 0x000008, "Wrong alignment on MM_UserEvent_Item_Slot_OnClickSlot");
static_assert(sizeof(MM_UserEvent_Item_Slot_OnClickSlot) == 0x000008, "Wrong size on MM_UserEvent_Item_Slot_OnClickSlot");
static_assert(offsetof(MM_UserEvent_Item_Slot_OnClickSlot, PSlot) == 0x000000, "Member 'MM_UserEvent_Item_Slot_OnClickSlot::PSlot' has a wrong offset!");

// Function MirMobile.MM_UserEvent_Painting.OnClickSlot
// 0x0008 (0x0008 - 0x0000)
struct MM_UserEvent_Painting_OnClickSlot final
{
public:
	class UMM_Slot_Base*                          PSlot;                                             // 0x0000(0x0008)(Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(MM_UserEvent_Painting_OnClickSlot) == 0x000008, "Wrong alignment on MM_UserEvent_Painting_OnClickSlot");
static_assert(sizeof(MM_UserEvent_Painting_OnClickSlot) == 0x000008, "Wrong size on MM_UserEvent_Painting_OnClickSlot");
static_assert(offsetof(MM_UserEvent_Painting_OnClickSlot, PSlot) == 0x000000, "Member 'MM_UserEvent_Painting_OnClickSlot::PSlot' has a wrong offset!");

// Function MirMobile.MM_VolumeController.OnDragVolumeController
// 0x0004 (0x0004 - 0x0000)
struct MM_VolumeController_OnDragVolumeController final
{
public:
	float                                         FRatio;                                            // 0x0000(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(MM_VolumeController_OnDragVolumeController) == 0x000004, "Wrong alignment on MM_VolumeController_OnDragVolumeController");
static_assert(sizeof(MM_VolumeController_OnDragVolumeController) == 0x000004, "Wrong size on MM_VolumeController_OnDragVolumeController");
static_assert(offsetof(MM_VolumeController_OnDragVolumeController, FRatio) == 0x000000, "Member 'MM_VolumeController_OnDragVolumeController::FRatio' has a wrong offset!");

// Function MirMobile.MM_Xdraco_SealingInventory.OnClickSlot
// 0x0004 (0x0004 - 0x0000)
struct MM_Xdraco_SealingInventory_OnClickSlot final
{
public:
	int32                                         ItemTID;                                           // 0x0000(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(MM_Xdraco_SealingInventory_OnClickSlot) == 0x000004, "Wrong alignment on MM_Xdraco_SealingInventory_OnClickSlot");
static_assert(sizeof(MM_Xdraco_SealingInventory_OnClickSlot) == 0x000004, "Wrong size on MM_Xdraco_SealingInventory_OnClickSlot");
static_assert(offsetof(MM_Xdraco_SealingInventory_OnClickSlot, ItemTID) == 0x000000, "Member 'MM_Xdraco_SealingInventory_OnClickSlot::ItemTID' has a wrong offset!");

// Function MirMobile.MM_XsollaWebBrowser.OnBeforePopup
// 0x0020 (0x0020 - 0x0000)
struct MM_XsollaWebBrowser_OnBeforePopup final
{
public:
	class FString                                 URL;                                               // 0x0000(0x0010)(Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 Frame;                                             // 0x0010(0x0010)(Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(MM_XsollaWebBrowser_OnBeforePopup) == 0x000008, "Wrong alignment on MM_XsollaWebBrowser_OnBeforePopup");
static_assert(sizeof(MM_XsollaWebBrowser_OnBeforePopup) == 0x000020, "Wrong size on MM_XsollaWebBrowser_OnBeforePopup");
static_assert(offsetof(MM_XsollaWebBrowser_OnBeforePopup, URL) == 0x000000, "Member 'MM_XsollaWebBrowser_OnBeforePopup::URL' has a wrong offset!");
static_assert(offsetof(MM_XsollaWebBrowser_OnBeforePopup, Frame) == 0x000010, "Member 'MM_XsollaWebBrowser_OnBeforePopup::Frame' has a wrong offset!");

// Function MirMobile.MM_XsollaWebBrowser.OnSocialAuthError
// 0x0020 (0x0020 - 0x0000)
struct MM_XsollaWebBrowser_OnSocialAuthError final
{
public:
	class FString                                 Code;                                              // 0x0000(0x0010)(Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 Description;                                       // 0x0010(0x0010)(Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(MM_XsollaWebBrowser_OnSocialAuthError) == 0x000008, "Wrong alignment on MM_XsollaWebBrowser_OnSocialAuthError");
static_assert(sizeof(MM_XsollaWebBrowser_OnSocialAuthError) == 0x000020, "Wrong size on MM_XsollaWebBrowser_OnSocialAuthError");
static_assert(offsetof(MM_XsollaWebBrowser_OnSocialAuthError, Code) == 0x000000, "Member 'MM_XsollaWebBrowser_OnSocialAuthError::Code' has a wrong offset!");
static_assert(offsetof(MM_XsollaWebBrowser_OnSocialAuthError, Description) == 0x000010, "Member 'MM_XsollaWebBrowser_OnSocialAuthError::Description' has a wrong offset!");

// Function MirMobile.MM_XsollaWebBrowser.OnSocialAuthUrlReceived
// 0x0010 (0x0010 - 0x0000)
struct MM_XsollaWebBrowser_OnSocialAuthUrlReceived final
{
public:
	class FString                                 URL;                                               // 0x0000(0x0010)(Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(MM_XsollaWebBrowser_OnSocialAuthUrlReceived) == 0x000008, "Wrong alignment on MM_XsollaWebBrowser_OnSocialAuthUrlReceived");
static_assert(sizeof(MM_XsollaWebBrowser_OnSocialAuthUrlReceived) == 0x000010, "Wrong size on MM_XsollaWebBrowser_OnSocialAuthUrlReceived");
static_assert(offsetof(MM_XsollaWebBrowser_OnSocialAuthUrlReceived, URL) == 0x000000, "Member 'MM_XsollaWebBrowser_OnSocialAuthUrlReceived::URL' has a wrong offset!");

// Function MirMobile.MM_XsollaWebBrowser.OnUrlChanged
// 0x0018 (0x0018 - 0x0000)
struct MM_XsollaWebBrowser_OnUrlChanged final
{
public:
	class FText                                   URL;                                               // 0x0000(0x0018)(ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
};
static_assert(alignof(MM_XsollaWebBrowser_OnUrlChanged) == 0x000008, "Wrong alignment on MM_XsollaWebBrowser_OnUrlChanged");
static_assert(sizeof(MM_XsollaWebBrowser_OnUrlChanged) == 0x000018, "Wrong size on MM_XsollaWebBrowser_OnUrlChanged");
static_assert(offsetof(MM_XsollaWebBrowser_OnUrlChanged, URL) == 0x000000, "Member 'MM_XsollaWebBrowser_OnUrlChanged::URL' has a wrong offset!");

// Function MirMobile.MMBlueprintFunctionLibrary.ConvertToSoftObjectPath
// 0x0020 (0x0020 - 0x0000)
struct MMBlueprintFunctionLibrary_ConvertToSoftObjectPath final
{
public:
	class FString                                 ObjectPath;                                        // 0x0000(0x0010)(Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 ReturnValue;                                       // 0x0010(0x0010)(Parm, OutParm, ZeroConstructor, ReturnParm, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(MMBlueprintFunctionLibrary_ConvertToSoftObjectPath) == 0x000008, "Wrong alignment on MMBlueprintFunctionLibrary_ConvertToSoftObjectPath");
static_assert(sizeof(MMBlueprintFunctionLibrary_ConvertToSoftObjectPath) == 0x000020, "Wrong size on MMBlueprintFunctionLibrary_ConvertToSoftObjectPath");
static_assert(offsetof(MMBlueprintFunctionLibrary_ConvertToSoftObjectPath, ObjectPath) == 0x000000, "Member 'MMBlueprintFunctionLibrary_ConvertToSoftObjectPath::ObjectPath' has a wrong offset!");
static_assert(offsetof(MMBlueprintFunctionLibrary_ConvertToSoftObjectPath, ReturnValue) == 0x000010, "Member 'MMBlueprintFunctionLibrary_ConvertToSoftObjectPath::ReturnValue' has a wrong offset!");

// Function MirMobile.MMBlueprintFunctionLibrary.DrawDebugFloat
// 0x0070 (0x0070 - 0x0000)
struct MMBlueprintFunctionLibrary_DrawDebugFloat final
{
public:
	class UObject*                                WorldContextObject;                                // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 Title;                                             // 0x0008(0x0010)(Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FDebugFloatHistory                     FloatHistory;                                      // 0x0018(0x0020)(Parm, NativeAccessSpecifierPublic)
	float                                         DrawX;                                             // 0x0038(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         DrawY;                                             // 0x003C(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         DrawSizeX;                                         // 0x0040(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         DrawSizeY;                                         // 0x0044(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         HistoryValue;                                      // 0x0048(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_4C[0x4];                                       // 0x004C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	struct FDebugFloatHistory                     ReturnValue;                                       // 0x0050(0x0020)(Parm, OutParm, ReturnParm, NativeAccessSpecifierPublic)
};
static_assert(alignof(MMBlueprintFunctionLibrary_DrawDebugFloat) == 0x000008, "Wrong alignment on MMBlueprintFunctionLibrary_DrawDebugFloat");
static_assert(sizeof(MMBlueprintFunctionLibrary_DrawDebugFloat) == 0x000070, "Wrong size on MMBlueprintFunctionLibrary_DrawDebugFloat");
static_assert(offsetof(MMBlueprintFunctionLibrary_DrawDebugFloat, WorldContextObject) == 0x000000, "Member 'MMBlueprintFunctionLibrary_DrawDebugFloat::WorldContextObject' has a wrong offset!");
static_assert(offsetof(MMBlueprintFunctionLibrary_DrawDebugFloat, Title) == 0x000008, "Member 'MMBlueprintFunctionLibrary_DrawDebugFloat::Title' has a wrong offset!");
static_assert(offsetof(MMBlueprintFunctionLibrary_DrawDebugFloat, FloatHistory) == 0x000018, "Member 'MMBlueprintFunctionLibrary_DrawDebugFloat::FloatHistory' has a wrong offset!");
static_assert(offsetof(MMBlueprintFunctionLibrary_DrawDebugFloat, DrawX) == 0x000038, "Member 'MMBlueprintFunctionLibrary_DrawDebugFloat::DrawX' has a wrong offset!");
static_assert(offsetof(MMBlueprintFunctionLibrary_DrawDebugFloat, DrawY) == 0x00003C, "Member 'MMBlueprintFunctionLibrary_DrawDebugFloat::DrawY' has a wrong offset!");
static_assert(offsetof(MMBlueprintFunctionLibrary_DrawDebugFloat, DrawSizeX) == 0x000040, "Member 'MMBlueprintFunctionLibrary_DrawDebugFloat::DrawSizeX' has a wrong offset!");
static_assert(offsetof(MMBlueprintFunctionLibrary_DrawDebugFloat, DrawSizeY) == 0x000044, "Member 'MMBlueprintFunctionLibrary_DrawDebugFloat::DrawSizeY' has a wrong offset!");
static_assert(offsetof(MMBlueprintFunctionLibrary_DrawDebugFloat, HistoryValue) == 0x000048, "Member 'MMBlueprintFunctionLibrary_DrawDebugFloat::HistoryValue' has a wrong offset!");
static_assert(offsetof(MMBlueprintFunctionLibrary_DrawDebugFloat, ReturnValue) == 0x000050, "Member 'MMBlueprintFunctionLibrary_DrawDebugFloat::ReturnValue' has a wrong offset!");

// Function MirMobile.MMBlueprintFunctionLibrary.DrawNavigationPath
// 0x0040 (0x0040 - 0x0000)
struct MMBlueprintFunctionLibrary_DrawNavigationPath final
{
public:
	const class UObject*                          Object;                                            // 0x0000(0x0008)(ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bStraight;                                         // 0x0008(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_9[0x3];                                        // 0x0009(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	struct FVector                                Start;                                             // 0x000C(0x000C)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                End;                                               // 0x0018(0x000C)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FLinearColor                           Color;                                             // 0x0024(0x0010)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_34[0x4];                                       // 0x0034(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	TSubclassOf<class UNavigationQueryFilter>     FilterClass;                                       // 0x0038(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(MMBlueprintFunctionLibrary_DrawNavigationPath) == 0x000008, "Wrong alignment on MMBlueprintFunctionLibrary_DrawNavigationPath");
static_assert(sizeof(MMBlueprintFunctionLibrary_DrawNavigationPath) == 0x000040, "Wrong size on MMBlueprintFunctionLibrary_DrawNavigationPath");
static_assert(offsetof(MMBlueprintFunctionLibrary_DrawNavigationPath, Object) == 0x000000, "Member 'MMBlueprintFunctionLibrary_DrawNavigationPath::Object' has a wrong offset!");
static_assert(offsetof(MMBlueprintFunctionLibrary_DrawNavigationPath, bStraight) == 0x000008, "Member 'MMBlueprintFunctionLibrary_DrawNavigationPath::bStraight' has a wrong offset!");
static_assert(offsetof(MMBlueprintFunctionLibrary_DrawNavigationPath, Start) == 0x00000C, "Member 'MMBlueprintFunctionLibrary_DrawNavigationPath::Start' has a wrong offset!");
static_assert(offsetof(MMBlueprintFunctionLibrary_DrawNavigationPath, End) == 0x000018, "Member 'MMBlueprintFunctionLibrary_DrawNavigationPath::End' has a wrong offset!");
static_assert(offsetof(MMBlueprintFunctionLibrary_DrawNavigationPath, Color) == 0x000024, "Member 'MMBlueprintFunctionLibrary_DrawNavigationPath::Color' has a wrong offset!");
static_assert(offsetof(MMBlueprintFunctionLibrary_DrawNavigationPath, FilterClass) == 0x000038, "Member 'MMBlueprintFunctionLibrary_DrawNavigationPath::FilterClass' has a wrong offset!");

// Function MirMobile.MMBlueprintFunctionLibrary.FixDrawDebugSolidBox
// 0x0040 (0x0040 - 0x0000)
struct MMBlueprintFunctionLibrary_FixDrawDebugSolidBox final
{
public:
	class UObject*                                WorldContextObject;                                // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                Center;                                            // 0x0008(0x000C)(ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                Extent;                                            // 0x0014(0x000C)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FLinearColor                           LineColor;                                         // 0x0020(0x0010)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FRotator                               Rotation;                                          // 0x0030(0x000C)(ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	uint8                                         Pad_3C[0x4];                                       // 0x003C(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(MMBlueprintFunctionLibrary_FixDrawDebugSolidBox) == 0x000008, "Wrong alignment on MMBlueprintFunctionLibrary_FixDrawDebugSolidBox");
static_assert(sizeof(MMBlueprintFunctionLibrary_FixDrawDebugSolidBox) == 0x000040, "Wrong size on MMBlueprintFunctionLibrary_FixDrawDebugSolidBox");
static_assert(offsetof(MMBlueprintFunctionLibrary_FixDrawDebugSolidBox, WorldContextObject) == 0x000000, "Member 'MMBlueprintFunctionLibrary_FixDrawDebugSolidBox::WorldContextObject' has a wrong offset!");
static_assert(offsetof(MMBlueprintFunctionLibrary_FixDrawDebugSolidBox, Center) == 0x000008, "Member 'MMBlueprintFunctionLibrary_FixDrawDebugSolidBox::Center' has a wrong offset!");
static_assert(offsetof(MMBlueprintFunctionLibrary_FixDrawDebugSolidBox, Extent) == 0x000014, "Member 'MMBlueprintFunctionLibrary_FixDrawDebugSolidBox::Extent' has a wrong offset!");
static_assert(offsetof(MMBlueprintFunctionLibrary_FixDrawDebugSolidBox, LineColor) == 0x000020, "Member 'MMBlueprintFunctionLibrary_FixDrawDebugSolidBox::LineColor' has a wrong offset!");
static_assert(offsetof(MMBlueprintFunctionLibrary_FixDrawDebugSolidBox, Rotation) == 0x000030, "Member 'MMBlueprintFunctionLibrary_FixDrawDebugSolidBox::Rotation' has a wrong offset!");

// Function MirMobile.MMBlueprintFunctionLibrary.GetAbsolutePosition
// 0x0010 (0x0010 - 0x0000)
struct MMBlueprintFunctionLibrary_GetAbsolutePosition final
{
public:
	class UWidget*                                PWidget;                                           // 0x0000(0x0008)(Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector2D                              ReturnValue;                                       // 0x0008(0x0008)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(MMBlueprintFunctionLibrary_GetAbsolutePosition) == 0x000008, "Wrong alignment on MMBlueprintFunctionLibrary_GetAbsolutePosition");
static_assert(sizeof(MMBlueprintFunctionLibrary_GetAbsolutePosition) == 0x000010, "Wrong size on MMBlueprintFunctionLibrary_GetAbsolutePosition");
static_assert(offsetof(MMBlueprintFunctionLibrary_GetAbsolutePosition, PWidget) == 0x000000, "Member 'MMBlueprintFunctionLibrary_GetAbsolutePosition::PWidget' has a wrong offset!");
static_assert(offsetof(MMBlueprintFunctionLibrary_GetAbsolutePosition, ReturnValue) == 0x000008, "Member 'MMBlueprintFunctionLibrary_GetAbsolutePosition::ReturnValue' has a wrong offset!");

// Function MirMobile.MMBlueprintFunctionLibrary.GetChildWidget
// 0x0018 (0x0018 - 0x0000)
struct MMBlueprintFunctionLibrary_GetChildWidget final
{
public:
	class UWidget*                                PWidget;                                           // 0x0000(0x0008)(Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<class UWidget*>                        ReturnValue;                                       // 0x0008(0x0010)(ExportObject, Parm, OutParm, ZeroConstructor, ReturnParm, ContainsInstancedReference, NativeAccessSpecifierPublic)
};
static_assert(alignof(MMBlueprintFunctionLibrary_GetChildWidget) == 0x000008, "Wrong alignment on MMBlueprintFunctionLibrary_GetChildWidget");
static_assert(sizeof(MMBlueprintFunctionLibrary_GetChildWidget) == 0x000018, "Wrong size on MMBlueprintFunctionLibrary_GetChildWidget");
static_assert(offsetof(MMBlueprintFunctionLibrary_GetChildWidget, PWidget) == 0x000000, "Member 'MMBlueprintFunctionLibrary_GetChildWidget::PWidget' has a wrong offset!");
static_assert(offsetof(MMBlueprintFunctionLibrary_GetChildWidget, ReturnValue) == 0x000008, "Member 'MMBlueprintFunctionLibrary_GetChildWidget::ReturnValue' has a wrong offset!");

// Function MirMobile.MMBlueprintFunctionLibrary.GetCurrentStageID
// 0x0004 (0x0004 - 0x0000)
struct MMBlueprintFunctionLibrary_GetCurrentStageID final
{
public:
	int32                                         ReturnValue;                                       // 0x0000(0x0004)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(MMBlueprintFunctionLibrary_GetCurrentStageID) == 0x000004, "Wrong alignment on MMBlueprintFunctionLibrary_GetCurrentStageID");
static_assert(sizeof(MMBlueprintFunctionLibrary_GetCurrentStageID) == 0x000004, "Wrong size on MMBlueprintFunctionLibrary_GetCurrentStageID");
static_assert(offsetof(MMBlueprintFunctionLibrary_GetCurrentStageID, ReturnValue) == 0x000000, "Member 'MMBlueprintFunctionLibrary_GetCurrentStageID::ReturnValue' has a wrong offset!");

// Function MirMobile.MMBlueprintFunctionLibrary.GetGameWorld
// 0x0008 (0x0008 - 0x0000)
struct MMBlueprintFunctionLibrary_GetGameWorld final
{
public:
	class UWorld*                                 ReturnValue;                                       // 0x0000(0x0008)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(MMBlueprintFunctionLibrary_GetGameWorld) == 0x000008, "Wrong alignment on MMBlueprintFunctionLibrary_GetGameWorld");
static_assert(sizeof(MMBlueprintFunctionLibrary_GetGameWorld) == 0x000008, "Wrong size on MMBlueprintFunctionLibrary_GetGameWorld");
static_assert(offsetof(MMBlueprintFunctionLibrary_GetGameWorld, ReturnValue) == 0x000000, "Member 'MMBlueprintFunctionLibrary_GetGameWorld::ReturnValue' has a wrong offset!");

// Function MirMobile.MMBlueprintFunctionLibrary.GetMainPC
// 0x0008 (0x0008 - 0x0000)
struct MMBlueprintFunctionLibrary_GetMainPC final
{
public:
	class AMM_MainPC*                             ReturnValue;                                       // 0x0000(0x0008)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(MMBlueprintFunctionLibrary_GetMainPC) == 0x000008, "Wrong alignment on MMBlueprintFunctionLibrary_GetMainPC");
static_assert(sizeof(MMBlueprintFunctionLibrary_GetMainPC) == 0x000008, "Wrong size on MMBlueprintFunctionLibrary_GetMainPC");
static_assert(offsetof(MMBlueprintFunctionLibrary_GetMainPC, ReturnValue) == 0x000000, "Member 'MMBlueprintFunctionLibrary_GetMainPC::ReturnValue' has a wrong offset!");

// Function MirMobile.MMBlueprintFunctionLibrary.GetMessageString
// 0x0018 (0x0018 - 0x0000)
struct MMBlueprintFunctionLibrary_GetMessageString final
{
public:
	int32                                         StringID;                                          // 0x0000(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_4[0x4];                                        // 0x0004(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class FString                                 ReturnValue;                                       // 0x0008(0x0010)(Parm, OutParm, ZeroConstructor, ReturnParm, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(MMBlueprintFunctionLibrary_GetMessageString) == 0x000008, "Wrong alignment on MMBlueprintFunctionLibrary_GetMessageString");
static_assert(sizeof(MMBlueprintFunctionLibrary_GetMessageString) == 0x000018, "Wrong size on MMBlueprintFunctionLibrary_GetMessageString");
static_assert(offsetof(MMBlueprintFunctionLibrary_GetMessageString, StringID) == 0x000000, "Member 'MMBlueprintFunctionLibrary_GetMessageString::StringID' has a wrong offset!");
static_assert(offsetof(MMBlueprintFunctionLibrary_GetMessageString, ReturnValue) == 0x000008, "Member 'MMBlueprintFunctionLibrary_GetMessageString::ReturnValue' has a wrong offset!");

// Function MirMobile.MMBlueprintFunctionLibrary.GetMirDataTable
// 0x0018 (0x0018 - 0x0000)
struct MMBlueprintFunctionLibrary_GetMirDataTable final
{
public:
	class FString                                 TableTypeName;                                     // 0x0000(0x0010)(Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UDataTable*                             ReturnValue;                                       // 0x0010(0x0008)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(MMBlueprintFunctionLibrary_GetMirDataTable) == 0x000008, "Wrong alignment on MMBlueprintFunctionLibrary_GetMirDataTable");
static_assert(sizeof(MMBlueprintFunctionLibrary_GetMirDataTable) == 0x000018, "Wrong size on MMBlueprintFunctionLibrary_GetMirDataTable");
static_assert(offsetof(MMBlueprintFunctionLibrary_GetMirDataTable, TableTypeName) == 0x000000, "Member 'MMBlueprintFunctionLibrary_GetMirDataTable::TableTypeName' has a wrong offset!");
static_assert(offsetof(MMBlueprintFunctionLibrary_GetMirDataTable, ReturnValue) == 0x000010, "Member 'MMBlueprintFunctionLibrary_GetMirDataTable::ReturnValue' has a wrong offset!");

// Function MirMobile.MMBlueprintFunctionLibrary.GetPickedActor
// 0x0020 (0x0020 - 0x0000)
struct MMBlueprintFunctionLibrary_GetPickedActor final
{
public:
	class UObject*                                PWorldContextObject;                               // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<EObjectTypeQuery>                      ObjectTypes;                                       // 0x0008(0x0010)(ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, NativeAccessSpecifierPublic)
	class AActor*                                 ReturnValue;                                       // 0x0018(0x0008)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(MMBlueprintFunctionLibrary_GetPickedActor) == 0x000008, "Wrong alignment on MMBlueprintFunctionLibrary_GetPickedActor");
static_assert(sizeof(MMBlueprintFunctionLibrary_GetPickedActor) == 0x000020, "Wrong size on MMBlueprintFunctionLibrary_GetPickedActor");
static_assert(offsetof(MMBlueprintFunctionLibrary_GetPickedActor, PWorldContextObject) == 0x000000, "Member 'MMBlueprintFunctionLibrary_GetPickedActor::PWorldContextObject' has a wrong offset!");
static_assert(offsetof(MMBlueprintFunctionLibrary_GetPickedActor, ObjectTypes) == 0x000008, "Member 'MMBlueprintFunctionLibrary_GetPickedActor::ObjectTypes' has a wrong offset!");
static_assert(offsetof(MMBlueprintFunctionLibrary_GetPickedActor, ReturnValue) == 0x000018, "Member 'MMBlueprintFunctionLibrary_GetPickedActor::ReturnValue' has a wrong offset!");

// Function MirMobile.MMBlueprintFunctionLibrary.GetPlayerClassID
// 0x0004 (0x0004 - 0x0000)
struct MMBlueprintFunctionLibrary_GetPlayerClassID final
{
public:
	int32                                         ReturnValue;                                       // 0x0000(0x0004)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(MMBlueprintFunctionLibrary_GetPlayerClassID) == 0x000004, "Wrong alignment on MMBlueprintFunctionLibrary_GetPlayerClassID");
static_assert(sizeof(MMBlueprintFunctionLibrary_GetPlayerClassID) == 0x000004, "Wrong size on MMBlueprintFunctionLibrary_GetPlayerClassID");
static_assert(offsetof(MMBlueprintFunctionLibrary_GetPlayerClassID, ReturnValue) == 0x000000, "Member 'MMBlueprintFunctionLibrary_GetPlayerClassID::ReturnValue' has a wrong offset!");

// Function MirMobile.MMBlueprintFunctionLibrary.GetSkeletalMesh
// 0x0018 (0x0018 - 0x0000)
struct MMBlueprintFunctionLibrary_GetSkeletalMesh final
{
public:
	class FString                                 Filename;                                          // 0x0000(0x0010)(Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class USkeletalMesh*                          ReturnValue;                                       // 0x0010(0x0008)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(MMBlueprintFunctionLibrary_GetSkeletalMesh) == 0x000008, "Wrong alignment on MMBlueprintFunctionLibrary_GetSkeletalMesh");
static_assert(sizeof(MMBlueprintFunctionLibrary_GetSkeletalMesh) == 0x000018, "Wrong size on MMBlueprintFunctionLibrary_GetSkeletalMesh");
static_assert(offsetof(MMBlueprintFunctionLibrary_GetSkeletalMesh, Filename) == 0x000000, "Member 'MMBlueprintFunctionLibrary_GetSkeletalMesh::Filename' has a wrong offset!");
static_assert(offsetof(MMBlueprintFunctionLibrary_GetSkeletalMesh, ReturnValue) == 0x000010, "Member 'MMBlueprintFunctionLibrary_GetSkeletalMesh::ReturnValue' has a wrong offset!");

// Function MirMobile.MMBlueprintFunctionLibrary.GetSvnID
// 0x0010 (0x0010 - 0x0000)
struct MMBlueprintFunctionLibrary_GetSvnID final
{
public:
	class FString                                 ReturnValue;                                       // 0x0000(0x0010)(Parm, OutParm, ZeroConstructor, ReturnParm, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(MMBlueprintFunctionLibrary_GetSvnID) == 0x000008, "Wrong alignment on MMBlueprintFunctionLibrary_GetSvnID");
static_assert(sizeof(MMBlueprintFunctionLibrary_GetSvnID) == 0x000010, "Wrong size on MMBlueprintFunctionLibrary_GetSvnID");
static_assert(offsetof(MMBlueprintFunctionLibrary_GetSvnID, ReturnValue) == 0x000000, "Member 'MMBlueprintFunctionLibrary_GetSvnID::ReturnValue' has a wrong offset!");

// Function MirMobile.MMBlueprintFunctionLibrary.GetTargetMonster
// 0x0018 (0x0018 - 0x0000)
struct MMBlueprintFunctionLibrary_GetTargetMonster final
{
public:
	class UObject*                                WorldContextObject;                                // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EACTION_RESULT                                ActionResult;                                      // 0x0008(0x0001)(Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_9[0x7];                                        // 0x0009(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	class AMM_Monster*                            ReturnValue;                                       // 0x0010(0x0008)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(MMBlueprintFunctionLibrary_GetTargetMonster) == 0x000008, "Wrong alignment on MMBlueprintFunctionLibrary_GetTargetMonster");
static_assert(sizeof(MMBlueprintFunctionLibrary_GetTargetMonster) == 0x000018, "Wrong size on MMBlueprintFunctionLibrary_GetTargetMonster");
static_assert(offsetof(MMBlueprintFunctionLibrary_GetTargetMonster, WorldContextObject) == 0x000000, "Member 'MMBlueprintFunctionLibrary_GetTargetMonster::WorldContextObject' has a wrong offset!");
static_assert(offsetof(MMBlueprintFunctionLibrary_GetTargetMonster, ActionResult) == 0x000008, "Member 'MMBlueprintFunctionLibrary_GetTargetMonster::ActionResult' has a wrong offset!");
static_assert(offsetof(MMBlueprintFunctionLibrary_GetTargetMonster, ReturnValue) == 0x000010, "Member 'MMBlueprintFunctionLibrary_GetTargetMonster::ReturnValue' has a wrong offset!");

// Function MirMobile.MMBlueprintFunctionLibrary.GetTargetNetPC
// 0x0018 (0x0018 - 0x0000)
struct MMBlueprintFunctionLibrary_GetTargetNetPC final
{
public:
	class UObject*                                WorldContextObject;                                // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EACTION_RESULT                                ActionResult;                                      // 0x0008(0x0001)(Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_9[0x7];                                        // 0x0009(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	class AMM_NetPC*                              ReturnValue;                                       // 0x0010(0x0008)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(MMBlueprintFunctionLibrary_GetTargetNetPC) == 0x000008, "Wrong alignment on MMBlueprintFunctionLibrary_GetTargetNetPC");
static_assert(sizeof(MMBlueprintFunctionLibrary_GetTargetNetPC) == 0x000018, "Wrong size on MMBlueprintFunctionLibrary_GetTargetNetPC");
static_assert(offsetof(MMBlueprintFunctionLibrary_GetTargetNetPC, WorldContextObject) == 0x000000, "Member 'MMBlueprintFunctionLibrary_GetTargetNetPC::WorldContextObject' has a wrong offset!");
static_assert(offsetof(MMBlueprintFunctionLibrary_GetTargetNetPC, ActionResult) == 0x000008, "Member 'MMBlueprintFunctionLibrary_GetTargetNetPC::ActionResult' has a wrong offset!");
static_assert(offsetof(MMBlueprintFunctionLibrary_GetTargetNetPC, ReturnValue) == 0x000010, "Member 'MMBlueprintFunctionLibrary_GetTargetNetPC::ReturnValue' has a wrong offset!");

// Function MirMobile.MMBlueprintFunctionLibrary.GetTemplateString
// 0x0018 (0x0018 - 0x0000)
struct MMBlueprintFunctionLibrary_GetTemplateString final
{
public:
	int32                                         StringID;                                          // 0x0000(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_4[0x4];                                        // 0x0004(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class FString                                 ReturnValue;                                       // 0x0008(0x0010)(Parm, OutParm, ZeroConstructor, ReturnParm, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(MMBlueprintFunctionLibrary_GetTemplateString) == 0x000008, "Wrong alignment on MMBlueprintFunctionLibrary_GetTemplateString");
static_assert(sizeof(MMBlueprintFunctionLibrary_GetTemplateString) == 0x000018, "Wrong size on MMBlueprintFunctionLibrary_GetTemplateString");
static_assert(offsetof(MMBlueprintFunctionLibrary_GetTemplateString, StringID) == 0x000000, "Member 'MMBlueprintFunctionLibrary_GetTemplateString::StringID' has a wrong offset!");
static_assert(offsetof(MMBlueprintFunctionLibrary_GetTemplateString, ReturnValue) == 0x000008, "Member 'MMBlueprintFunctionLibrary_GetTemplateString::ReturnValue' has a wrong offset!");

// Function MirMobile.MMBlueprintFunctionLibrary.GetWorldType_BP
// 0x0010 (0x0010 - 0x0000)
struct MMBlueprintFunctionLibrary_GetWorldType_BP final
{
public:
	class UObject*                                WorldContextObject;                                // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EWorld_Type                                   OutResult;                                         // 0x0008(0x0001)(Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_9[0x7];                                        // 0x0009(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(MMBlueprintFunctionLibrary_GetWorldType_BP) == 0x000008, "Wrong alignment on MMBlueprintFunctionLibrary_GetWorldType_BP");
static_assert(sizeof(MMBlueprintFunctionLibrary_GetWorldType_BP) == 0x000010, "Wrong size on MMBlueprintFunctionLibrary_GetWorldType_BP");
static_assert(offsetof(MMBlueprintFunctionLibrary_GetWorldType_BP, WorldContextObject) == 0x000000, "Member 'MMBlueprintFunctionLibrary_GetWorldType_BP::WorldContextObject' has a wrong offset!");
static_assert(offsetof(MMBlueprintFunctionLibrary_GetWorldType_BP, OutResult) == 0x000008, "Member 'MMBlueprintFunctionLibrary_GetWorldType_BP::OutResult' has a wrong offset!");

// Function MirMobile.MMBlueprintFunctionLibrary.IsMirDebugMode
// 0x0001 (0x0001 - 0x0000)
struct MMBlueprintFunctionLibrary_IsMirDebugMode final
{
public:
	bool                                          ReturnValue;                                       // 0x0000(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(MMBlueprintFunctionLibrary_IsMirDebugMode) == 0x000001, "Wrong alignment on MMBlueprintFunctionLibrary_IsMirDebugMode");
static_assert(sizeof(MMBlueprintFunctionLibrary_IsMirDebugMode) == 0x000001, "Wrong size on MMBlueprintFunctionLibrary_IsMirDebugMode");
static_assert(offsetof(MMBlueprintFunctionLibrary_IsMirDebugMode, ReturnValue) == 0x000000, "Member 'MMBlueprintFunctionLibrary_IsMirDebugMode::ReturnValue' has a wrong offset!");

// Function MirMobile.MMBlueprintFunctionLibrary.IsNavigationPathExists
// 0x0030 (0x0030 - 0x0000)
struct MMBlueprintFunctionLibrary_IsNavigationPathExists final
{
public:
	const class UObject*                          Object;                                            // 0x0000(0x0008)(ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                Start;                                             // 0x0008(0x000C)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                End;                                               // 0x0014(0x000C)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSubclassOf<class UNavigationQueryFilter>     FilterClass;                                       // 0x0020(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          ReturnValue;                                       // 0x0028(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_29[0x7];                                       // 0x0029(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(MMBlueprintFunctionLibrary_IsNavigationPathExists) == 0x000008, "Wrong alignment on MMBlueprintFunctionLibrary_IsNavigationPathExists");
static_assert(sizeof(MMBlueprintFunctionLibrary_IsNavigationPathExists) == 0x000030, "Wrong size on MMBlueprintFunctionLibrary_IsNavigationPathExists");
static_assert(offsetof(MMBlueprintFunctionLibrary_IsNavigationPathExists, Object) == 0x000000, "Member 'MMBlueprintFunctionLibrary_IsNavigationPathExists::Object' has a wrong offset!");
static_assert(offsetof(MMBlueprintFunctionLibrary_IsNavigationPathExists, Start) == 0x000008, "Member 'MMBlueprintFunctionLibrary_IsNavigationPathExists::Start' has a wrong offset!");
static_assert(offsetof(MMBlueprintFunctionLibrary_IsNavigationPathExists, End) == 0x000014, "Member 'MMBlueprintFunctionLibrary_IsNavigationPathExists::End' has a wrong offset!");
static_assert(offsetof(MMBlueprintFunctionLibrary_IsNavigationPathExists, FilterClass) == 0x000020, "Member 'MMBlueprintFunctionLibrary_IsNavigationPathExists::FilterClass' has a wrong offset!");
static_assert(offsetof(MMBlueprintFunctionLibrary_IsNavigationPathExists, ReturnValue) == 0x000028, "Member 'MMBlueprintFunctionLibrary_IsNavigationPathExists::ReturnValue' has a wrong offset!");

// Function MirMobile.MMBlueprintFunctionLibrary.IsPhasingMode
// 0x0001 (0x0001 - 0x0000)
struct MMBlueprintFunctionLibrary_IsPhasingMode final
{
public:
	bool                                          ReturnValue;                                       // 0x0000(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(MMBlueprintFunctionLibrary_IsPhasingMode) == 0x000001, "Wrong alignment on MMBlueprintFunctionLibrary_IsPhasingMode");
static_assert(sizeof(MMBlueprintFunctionLibrary_IsPhasingMode) == 0x000001, "Wrong size on MMBlueprintFunctionLibrary_IsPhasingMode");
static_assert(offsetof(MMBlueprintFunctionLibrary_IsPhasingMode, ReturnValue) == 0x000000, "Member 'MMBlueprintFunctionLibrary_IsPhasingMode::ReturnValue' has a wrong offset!");

// Function MirMobile.MMBlueprintFunctionLibrary.IsSimulateInEditorViewport
// 0x0001 (0x0001 - 0x0000)
struct MMBlueprintFunctionLibrary_IsSimulateInEditorViewport final
{
public:
	bool                                          ReturnValue;                                       // 0x0000(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(MMBlueprintFunctionLibrary_IsSimulateInEditorViewport) == 0x000001, "Wrong alignment on MMBlueprintFunctionLibrary_IsSimulateInEditorViewport");
static_assert(sizeof(MMBlueprintFunctionLibrary_IsSimulateInEditorViewport) == 0x000001, "Wrong size on MMBlueprintFunctionLibrary_IsSimulateInEditorViewport");
static_assert(offsetof(MMBlueprintFunctionLibrary_IsSimulateInEditorViewport, ReturnValue) == 0x000000, "Member 'MMBlueprintFunctionLibrary_IsSimulateInEditorViewport::ReturnValue' has a wrong offset!");

// Function MirMobile.MMBlueprintFunctionLibrary.LoadIcon
// 0x0018 (0x0018 - 0x0000)
struct MMBlueprintFunctionLibrary_LoadIcon final
{
public:
	class FString                                 Filename;                                          // 0x0000(0x0010)(Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UObject*                                ReturnValue;                                       // 0x0010(0x0008)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(MMBlueprintFunctionLibrary_LoadIcon) == 0x000008, "Wrong alignment on MMBlueprintFunctionLibrary_LoadIcon");
static_assert(sizeof(MMBlueprintFunctionLibrary_LoadIcon) == 0x000018, "Wrong size on MMBlueprintFunctionLibrary_LoadIcon");
static_assert(offsetof(MMBlueprintFunctionLibrary_LoadIcon, Filename) == 0x000000, "Member 'MMBlueprintFunctionLibrary_LoadIcon::Filename' has a wrong offset!");
static_assert(offsetof(MMBlueprintFunctionLibrary_LoadIcon, ReturnValue) == 0x000010, "Member 'MMBlueprintFunctionLibrary_LoadIcon::ReturnValue' has a wrong offset!");

// Function MirMobile.MMBlueprintFunctionLibrary.LoadObjectByObjectPath
// 0x0018 (0x0018 - 0x0000)
struct MMBlueprintFunctionLibrary_LoadObjectByObjectPath final
{
public:
	class FString                                 Filename;                                          // 0x0000(0x0010)(Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UObject*                                ReturnValue;                                       // 0x0010(0x0008)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(MMBlueprintFunctionLibrary_LoadObjectByObjectPath) == 0x000008, "Wrong alignment on MMBlueprintFunctionLibrary_LoadObjectByObjectPath");
static_assert(sizeof(MMBlueprintFunctionLibrary_LoadObjectByObjectPath) == 0x000018, "Wrong size on MMBlueprintFunctionLibrary_LoadObjectByObjectPath");
static_assert(offsetof(MMBlueprintFunctionLibrary_LoadObjectByObjectPath, Filename) == 0x000000, "Member 'MMBlueprintFunctionLibrary_LoadObjectByObjectPath::Filename' has a wrong offset!");
static_assert(offsetof(MMBlueprintFunctionLibrary_LoadObjectByObjectPath, ReturnValue) == 0x000010, "Member 'MMBlueprintFunctionLibrary_LoadObjectByObjectPath::ReturnValue' has a wrong offset!");

// Function MirMobile.MMBlueprintFunctionLibrary.MarkPackageDirty
// 0x0010 (0x0010 - 0x0000)
struct MMBlueprintFunctionLibrary_MarkPackageDirty final
{
public:
	class UObject*                                DirtyObject;                                       // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          ReturnValue;                                       // 0x0008(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_9[0x7];                                        // 0x0009(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(MMBlueprintFunctionLibrary_MarkPackageDirty) == 0x000008, "Wrong alignment on MMBlueprintFunctionLibrary_MarkPackageDirty");
static_assert(sizeof(MMBlueprintFunctionLibrary_MarkPackageDirty) == 0x000010, "Wrong size on MMBlueprintFunctionLibrary_MarkPackageDirty");
static_assert(offsetof(MMBlueprintFunctionLibrary_MarkPackageDirty, DirtyObject) == 0x000000, "Member 'MMBlueprintFunctionLibrary_MarkPackageDirty::DirtyObject' has a wrong offset!");
static_assert(offsetof(MMBlueprintFunctionLibrary_MarkPackageDirty, ReturnValue) == 0x000008, "Member 'MMBlueprintFunctionLibrary_MarkPackageDirty::ReturnValue' has a wrong offset!");

// Function MirMobile.MMBlueprintFunctionLibrary.MirScriptExecute
// 0x0018 (0x0018 - 0x0000)
struct MMBlueprintFunctionLibrary_MirScriptExecute final
{
public:
	class UObject*                                WorldContextObject;                                // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<class FString>                         ScriptData;                                        // 0x0008(0x0010)(Parm, ZeroConstructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(MMBlueprintFunctionLibrary_MirScriptExecute) == 0x000008, "Wrong alignment on MMBlueprintFunctionLibrary_MirScriptExecute");
static_assert(sizeof(MMBlueprintFunctionLibrary_MirScriptExecute) == 0x000018, "Wrong size on MMBlueprintFunctionLibrary_MirScriptExecute");
static_assert(offsetof(MMBlueprintFunctionLibrary_MirScriptExecute, WorldContextObject) == 0x000000, "Member 'MMBlueprintFunctionLibrary_MirScriptExecute::WorldContextObject' has a wrong offset!");
static_assert(offsetof(MMBlueprintFunctionLibrary_MirScriptExecute, ScriptData) == 0x000008, "Member 'MMBlueprintFunctionLibrary_MirScriptExecute::ScriptData' has a wrong offset!");

// Function MirMobile.MMBlueprintFunctionLibrary.OpenTextPopup
// 0x0010 (0x0010 - 0x0000)
struct MMBlueprintFunctionLibrary_OpenTextPopup final
{
public:
	class FString                                 MessageString;                                     // 0x0000(0x0010)(Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(MMBlueprintFunctionLibrary_OpenTextPopup) == 0x000008, "Wrong alignment on MMBlueprintFunctionLibrary_OpenTextPopup");
static_assert(sizeof(MMBlueprintFunctionLibrary_OpenTextPopup) == 0x000010, "Wrong size on MMBlueprintFunctionLibrary_OpenTextPopup");
static_assert(offsetof(MMBlueprintFunctionLibrary_OpenTextPopup, MessageString) == 0x000000, "Member 'MMBlueprintFunctionLibrary_OpenTextPopup::MessageString' has a wrong offset!");

// Function MirMobile.MMBlueprintFunctionLibrary.PLATFORM_WIN64
// 0x0001 (0x0001 - 0x0000)
struct MMBlueprintFunctionLibrary_PLATFORM_WIN64 final
{
public:
	bool                                          ReturnValue;                                       // 0x0000(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(MMBlueprintFunctionLibrary_PLATFORM_WIN64) == 0x000001, "Wrong alignment on MMBlueprintFunctionLibrary_PLATFORM_WIN64");
static_assert(sizeof(MMBlueprintFunctionLibrary_PLATFORM_WIN64) == 0x000001, "Wrong size on MMBlueprintFunctionLibrary_PLATFORM_WIN64");
static_assert(offsetof(MMBlueprintFunctionLibrary_PLATFORM_WIN64, ReturnValue) == 0x000000, "Member 'MMBlueprintFunctionLibrary_PLATFORM_WIN64::ReturnValue' has a wrong offset!");

// Function MirMobile.MMBlueprintFunctionLibrary.RelationScriptExecute
// 0x0018 (0x0018 - 0x0000)
struct MMBlueprintFunctionLibrary_RelationScriptExecute final
{
public:
	class UObject*                                WorldContextObject;                                // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<class FString>                         ScriptData;                                        // 0x0008(0x0010)(Parm, ZeroConstructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(MMBlueprintFunctionLibrary_RelationScriptExecute) == 0x000008, "Wrong alignment on MMBlueprintFunctionLibrary_RelationScriptExecute");
static_assert(sizeof(MMBlueprintFunctionLibrary_RelationScriptExecute) == 0x000018, "Wrong size on MMBlueprintFunctionLibrary_RelationScriptExecute");
static_assert(offsetof(MMBlueprintFunctionLibrary_RelationScriptExecute, WorldContextObject) == 0x000000, "Member 'MMBlueprintFunctionLibrary_RelationScriptExecute::WorldContextObject' has a wrong offset!");
static_assert(offsetof(MMBlueprintFunctionLibrary_RelationScriptExecute, ScriptData) == 0x000008, "Member 'MMBlueprintFunctionLibrary_RelationScriptExecute::ScriptData' has a wrong offset!");

// Function MirMobile.MMBlueprintFunctionLibrary.SetSkeletalMeshVertex
// 0x0020 (0x0020 - 0x0000)
struct MMBlueprintFunctionLibrary_SetSkeletalMeshVertex final
{
public:
	class UObject*                                WorldContextObject;                                // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class USkinnedMeshComponent*                  PSourceMesh;                                       // 0x0008(0x0008)(Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class USkinnedMeshComponent*                  PNewMesh;                                          // 0x0010(0x0008)(Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          ReturnValue;                                       // 0x0018(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_19[0x7];                                       // 0x0019(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(MMBlueprintFunctionLibrary_SetSkeletalMeshVertex) == 0x000008, "Wrong alignment on MMBlueprintFunctionLibrary_SetSkeletalMeshVertex");
static_assert(sizeof(MMBlueprintFunctionLibrary_SetSkeletalMeshVertex) == 0x000020, "Wrong size on MMBlueprintFunctionLibrary_SetSkeletalMeshVertex");
static_assert(offsetof(MMBlueprintFunctionLibrary_SetSkeletalMeshVertex, WorldContextObject) == 0x000000, "Member 'MMBlueprintFunctionLibrary_SetSkeletalMeshVertex::WorldContextObject' has a wrong offset!");
static_assert(offsetof(MMBlueprintFunctionLibrary_SetSkeletalMeshVertex, PSourceMesh) == 0x000008, "Member 'MMBlueprintFunctionLibrary_SetSkeletalMeshVertex::PSourceMesh' has a wrong offset!");
static_assert(offsetof(MMBlueprintFunctionLibrary_SetSkeletalMeshVertex, PNewMesh) == 0x000010, "Member 'MMBlueprintFunctionLibrary_SetSkeletalMeshVertex::PNewMesh' has a wrong offset!");
static_assert(offsetof(MMBlueprintFunctionLibrary_SetSkeletalMeshVertex, ReturnValue) == 0x000018, "Member 'MMBlueprintFunctionLibrary_SetSkeletalMeshVertex::ReturnValue' has a wrong offset!");

// Function MirMobile.MMBlueprintFunctionLibrary.SetTextureBrush
// 0x0010 (0x0010 - 0x0000)
struct MMBlueprintFunctionLibrary_SetTextureBrush final
{
public:
	class UObject*                                PSprite;                                           // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UImage*                                 PImage;                                            // 0x0008(0x0008)(Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(MMBlueprintFunctionLibrary_SetTextureBrush) == 0x000008, "Wrong alignment on MMBlueprintFunctionLibrary_SetTextureBrush");
static_assert(sizeof(MMBlueprintFunctionLibrary_SetTextureBrush) == 0x000010, "Wrong size on MMBlueprintFunctionLibrary_SetTextureBrush");
static_assert(offsetof(MMBlueprintFunctionLibrary_SetTextureBrush, PSprite) == 0x000000, "Member 'MMBlueprintFunctionLibrary_SetTextureBrush::PSprite' has a wrong offset!");
static_assert(offsetof(MMBlueprintFunctionLibrary_SetTextureBrush, PImage) == 0x000008, "Member 'MMBlueprintFunctionLibrary_SetTextureBrush::PImage' has a wrong offset!");

// Function MirMobile.MMBlueprintFunctionLibrary.SoundVolumeChange
// 0x0010 (0x0010 - 0x0000)
struct MMBlueprintFunctionLibrary_SoundVolumeChange final
{
public:
	class USoundClass*                            SoundClassObject;                                  // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         NewVolume;                                         // 0x0008(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          ReturnValue;                                       // 0x000C(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_D[0x3];                                        // 0x000D(0x0003)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(MMBlueprintFunctionLibrary_SoundVolumeChange) == 0x000008, "Wrong alignment on MMBlueprintFunctionLibrary_SoundVolumeChange");
static_assert(sizeof(MMBlueprintFunctionLibrary_SoundVolumeChange) == 0x000010, "Wrong size on MMBlueprintFunctionLibrary_SoundVolumeChange");
static_assert(offsetof(MMBlueprintFunctionLibrary_SoundVolumeChange, SoundClassObject) == 0x000000, "Member 'MMBlueprintFunctionLibrary_SoundVolumeChange::SoundClassObject' has a wrong offset!");
static_assert(offsetof(MMBlueprintFunctionLibrary_SoundVolumeChange, NewVolume) == 0x000008, "Member 'MMBlueprintFunctionLibrary_SoundVolumeChange::NewVolume' has a wrong offset!");
static_assert(offsetof(MMBlueprintFunctionLibrary_SoundVolumeChange, ReturnValue) == 0x00000C, "Member 'MMBlueprintFunctionLibrary_SoundVolumeChange::ReturnValue' has a wrong offset!");

// Function MirMobile.MMBlueprintFunctionLibrary.SpawnActorByString
// 0x0040 (0x0040 - 0x0000)
struct MMBlueprintFunctionLibrary_SpawnActorByString final
{
public:
	class UObject*                                WorldContextObject;                                // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 ReferenceName;                                     // 0x0008(0x0010)(Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                VLoc;                                              // 0x0018(0x000C)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FRotator                               RRot;                                              // 0x0024(0x000C)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	ELOAD_RESULT                                  LoadType;                                          // 0x0030(0x0001)(Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_31[0x7];                                       // 0x0031(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	class AActor*                                 ReturnValue;                                       // 0x0038(0x0008)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(MMBlueprintFunctionLibrary_SpawnActorByString) == 0x000008, "Wrong alignment on MMBlueprintFunctionLibrary_SpawnActorByString");
static_assert(sizeof(MMBlueprintFunctionLibrary_SpawnActorByString) == 0x000040, "Wrong size on MMBlueprintFunctionLibrary_SpawnActorByString");
static_assert(offsetof(MMBlueprintFunctionLibrary_SpawnActorByString, WorldContextObject) == 0x000000, "Member 'MMBlueprintFunctionLibrary_SpawnActorByString::WorldContextObject' has a wrong offset!");
static_assert(offsetof(MMBlueprintFunctionLibrary_SpawnActorByString, ReferenceName) == 0x000008, "Member 'MMBlueprintFunctionLibrary_SpawnActorByString::ReferenceName' has a wrong offset!");
static_assert(offsetof(MMBlueprintFunctionLibrary_SpawnActorByString, VLoc) == 0x000018, "Member 'MMBlueprintFunctionLibrary_SpawnActorByString::VLoc' has a wrong offset!");
static_assert(offsetof(MMBlueprintFunctionLibrary_SpawnActorByString, RRot) == 0x000024, "Member 'MMBlueprintFunctionLibrary_SpawnActorByString::RRot' has a wrong offset!");
static_assert(offsetof(MMBlueprintFunctionLibrary_SpawnActorByString, LoadType) == 0x000030, "Member 'MMBlueprintFunctionLibrary_SpawnActorByString::LoadType' has a wrong offset!");
static_assert(offsetof(MMBlueprintFunctionLibrary_SpawnActorByString, ReturnValue) == 0x000038, "Member 'MMBlueprintFunctionLibrary_SpawnActorByString::ReturnValue' has a wrong offset!");

// Function MirMobile.MMBlueprintFunctionLibrary.ToggleAllWidget
// 0x0001 (0x0001 - 0x0000)
struct MMBlueprintFunctionLibrary_ToggleAllWidget final
{
public:
	bool                                          bShow;                                             // 0x0000(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(MMBlueprintFunctionLibrary_ToggleAllWidget) == 0x000001, "Wrong alignment on MMBlueprintFunctionLibrary_ToggleAllWidget");
static_assert(sizeof(MMBlueprintFunctionLibrary_ToggleAllWidget) == 0x000001, "Wrong size on MMBlueprintFunctionLibrary_ToggleAllWidget");
static_assert(offsetof(MMBlueprintFunctionLibrary_ToggleAllWidget, bShow) == 0x000000, "Member 'MMBlueprintFunctionLibrary_ToggleAllWidget::bShow' has a wrong offset!");

// Function MirMobile.MMBlueprintFunctionLibrary.UnloadStreamLevel
// 0x0028 (0x0028 - 0x0000)
struct MMBlueprintFunctionLibrary_UnloadStreamLevel final
{
public:
	class ULevelStreaming*                        PStremingLevel;                                    // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   LevelName;                                         // 0x0008(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FLatentActionInfo                      LatentInfo;                                        // 0x0010(0x0018)(Parm, NoDestructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(MMBlueprintFunctionLibrary_UnloadStreamLevel) == 0x000008, "Wrong alignment on MMBlueprintFunctionLibrary_UnloadStreamLevel");
static_assert(sizeof(MMBlueprintFunctionLibrary_UnloadStreamLevel) == 0x000028, "Wrong size on MMBlueprintFunctionLibrary_UnloadStreamLevel");
static_assert(offsetof(MMBlueprintFunctionLibrary_UnloadStreamLevel, PStremingLevel) == 0x000000, "Member 'MMBlueprintFunctionLibrary_UnloadStreamLevel::PStremingLevel' has a wrong offset!");
static_assert(offsetof(MMBlueprintFunctionLibrary_UnloadStreamLevel, LevelName) == 0x000008, "Member 'MMBlueprintFunctionLibrary_UnloadStreamLevel::LevelName' has a wrong offset!");
static_assert(offsetof(MMBlueprintFunctionLibrary_UnloadStreamLevel, LatentInfo) == 0x000010, "Member 'MMBlueprintFunctionLibrary_UnloadStreamLevel::LatentInfo' has a wrong offset!");

// Function MirMobile.MMBlueprintFunctionLibrary.ViewprotFade
// 0x000C (0x000C - 0x0000)
struct MMBlueprintFunctionLibrary_ViewprotFade final
{
public:
	float                                         Opacity;                                           // 0x0000(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         Duration;                                          // 0x0004(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         FirstDelay;                                        // 0x0008(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(MMBlueprintFunctionLibrary_ViewprotFade) == 0x000004, "Wrong alignment on MMBlueprintFunctionLibrary_ViewprotFade");
static_assert(sizeof(MMBlueprintFunctionLibrary_ViewprotFade) == 0x00000C, "Wrong size on MMBlueprintFunctionLibrary_ViewprotFade");
static_assert(offsetof(MMBlueprintFunctionLibrary_ViewprotFade, Opacity) == 0x000000, "Member 'MMBlueprintFunctionLibrary_ViewprotFade::Opacity' has a wrong offset!");
static_assert(offsetof(MMBlueprintFunctionLibrary_ViewprotFade, Duration) == 0x000004, "Member 'MMBlueprintFunctionLibrary_ViewprotFade::Duration' has a wrong offset!");
static_assert(offsetof(MMBlueprintFunctionLibrary_ViewprotFade, FirstDelay) == 0x000008, "Member 'MMBlueprintFunctionLibrary_ViewprotFade::FirstDelay' has a wrong offset!");

// Function MirMobile.MMBlueprintFunctionLibrary.ViewprotFadeInOut
// 0x0008 (0x0008 - 0x0000)
struct MMBlueprintFunctionLibrary_ViewprotFadeInOut final
{
public:
	float                                         Opacity;                                           // 0x0000(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         Duration;                                          // 0x0004(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(MMBlueprintFunctionLibrary_ViewprotFadeInOut) == 0x000004, "Wrong alignment on MMBlueprintFunctionLibrary_ViewprotFadeInOut");
static_assert(sizeof(MMBlueprintFunctionLibrary_ViewprotFadeInOut) == 0x000008, "Wrong size on MMBlueprintFunctionLibrary_ViewprotFadeInOut");
static_assert(offsetof(MMBlueprintFunctionLibrary_ViewprotFadeInOut, Opacity) == 0x000000, "Member 'MMBlueprintFunctionLibrary_ViewprotFadeInOut::Opacity' has a wrong offset!");
static_assert(offsetof(MMBlueprintFunctionLibrary_ViewprotFadeInOut, Duration) == 0x000004, "Member 'MMBlueprintFunctionLibrary_ViewprotFadeInOut::Duration' has a wrong offset!");

// Function MirMobile.MMBlueprintFunctionLibrary.WITH_EDITOR_BP
// 0x0001 (0x0001 - 0x0000)
struct MMBlueprintFunctionLibrary_WITH_EDITOR_BP final
{
public:
	bool                                          ReturnValue;                                       // 0x0000(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(MMBlueprintFunctionLibrary_WITH_EDITOR_BP) == 0x000001, "Wrong alignment on MMBlueprintFunctionLibrary_WITH_EDITOR_BP");
static_assert(sizeof(MMBlueprintFunctionLibrary_WITH_EDITOR_BP) == 0x000001, "Wrong size on MMBlueprintFunctionLibrary_WITH_EDITOR_BP");
static_assert(offsetof(MMBlueprintFunctionLibrary_WITH_EDITOR_BP, ReturnValue) == 0x000000, "Member 'MMBlueprintFunctionLibrary_WITH_EDITOR_BP::ReturnValue' has a wrong offset!");

// Function MirMobile.MMBlueprintFunctionLibrary.WorldType_InEditor
// 0x0010 (0x0010 - 0x0000)
struct MMBlueprintFunctionLibrary_WorldType_InEditor final
{
public:
	class UObject*                                WorldContextObject;                                // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          ReturnValue;                                       // 0x0008(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_9[0x7];                                        // 0x0009(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(MMBlueprintFunctionLibrary_WorldType_InEditor) == 0x000008, "Wrong alignment on MMBlueprintFunctionLibrary_WorldType_InEditor");
static_assert(sizeof(MMBlueprintFunctionLibrary_WorldType_InEditor) == 0x000010, "Wrong size on MMBlueprintFunctionLibrary_WorldType_InEditor");
static_assert(offsetof(MMBlueprintFunctionLibrary_WorldType_InEditor, WorldContextObject) == 0x000000, "Member 'MMBlueprintFunctionLibrary_WorldType_InEditor::WorldContextObject' has a wrong offset!");
static_assert(offsetof(MMBlueprintFunctionLibrary_WorldType_InEditor, ReturnValue) == 0x000008, "Member 'MMBlueprintFunctionLibrary_WorldType_InEditor::ReturnValue' has a wrong offset!");

// Function MirMobile.MMRichTextBox.SetFont
// 0x0050 (0x0050 - 0x0000)
struct MMRichTextBox_SetFont final
{
public:
	struct FSlateFontInfo                         InFontInfo;                                        // 0x0000(0x0050)(Parm, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(MMRichTextBox_SetFont) == 0x000008, "Wrong alignment on MMRichTextBox_SetFont");
static_assert(sizeof(MMRichTextBox_SetFont) == 0x000050, "Wrong size on MMRichTextBox_SetFont");
static_assert(offsetof(MMRichTextBox_SetFont, InFontInfo) == 0x000000, "Member 'MMRichTextBox_SetFont::InFontInfo' has a wrong offset!");

// Function MirMobile.MMRichTextBox.SetRichTextColor
// 0x0010 (0x0010 - 0x0000)
struct MMRichTextBox_SetRichTextColor final
{
public:
	struct FLinearColor                           InColorAndOpacity;                                 // 0x0000(0x0010)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(MMRichTextBox_SetRichTextColor) == 0x000004, "Wrong alignment on MMRichTextBox_SetRichTextColor");
static_assert(sizeof(MMRichTextBox_SetRichTextColor) == 0x000010, "Wrong size on MMRichTextBox_SetRichTextColor");
static_assert(offsetof(MMRichTextBox_SetRichTextColor, InColorAndOpacity) == 0x000000, "Member 'MMRichTextBox_SetRichTextColor::InColorAndOpacity' has a wrong offset!");

// Function MirMobile.MMRichTextBox.SetText
// 0x0018 (0x0018 - 0x0000)
struct MMRichTextBox_SetText final
{
public:
	class FText                                   InText;                                            // 0x0000(0x0018)(Parm, NativeAccessSpecifierPublic)
};
static_assert(alignof(MMRichTextBox_SetText) == 0x000008, "Wrong alignment on MMRichTextBox_SetText");
static_assert(sizeof(MMRichTextBox_SetText) == 0x000018, "Wrong size on MMRichTextBox_SetText");
static_assert(offsetof(MMRichTextBox_SetText, InText) == 0x000000, "Member 'MMRichTextBox_SetText::InText' has a wrong offset!");

// Function MirMobile.MMRichTextBox.GetText
// 0x0018 (0x0018 - 0x0000)
struct MMRichTextBox_GetText final
{
public:
	class FText                                   ReturnValue;                                       // 0x0000(0x0018)(Parm, OutParm, ReturnParm, NativeAccessSpecifierPublic)
};
static_assert(alignof(MMRichTextBox_GetText) == 0x000008, "Wrong alignment on MMRichTextBox_GetText");
static_assert(sizeof(MMRichTextBox_GetText) == 0x000018, "Wrong size on MMRichTextBox_GetText");
static_assert(offsetof(MMRichTextBox_GetText, ReturnValue) == 0x000000, "Member 'MMRichTextBox_GetText::ReturnValue' has a wrong offset!");

// Function MirMobile.MyNpcSpawner.SetPreviewData
// 0x0028 (0x0028 - 0x0000)
struct MyNpcSpawner_SetPreviewData final
{
public:
	class FString                                 NameTitle;                                         // 0x0000(0x0010)(Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 NpcName;                                           // 0x0010(0x0010)(Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         InteractionRange;                                  // 0x0020(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         SightRange;                                        // 0x0024(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(MyNpcSpawner_SetPreviewData) == 0x000008, "Wrong alignment on MyNpcSpawner_SetPreviewData");
static_assert(sizeof(MyNpcSpawner_SetPreviewData) == 0x000028, "Wrong size on MyNpcSpawner_SetPreviewData");
static_assert(offsetof(MyNpcSpawner_SetPreviewData, NameTitle) == 0x000000, "Member 'MyNpcSpawner_SetPreviewData::NameTitle' has a wrong offset!");
static_assert(offsetof(MyNpcSpawner_SetPreviewData, NpcName) == 0x000010, "Member 'MyNpcSpawner_SetPreviewData::NpcName' has a wrong offset!");
static_assert(offsetof(MyNpcSpawner_SetPreviewData, InteractionRange) == 0x000020, "Member 'MyNpcSpawner_SetPreviewData::InteractionRange' has a wrong offset!");
static_assert(offsetof(MyNpcSpawner_SetPreviewData, SightRange) == 0x000024, "Member 'MyNpcSpawner_SetPreviewData::SightRange' has a wrong offset!");

// Function MirMobile.MyPortalTrigger.IsOverlapPortal
// 0x0001 (0x0001 - 0x0000)
struct MyPortalTrigger_IsOverlapPortal final
{
public:
	bool                                          ReturnValue;                                       // 0x0000(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(MyPortalTrigger_IsOverlapPortal) == 0x000001, "Wrong alignment on MyPortalTrigger_IsOverlapPortal");
static_assert(sizeof(MyPortalTrigger_IsOverlapPortal) == 0x000001, "Wrong size on MyPortalTrigger_IsOverlapPortal");
static_assert(offsetof(MyPortalTrigger_IsOverlapPortal, ReturnValue) == 0x000000, "Member 'MyPortalTrigger_IsOverlapPortal::ReturnValue' has a wrong offset!");

// Function MirMobile.MyPortalTrigger.NextStageNameEvent
// 0x0010 (0x0010 - 0x0000)
struct MyPortalTrigger_NextStageNameEvent final
{
public:
	class FString                                 StrNextStage;                                      // 0x0000(0x0010)(Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(MyPortalTrigger_NextStageNameEvent) == 0x000008, "Wrong alignment on MyPortalTrigger_NextStageNameEvent");
static_assert(sizeof(MyPortalTrigger_NextStageNameEvent) == 0x000010, "Wrong size on MyPortalTrigger_NextStageNameEvent");
static_assert(offsetof(MyPortalTrigger_NextStageNameEvent, StrNextStage) == 0x000000, "Member 'MyPortalTrigger_NextStageNameEvent::StrNextStage' has a wrong offset!");

// Function MirMobile.MyPortalTrigger.OpenPortalEvent
// 0x0002 (0x0002 - 0x0000)
struct MyPortalTrigger_OpenPortalEvent final
{
public:
	bool                                          bOpen;                                             // 0x0000(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bInit;                                             // 0x0001(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(MyPortalTrigger_OpenPortalEvent) == 0x000001, "Wrong alignment on MyPortalTrigger_OpenPortalEvent");
static_assert(sizeof(MyPortalTrigger_OpenPortalEvent) == 0x000002, "Wrong size on MyPortalTrigger_OpenPortalEvent");
static_assert(offsetof(MyPortalTrigger_OpenPortalEvent, bOpen) == 0x000000, "Member 'MyPortalTrigger_OpenPortalEvent::bOpen' has a wrong offset!");
static_assert(offsetof(MyPortalTrigger_OpenPortalEvent, bInit) == 0x000001, "Member 'MyPortalTrigger_OpenPortalEvent::bInit' has a wrong offset!");

// Function MirMobile.MyPortalTrigger.SetPortalCollisionEnable
// 0x0001 (0x0001 - 0x0000)
struct MyPortalTrigger_SetPortalCollisionEnable final
{
public:
	bool                                          bVisible;                                          // 0x0000(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(MyPortalTrigger_SetPortalCollisionEnable) == 0x000001, "Wrong alignment on MyPortalTrigger_SetPortalCollisionEnable");
static_assert(sizeof(MyPortalTrigger_SetPortalCollisionEnable) == 0x000001, "Wrong size on MyPortalTrigger_SetPortalCollisionEnable");
static_assert(offsetof(MyPortalTrigger_SetPortalCollisionEnable, bVisible) == 0x000000, "Member 'MyPortalTrigger_SetPortalCollisionEnable::bVisible' has a wrong offset!");

// Function MirMobile.MyPortalTrigger.SetPortalVisible
// 0x0001 (0x0001 - 0x0000)
struct MyPortalTrigger_SetPortalVisible final
{
public:
	bool                                          bVisible;                                          // 0x0000(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(MyPortalTrigger_SetPortalVisible) == 0x000001, "Wrong alignment on MyPortalTrigger_SetPortalVisible");
static_assert(sizeof(MyPortalTrigger_SetPortalVisible) == 0x000001, "Wrong size on MyPortalTrigger_SetPortalVisible");
static_assert(offsetof(MyPortalTrigger_SetPortalVisible, bVisible) == 0x000000, "Member 'MyPortalTrigger_SetPortalVisible::bVisible' has a wrong offset!");

// Function MirMobile.MyPortalTrigger.ShowPortalName
// 0x0001 (0x0001 - 0x0000)
struct MyPortalTrigger_ShowPortalName final
{
public:
	bool                                          bShow;                                             // 0x0000(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(MyPortalTrigger_ShowPortalName) == 0x000001, "Wrong alignment on MyPortalTrigger_ShowPortalName");
static_assert(sizeof(MyPortalTrigger_ShowPortalName) == 0x000001, "Wrong size on MyPortalTrigger_ShowPortalName");
static_assert(offsetof(MyPortalTrigger_ShowPortalName, bShow) == 0x000000, "Member 'MyPortalTrigger_ShowPortalName::bShow' has a wrong offset!");

// Function MirMobile.MyPortalTrigger.UpdatePortalEffectEvent
// 0x0008 (0x0008 - 0x0000)
struct MyPortalTrigger_UpdatePortalEffectEvent final
{
public:
	class UParticleSystem*                        ParticleTemplate;                                  // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(MyPortalTrigger_UpdatePortalEffectEvent) == 0x000008, "Wrong alignment on MyPortalTrigger_UpdatePortalEffectEvent");
static_assert(sizeof(MyPortalTrigger_UpdatePortalEffectEvent) == 0x000008, "Wrong size on MyPortalTrigger_UpdatePortalEffectEvent");
static_assert(offsetof(MyPortalTrigger_UpdatePortalEffectEvent, ParticleTemplate) == 0x000000, "Member 'MyPortalTrigger_UpdatePortalEffectEvent::ParticleTemplate' has a wrong offset!");

// Function MirMobile.PhaseAreaTrigger.SetAreaBoxCollision
// 0x0030 (0x0030 - 0x0000)
struct PhaseAreaTrigger_SetAreaBoxCollision final
{
public:
	TArray<struct FVector>                        BoxLocArray;                                       // 0x0000(0x0010)(ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, NativeAccessSpecifierPublic)
	TArray<struct FRotator>                       BoxRotArray;                                       // 0x0010(0x0010)(ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, NativeAccessSpecifierPublic)
	struct FVector                                BoxExtent;                                         // 0x0020(0x000C)(ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2C[0x4];                                       // 0x002C(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(PhaseAreaTrigger_SetAreaBoxCollision) == 0x000008, "Wrong alignment on PhaseAreaTrigger_SetAreaBoxCollision");
static_assert(sizeof(PhaseAreaTrigger_SetAreaBoxCollision) == 0x000030, "Wrong size on PhaseAreaTrigger_SetAreaBoxCollision");
static_assert(offsetof(PhaseAreaTrigger_SetAreaBoxCollision, BoxLocArray) == 0x000000, "Member 'PhaseAreaTrigger_SetAreaBoxCollision::BoxLocArray' has a wrong offset!");
static_assert(offsetof(PhaseAreaTrigger_SetAreaBoxCollision, BoxRotArray) == 0x000010, "Member 'PhaseAreaTrigger_SetAreaBoxCollision::BoxRotArray' has a wrong offset!");
static_assert(offsetof(PhaseAreaTrigger_SetAreaBoxCollision, BoxExtent) == 0x000020, "Member 'PhaseAreaTrigger_SetAreaBoxCollision::BoxExtent' has a wrong offset!");

// Function MirMobile.PlayerModelingActor.CopySkeletalMesh
// 0x0010 (0x0010 - 0x0000)
struct PlayerModelingActor_CopySkeletalMesh final
{
public:
	class USkinnedMeshComponent*                  PSourceMesh;                                       // 0x0000(0x0008)(Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class USkinnedMeshComponent*                  PNewMesh;                                          // 0x0008(0x0008)(Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(PlayerModelingActor_CopySkeletalMesh) == 0x000008, "Wrong alignment on PlayerModelingActor_CopySkeletalMesh");
static_assert(sizeof(PlayerModelingActor_CopySkeletalMesh) == 0x000010, "Wrong size on PlayerModelingActor_CopySkeletalMesh");
static_assert(offsetof(PlayerModelingActor_CopySkeletalMesh, PSourceMesh) == 0x000000, "Member 'PlayerModelingActor_CopySkeletalMesh::PSourceMesh' has a wrong offset!");
static_assert(offsetof(PlayerModelingActor_CopySkeletalMesh, PNewMesh) == 0x000008, "Member 'PlayerModelingActor_CopySkeletalMesh::PNewMesh' has a wrong offset!");

// Function MirMobile.Popup_Auto_ExtendTime.OnChangeCount
// 0x0008 (0x0008 - 0x0000)
struct Popup_Auto_ExtendTime_OnChangeCount final
{
public:
	int64                                         Count;                                             // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(Popup_Auto_ExtendTime_OnChangeCount) == 0x000008, "Wrong alignment on Popup_Auto_ExtendTime_OnChangeCount");
static_assert(sizeof(Popup_Auto_ExtendTime_OnChangeCount) == 0x000008, "Wrong size on Popup_Auto_ExtendTime_OnChangeCount");
static_assert(offsetof(Popup_Auto_ExtendTime_OnChangeCount, Count) == 0x000000, "Member 'Popup_Auto_ExtendTime_OnChangeCount::Count' has a wrong offset!");

// Function MirMobile.Popup_Auto_ExtendTime.OnSelectedExtenMode
// 0x0004 (0x0004 - 0x0000)
struct Popup_Auto_ExtendTime_OnSelectedExtenMode final
{
public:
	int32                                         Idx;                                               // 0x0000(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(Popup_Auto_ExtendTime_OnSelectedExtenMode) == 0x000004, "Wrong alignment on Popup_Auto_ExtendTime_OnSelectedExtenMode");
static_assert(sizeof(Popup_Auto_ExtendTime_OnSelectedExtenMode) == 0x000004, "Wrong size on Popup_Auto_ExtendTime_OnSelectedExtenMode");
static_assert(offsetof(Popup_Auto_ExtendTime_OnSelectedExtenMode, Idx) == 0x000000, "Member 'Popup_Auto_ExtendTime_OnSelectedExtenMode::Idx' has a wrong offset!");

// Function MirMobile.Popup_Auto_ExtendTime.OnSelectedUseGold
// 0x0004 (0x0004 - 0x0000)
struct Popup_Auto_ExtendTime_OnSelectedUseGold final
{
public:
	int32                                         Idx;                                               // 0x0000(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(Popup_Auto_ExtendTime_OnSelectedUseGold) == 0x000004, "Wrong alignment on Popup_Auto_ExtendTime_OnSelectedUseGold");
static_assert(sizeof(Popup_Auto_ExtendTime_OnSelectedUseGold) == 0x000004, "Wrong size on Popup_Auto_ExtendTime_OnSelectedUseGold");
static_assert(offsetof(Popup_Auto_ExtendTime_OnSelectedUseGold, Idx) == 0x000000, "Member 'Popup_Auto_ExtendTime_OnSelectedUseGold::Idx' has a wrong offset!");

// Function MirMobile.SceneCaptureGameMode.BeginTestGameMode
// 0x0004 (0x0004 - 0x0000)
struct SceneCaptureGameMode_BeginTestGameMode final
{
public:
	int32                                         ClassID;                                           // 0x0000(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(SceneCaptureGameMode_BeginTestGameMode) == 0x000004, "Wrong alignment on SceneCaptureGameMode_BeginTestGameMode");
static_assert(sizeof(SceneCaptureGameMode_BeginTestGameMode) == 0x000004, "Wrong size on SceneCaptureGameMode_BeginTestGameMode");
static_assert(offsetof(SceneCaptureGameMode_BeginTestGameMode, ClassID) == 0x000000, "Member 'SceneCaptureGameMode_BeginTestGameMode::ClassID' has a wrong offset!");

// Function MirMobile.SceneCaptureGameMode.ChangeCharacter
// 0x0004 (0x0004 - 0x0000)
struct SceneCaptureGameMode_ChangeCharacter final
{
public:
	int32                                         ClassID;                                           // 0x0000(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(SceneCaptureGameMode_ChangeCharacter) == 0x000004, "Wrong alignment on SceneCaptureGameMode_ChangeCharacter");
static_assert(sizeof(SceneCaptureGameMode_ChangeCharacter) == 0x000004, "Wrong size on SceneCaptureGameMode_ChangeCharacter");
static_assert(offsetof(SceneCaptureGameMode_ChangeCharacter, ClassID) == 0x000000, "Member 'SceneCaptureGameMode_ChangeCharacter::ClassID' has a wrong offset!");

// Function MirMobile.SceneCapturePawn.AddCameraFOVInput
// 0x0004 (0x0004 - 0x0000)
struct SceneCapturePawn_AddCameraFOVInput final
{
public:
	float                                         Val;                                               // 0x0000(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(SceneCapturePawn_AddCameraFOVInput) == 0x000004, "Wrong alignment on SceneCapturePawn_AddCameraFOVInput");
static_assert(sizeof(SceneCapturePawn_AddCameraFOVInput) == 0x000004, "Wrong size on SceneCapturePawn_AddCameraFOVInput");
static_assert(offsetof(SceneCapturePawn_AddCameraFOVInput, Val) == 0x000000, "Member 'SceneCapturePawn_AddCameraFOVInput::Val' has a wrong offset!");

// Function MirMobile.SceneCapturePawn.AddCameraPitchInput
// 0x0004 (0x0004 - 0x0000)
struct SceneCapturePawn_AddCameraPitchInput final
{
public:
	float                                         Val;                                               // 0x0000(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(SceneCapturePawn_AddCameraPitchInput) == 0x000004, "Wrong alignment on SceneCapturePawn_AddCameraPitchInput");
static_assert(sizeof(SceneCapturePawn_AddCameraPitchInput) == 0x000004, "Wrong size on SceneCapturePawn_AddCameraPitchInput");
static_assert(offsetof(SceneCapturePawn_AddCameraPitchInput, Val) == 0x000000, "Member 'SceneCapturePawn_AddCameraPitchInput::Val' has a wrong offset!");

// Function MirMobile.SceneCapturePawn.AddCameraSensitivity
// 0x0004 (0x0004 - 0x0000)
struct SceneCapturePawn_AddCameraSensitivity final
{
public:
	float                                         Val;                                               // 0x0000(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(SceneCapturePawn_AddCameraSensitivity) == 0x000004, "Wrong alignment on SceneCapturePawn_AddCameraSensitivity");
static_assert(sizeof(SceneCapturePawn_AddCameraSensitivity) == 0x000004, "Wrong size on SceneCapturePawn_AddCameraSensitivity");
static_assert(offsetof(SceneCapturePawn_AddCameraSensitivity, Val) == 0x000000, "Member 'SceneCapturePawn_AddCameraSensitivity::Val' has a wrong offset!");

// Function MirMobile.SceneCapturePawn.GetSensitivity
// 0x0004 (0x0004 - 0x0000)
struct SceneCapturePawn_GetSensitivity final
{
public:
	float                                         ReturnValue;                                       // 0x0000(0x0004)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(SceneCapturePawn_GetSensitivity) == 0x000004, "Wrong alignment on SceneCapturePawn_GetSensitivity");
static_assert(sizeof(SceneCapturePawn_GetSensitivity) == 0x000004, "Wrong size on SceneCapturePawn_GetSensitivity");
static_assert(offsetof(SceneCapturePawn_GetSensitivity, ReturnValue) == 0x000000, "Member 'SceneCapturePawn_GetSensitivity::ReturnValue' has a wrong offset!");

// Function MirMobile.SceneCapturePawn.MoveForward
// 0x0004 (0x0004 - 0x0000)
struct SceneCapturePawn_MoveForward final
{
public:
	float                                         Val;                                               // 0x0000(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(SceneCapturePawn_MoveForward) == 0x000004, "Wrong alignment on SceneCapturePawn_MoveForward");
static_assert(sizeof(SceneCapturePawn_MoveForward) == 0x000004, "Wrong size on SceneCapturePawn_MoveForward");
static_assert(offsetof(SceneCapturePawn_MoveForward, Val) == 0x000000, "Member 'SceneCapturePawn_MoveForward::Val' has a wrong offset!");

// Function MirMobile.SceneCapturePawn.MoveRight
// 0x0004 (0x0004 - 0x0000)
struct SceneCapturePawn_MoveRight final
{
public:
	float                                         Val;                                               // 0x0000(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(SceneCapturePawn_MoveRight) == 0x000004, "Wrong alignment on SceneCapturePawn_MoveRight");
static_assert(sizeof(SceneCapturePawn_MoveRight) == 0x000004, "Wrong size on SceneCapturePawn_MoveRight");
static_assert(offsetof(SceneCapturePawn_MoveRight, Val) == 0x000000, "Member 'SceneCapturePawn_MoveRight::Val' has a wrong offset!");

// Function MirMobile.SceneCapturePawn.MoveUp_World
// 0x0004 (0x0004 - 0x0000)
struct SceneCapturePawn_MoveUp_World final
{
public:
	float                                         Val;                                               // 0x0000(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(SceneCapturePawn_MoveUp_World) == 0x000004, "Wrong alignment on SceneCapturePawn_MoveUp_World");
static_assert(sizeof(SceneCapturePawn_MoveUp_World) == 0x000004, "Wrong size on SceneCapturePawn_MoveUp_World");
static_assert(offsetof(SceneCapturePawn_MoveUp_World, Val) == 0x000000, "Member 'SceneCapturePawn_MoveUp_World::Val' has a wrong offset!");

// Function MirMobile.SceneCapturePawn.GetCameraComponent
// 0x0008 (0x0008 - 0x0000)
struct SceneCapturePawn_GetCameraComponent final
{
public:
	class UCameraComponent*                       ReturnValue;                                       // 0x0000(0x0008)(ExportObject, Parm, OutParm, ZeroConstructor, ReturnParm, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(SceneCapturePawn_GetCameraComponent) == 0x000008, "Wrong alignment on SceneCapturePawn_GetCameraComponent");
static_assert(sizeof(SceneCapturePawn_GetCameraComponent) == 0x000008, "Wrong size on SceneCapturePawn_GetCameraComponent");
static_assert(offsetof(SceneCapturePawn_GetCameraComponent, ReturnValue) == 0x000000, "Member 'SceneCapturePawn_GetCameraComponent::ReturnValue' has a wrong offset!");

// Function MirMobile.SceneCapturePawn.GetCollisionComponent
// 0x0008 (0x0008 - 0x0000)
struct SceneCapturePawn_GetCollisionComponent final
{
public:
	class USphereComponent*                       ReturnValue;                                       // 0x0000(0x0008)(ExportObject, Parm, OutParm, ZeroConstructor, ReturnParm, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(SceneCapturePawn_GetCollisionComponent) == 0x000008, "Wrong alignment on SceneCapturePawn_GetCollisionComponent");
static_assert(sizeof(SceneCapturePawn_GetCollisionComponent) == 0x000008, "Wrong size on SceneCapturePawn_GetCollisionComponent");
static_assert(offsetof(SceneCapturePawn_GetCollisionComponent, ReturnValue) == 0x000000, "Member 'SceneCapturePawn_GetCollisionComponent::ReturnValue' has a wrong offset!");

// Function MirMobile.SceneCapturePawn.GetMeshComponent
// 0x0008 (0x0008 - 0x0000)
struct SceneCapturePawn_GetMeshComponent final
{
public:
	class UStaticMeshComponent*                   ReturnValue;                                       // 0x0000(0x0008)(ExportObject, Parm, OutParm, ZeroConstructor, ReturnParm, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(SceneCapturePawn_GetMeshComponent) == 0x000008, "Wrong alignment on SceneCapturePawn_GetMeshComponent");
static_assert(sizeof(SceneCapturePawn_GetMeshComponent) == 0x000008, "Wrong size on SceneCapturePawn_GetMeshComponent");
static_assert(offsetof(SceneCapturePawn_GetMeshComponent, ReturnValue) == 0x000000, "Member 'SceneCapturePawn_GetMeshComponent::ReturnValue' has a wrong offset!");

// Function MirMobile.ScriptSubtitleWidget.SetSubtitleType
// 0x0001 (0x0001 - 0x0000)
struct ScriptSubtitleWidget_SetSubtitleType final
{
public:
	EDialoguePostion                              SubtitleType;                                      // 0x0000(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(ScriptSubtitleWidget_SetSubtitleType) == 0x000001, "Wrong alignment on ScriptSubtitleWidget_SetSubtitleType");
static_assert(sizeof(ScriptSubtitleWidget_SetSubtitleType) == 0x000001, "Wrong size on ScriptSubtitleWidget_SetSubtitleType");
static_assert(offsetof(ScriptSubtitleWidget_SetSubtitleType, SubtitleType) == 0x000000, "Member 'ScriptSubtitleWidget_SetSubtitleType::SubtitleType' has a wrong offset!");

// Function MirMobile.SpectatorCamera.MoveForward
// 0x0004 (0x0004 - 0x0000)
struct SpectatorCamera_MoveForward final
{
public:
	float                                         AxisValue;                                         // 0x0000(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(SpectatorCamera_MoveForward) == 0x000004, "Wrong alignment on SpectatorCamera_MoveForward");
static_assert(sizeof(SpectatorCamera_MoveForward) == 0x000004, "Wrong size on SpectatorCamera_MoveForward");
static_assert(offsetof(SpectatorCamera_MoveForward, AxisValue) == 0x000000, "Member 'SpectatorCamera_MoveForward::AxisValue' has a wrong offset!");

// Function MirMobile.SpectatorCamera.MoveRight
// 0x0004 (0x0004 - 0x0000)
struct SpectatorCamera_MoveRight final
{
public:
	float                                         AxisValue;                                         // 0x0000(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(SpectatorCamera_MoveRight) == 0x000004, "Wrong alignment on SpectatorCamera_MoveRight");
static_assert(sizeof(SpectatorCamera_MoveRight) == 0x000004, "Wrong size on SpectatorCamera_MoveRight");
static_assert(offsetof(SpectatorCamera_MoveRight, AxisValue) == 0x000000, "Member 'SpectatorCamera_MoveRight::AxisValue' has a wrong offset!");

// Function MirMobile.SpectatorCamera.MoveUp
// 0x0004 (0x0004 - 0x0000)
struct SpectatorCamera_MoveUp final
{
public:
	float                                         AxisValue;                                         // 0x0000(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(SpectatorCamera_MoveUp) == 0x000004, "Wrong alignment on SpectatorCamera_MoveUp");
static_assert(sizeof(SpectatorCamera_MoveUp) == 0x000004, "Wrong size on SpectatorCamera_MoveUp");
static_assert(offsetof(SpectatorCamera_MoveUp, AxisValue) == 0x000000, "Member 'SpectatorCamera_MoveUp::AxisValue' has a wrong offset!");

// Function MirMobile.SpectatorCamera.PitchCamera
// 0x0004 (0x0004 - 0x0000)
struct SpectatorCamera_PitchCamera final
{
public:
	float                                         AxisValue;                                         // 0x0000(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(SpectatorCamera_PitchCamera) == 0x000004, "Wrong alignment on SpectatorCamera_PitchCamera");
static_assert(sizeof(SpectatorCamera_PitchCamera) == 0x000004, "Wrong size on SpectatorCamera_PitchCamera");
static_assert(offsetof(SpectatorCamera_PitchCamera, AxisValue) == 0x000000, "Member 'SpectatorCamera_PitchCamera::AxisValue' has a wrong offset!");

// Function MirMobile.SpectatorCamera.SetCameraTarget
// 0x0008 (0x0008 - 0x0000)
struct SpectatorCamera_SetCameraTarget final
{
public:
	class AActor*                                 PTargetActor;                                      // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(SpectatorCamera_SetCameraTarget) == 0x000008, "Wrong alignment on SpectatorCamera_SetCameraTarget");
static_assert(sizeof(SpectatorCamera_SetCameraTarget) == 0x000008, "Wrong size on SpectatorCamera_SetCameraTarget");
static_assert(offsetof(SpectatorCamera_SetCameraTarget, PTargetActor) == 0x000000, "Member 'SpectatorCamera_SetCameraTarget::PTargetActor' has a wrong offset!");

// Function MirMobile.SpectatorCamera.SetPresetData
// 0x0004 (0x0004 - 0x0000)
struct SpectatorCamera_SetPresetData final
{
public:
	int32                                         PresetIndex;                                       // 0x0000(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(SpectatorCamera_SetPresetData) == 0x000004, "Wrong alignment on SpectatorCamera_SetPresetData");
static_assert(sizeof(SpectatorCamera_SetPresetData) == 0x000004, "Wrong size on SpectatorCamera_SetPresetData");
static_assert(offsetof(SpectatorCamera_SetPresetData, PresetIndex) == 0x000000, "Member 'SpectatorCamera_SetPresetData::PresetIndex' has a wrong offset!");

// Function MirMobile.SpectatorCamera.YawCamera
// 0x0004 (0x0004 - 0x0000)
struct SpectatorCamera_YawCamera final
{
public:
	float                                         AxisValue;                                         // 0x0000(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(SpectatorCamera_YawCamera) == 0x000004, "Wrong alignment on SpectatorCamera_YawCamera");
static_assert(sizeof(SpectatorCamera_YawCamera) == 0x000004, "Wrong size on SpectatorCamera_YawCamera");
static_assert(offsetof(SpectatorCamera_YawCamera, AxisValue) == 0x000000, "Member 'SpectatorCamera_YawCamera::AxisValue' has a wrong offset!");

// Function MirMobile.SpeechBalloonWidget.SetTextColorEvent
// 0x0010 (0x0010 - 0x0000)
struct SpeechBalloonWidget_SetTextColorEvent final
{
public:
	struct FLinearColor                           DialogueTextColor;                                 // 0x0000(0x0010)(ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(SpeechBalloonWidget_SetTextColorEvent) == 0x000004, "Wrong alignment on SpeechBalloonWidget_SetTextColorEvent");
static_assert(sizeof(SpeechBalloonWidget_SetTextColorEvent) == 0x000010, "Wrong size on SpeechBalloonWidget_SetTextColorEvent");
static_assert(offsetof(SpeechBalloonWidget_SetTextColorEvent, DialogueTextColor) == 0x000000, "Member 'SpeechBalloonWidget_SetTextColorEvent::DialogueTextColor' has a wrong offset!");

// Function MirMobile.SpeechBalloonWidget.SetTextEvent
// 0x0018 (0x0018 - 0x0000)
struct SpeechBalloonWidget_SetTextEvent final
{
public:
	class FText                                   DialogueText;                                      // 0x0000(0x0018)(ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
};
static_assert(alignof(SpeechBalloonWidget_SetTextEvent) == 0x000008, "Wrong alignment on SpeechBalloonWidget_SetTextEvent");
static_assert(sizeof(SpeechBalloonWidget_SetTextEvent) == 0x000018, "Wrong size on SpeechBalloonWidget_SetTextEvent");
static_assert(offsetof(SpeechBalloonWidget_SetTextEvent, DialogueText) == 0x000000, "Member 'SpeechBalloonWidget_SetTextEvent::DialogueText' has a wrong offset!");

// Function MirMobile.TownAlarmTrigger.ActivateTrigger
// 0x0004 (0x0004 - 0x0000)
struct TownAlarmTrigger_ActivateTrigger final
{
public:
	int32                                         AreaId;                                            // 0x0000(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(TownAlarmTrigger_ActivateTrigger) == 0x000004, "Wrong alignment on TownAlarmTrigger_ActivateTrigger");
static_assert(sizeof(TownAlarmTrigger_ActivateTrigger) == 0x000004, "Wrong size on TownAlarmTrigger_ActivateTrigger");
static_assert(offsetof(TownAlarmTrigger_ActivateTrigger, AreaId) == 0x000000, "Member 'TownAlarmTrigger_ActivateTrigger::AreaId' has a wrong offset!");

// Function MirMobile.TownAlarmTrigger.SetEnableCollision
// 0x0001 (0x0001 - 0x0000)
struct TownAlarmTrigger_SetEnableCollision final
{
public:
	bool                                          IsEnable;                                          // 0x0000(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(TownAlarmTrigger_SetEnableCollision) == 0x000001, "Wrong alignment on TownAlarmTrigger_SetEnableCollision");
static_assert(sizeof(TownAlarmTrigger_SetEnableCollision) == 0x000001, "Wrong size on TownAlarmTrigger_SetEnableCollision");
static_assert(offsetof(TownAlarmTrigger_SetEnableCollision, IsEnable) == 0x000000, "Member 'TownAlarmTrigger_SetEnableCollision::IsEnable' has a wrong offset!");

// Function MirMobile.TranslucentStaticMeshActor.OnActorBeginOverlap
// 0x00A8 (0x00A8 - 0x0000)
struct TranslucentStaticMeshActor_OnActorBeginOverlap final
{
public:
	class UPrimitiveComponent*                    OverlappedComponent;                               // 0x0000(0x0008)(Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class AActor*                                 POtherActor;                                       // 0x0008(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UPrimitiveComponent*                    OtherComponent;                                    // 0x0010(0x0008)(Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         OtherBodyIndex;                                    // 0x0018(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bFromSweep;                                        // 0x001C(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1D[0x3];                                       // 0x001D(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	struct FHitResult                             SweepResult;                                       // 0x0020(0x0088)(ConstParm, Parm, OutParm, ReferenceParm, IsPlainOldData, NoDestructor, ContainsInstancedReference, NativeAccessSpecifierPublic)
};
static_assert(alignof(TranslucentStaticMeshActor_OnActorBeginOverlap) == 0x000008, "Wrong alignment on TranslucentStaticMeshActor_OnActorBeginOverlap");
static_assert(sizeof(TranslucentStaticMeshActor_OnActorBeginOverlap) == 0x0000A8, "Wrong size on TranslucentStaticMeshActor_OnActorBeginOverlap");
static_assert(offsetof(TranslucentStaticMeshActor_OnActorBeginOverlap, OverlappedComponent) == 0x000000, "Member 'TranslucentStaticMeshActor_OnActorBeginOverlap::OverlappedComponent' has a wrong offset!");
static_assert(offsetof(TranslucentStaticMeshActor_OnActorBeginOverlap, POtherActor) == 0x000008, "Member 'TranslucentStaticMeshActor_OnActorBeginOverlap::POtherActor' has a wrong offset!");
static_assert(offsetof(TranslucentStaticMeshActor_OnActorBeginOverlap, OtherComponent) == 0x000010, "Member 'TranslucentStaticMeshActor_OnActorBeginOverlap::OtherComponent' has a wrong offset!");
static_assert(offsetof(TranslucentStaticMeshActor_OnActorBeginOverlap, OtherBodyIndex) == 0x000018, "Member 'TranslucentStaticMeshActor_OnActorBeginOverlap::OtherBodyIndex' has a wrong offset!");
static_assert(offsetof(TranslucentStaticMeshActor_OnActorBeginOverlap, bFromSweep) == 0x00001C, "Member 'TranslucentStaticMeshActor_OnActorBeginOverlap::bFromSweep' has a wrong offset!");
static_assert(offsetof(TranslucentStaticMeshActor_OnActorBeginOverlap, SweepResult) == 0x000020, "Member 'TranslucentStaticMeshActor_OnActorBeginOverlap::SweepResult' has a wrong offset!");

// Function MirMobile.TranslucentStaticMeshActor.OnActorEndOverlap
// 0x0020 (0x0020 - 0x0000)
struct TranslucentStaticMeshActor_OnActorEndOverlap final
{
public:
	class UPrimitiveComponent*                    OverlappedComponent;                               // 0x0000(0x0008)(Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class AActor*                                 POtherActor;                                       // 0x0008(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UPrimitiveComponent*                    OtherComponent;                                    // 0x0010(0x0008)(Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         OtherBodyIndex;                                    // 0x0018(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1C[0x4];                                       // 0x001C(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(TranslucentStaticMeshActor_OnActorEndOverlap) == 0x000008, "Wrong alignment on TranslucentStaticMeshActor_OnActorEndOverlap");
static_assert(sizeof(TranslucentStaticMeshActor_OnActorEndOverlap) == 0x000020, "Wrong size on TranslucentStaticMeshActor_OnActorEndOverlap");
static_assert(offsetof(TranslucentStaticMeshActor_OnActorEndOverlap, OverlappedComponent) == 0x000000, "Member 'TranslucentStaticMeshActor_OnActorEndOverlap::OverlappedComponent' has a wrong offset!");
static_assert(offsetof(TranslucentStaticMeshActor_OnActorEndOverlap, POtherActor) == 0x000008, "Member 'TranslucentStaticMeshActor_OnActorEndOverlap::POtherActor' has a wrong offset!");
static_assert(offsetof(TranslucentStaticMeshActor_OnActorEndOverlap, OtherComponent) == 0x000010, "Member 'TranslucentStaticMeshActor_OnActorEndOverlap::OtherComponent' has a wrong offset!");
static_assert(offsetof(TranslucentStaticMeshActor_OnActorEndOverlap, OtherBodyIndex) == 0x000018, "Member 'TranslucentStaticMeshActor_OnActorEndOverlap::OtherBodyIndex' has a wrong offset!");

// Function MirMobile.TranslucentStaticMeshActor.OnActorHiting
// 0x00B0 (0x00B0 - 0x0000)
struct TranslucentStaticMeshActor_OnActorHiting final
{
public:
	class UPrimitiveComponent*                    HitComponent;                                      // 0x0000(0x0008)(Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class AActor*                                 OtherActor;                                        // 0x0008(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UPrimitiveComponent*                    OtherComp;                                         // 0x0010(0x0008)(Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                NormalImpulse;                                     // 0x0018(0x000C)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FHitResult                             Hit;                                               // 0x0024(0x0088)(ConstParm, Parm, OutParm, ReferenceParm, IsPlainOldData, NoDestructor, ContainsInstancedReference, NativeAccessSpecifierPublic)
	uint8                                         Pad_AC[0x4];                                       // 0x00AC(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(TranslucentStaticMeshActor_OnActorHiting) == 0x000008, "Wrong alignment on TranslucentStaticMeshActor_OnActorHiting");
static_assert(sizeof(TranslucentStaticMeshActor_OnActorHiting) == 0x0000B0, "Wrong size on TranslucentStaticMeshActor_OnActorHiting");
static_assert(offsetof(TranslucentStaticMeshActor_OnActorHiting, HitComponent) == 0x000000, "Member 'TranslucentStaticMeshActor_OnActorHiting::HitComponent' has a wrong offset!");
static_assert(offsetof(TranslucentStaticMeshActor_OnActorHiting, OtherActor) == 0x000008, "Member 'TranslucentStaticMeshActor_OnActorHiting::OtherActor' has a wrong offset!");
static_assert(offsetof(TranslucentStaticMeshActor_OnActorHiting, OtherComp) == 0x000010, "Member 'TranslucentStaticMeshActor_OnActorHiting::OtherComp' has a wrong offset!");
static_assert(offsetof(TranslucentStaticMeshActor_OnActorHiting, NormalImpulse) == 0x000018, "Member 'TranslucentStaticMeshActor_OnActorHiting::NormalImpulse' has a wrong offset!");
static_assert(offsetof(TranslucentStaticMeshActor_OnActorHiting, Hit) == 0x000024, "Member 'TranslucentStaticMeshActor_OnActorHiting::Hit' has a wrong offset!");

// Function MirMobile.TutorialGuidWidget.SetFingerEffectSizeEvent
// 0x0008 (0x0008 - 0x0000)
struct TutorialGuidWidget_SetFingerEffectSizeEvent final
{
public:
	struct FVector2D                              FingerSize;                                        // 0x0000(0x0008)(ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(TutorialGuidWidget_SetFingerEffectSizeEvent) == 0x000004, "Wrong alignment on TutorialGuidWidget_SetFingerEffectSizeEvent");
static_assert(sizeof(TutorialGuidWidget_SetFingerEffectSizeEvent) == 0x000008, "Wrong size on TutorialGuidWidget_SetFingerEffectSizeEvent");
static_assert(offsetof(TutorialGuidWidget_SetFingerEffectSizeEvent, FingerSize) == 0x000000, "Member 'TutorialGuidWidget_SetFingerEffectSizeEvent::FingerSize' has a wrong offset!");

// Function MirMobile.TutorialHighlightWidget.SetTypeID
// 0x000C (0x000C - 0x0000)
struct TutorialHighlightWidget_SetTypeID final
{
public:
	int32                                         MainID;                                            // 0x0000(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   TargetName;                                        // 0x0004(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(TutorialHighlightWidget_SetTypeID) == 0x000004, "Wrong alignment on TutorialHighlightWidget_SetTypeID");
static_assert(sizeof(TutorialHighlightWidget_SetTypeID) == 0x00000C, "Wrong size on TutorialHighlightWidget_SetTypeID");
static_assert(offsetof(TutorialHighlightWidget_SetTypeID, MainID) == 0x000000, "Member 'TutorialHighlightWidget_SetTypeID::MainID' has a wrong offset!");
static_assert(offsetof(TutorialHighlightWidget_SetTypeID, TargetName) == 0x000004, "Member 'TutorialHighlightWidget_SetTypeID::TargetName' has a wrong offset!");

// Function MirMobile.TutorialNpcDialog.SetInfo
// 0x0010 (0x0010 - 0x0000)
struct TutorialNpcDialog_SetInfo final
{
public:
	int32                                         IconID;                                            // 0x0000(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         Dialogstringid;                                    // 0x0004(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          Playstartanim;                                     // 0x0008(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_9[0x3];                                        // 0x0009(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         VoiceID;                                           // 0x000C(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(TutorialNpcDialog_SetInfo) == 0x000004, "Wrong alignment on TutorialNpcDialog_SetInfo");
static_assert(sizeof(TutorialNpcDialog_SetInfo) == 0x000010, "Wrong size on TutorialNpcDialog_SetInfo");
static_assert(offsetof(TutorialNpcDialog_SetInfo, IconID) == 0x000000, "Member 'TutorialNpcDialog_SetInfo::IconID' has a wrong offset!");
static_assert(offsetof(TutorialNpcDialog_SetInfo, Dialogstringid) == 0x000004, "Member 'TutorialNpcDialog_SetInfo::Dialogstringid' has a wrong offset!");
static_assert(offsetof(TutorialNpcDialog_SetInfo, Playstartanim) == 0x000008, "Member 'TutorialNpcDialog_SetInfo::Playstartanim' has a wrong offset!");
static_assert(offsetof(TutorialNpcDialog_SetInfo, VoiceID) == 0x00000C, "Member 'TutorialNpcDialog_SetInfo::VoiceID' has a wrong offset!");

// Function MirMobile.WNFreeStopHingeModule.OnChangedDeviceState
// 0x0004 (0x0004 - 0x0000)
struct WNFreeStopHingeModule_OnChangedDeviceState final
{
public:
	EPostureDeviceState                           InDeviceState;                                     // 0x0000(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(WNFreeStopHingeModule_OnChangedDeviceState) == 0x000004, "Wrong alignment on WNFreeStopHingeModule_OnChangedDeviceState");
static_assert(sizeof(WNFreeStopHingeModule_OnChangedDeviceState) == 0x000004, "Wrong size on WNFreeStopHingeModule_OnChangedDeviceState");
static_assert(offsetof(WNFreeStopHingeModule_OnChangedDeviceState, InDeviceState) == 0x000000, "Member 'WNFreeStopHingeModule_OnChangedDeviceState::InDeviceState' has a wrong offset!");

}

